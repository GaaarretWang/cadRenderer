// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SERIALIZATION_FLATBUFFERDOCSPACE_H_
#define FLATBUFFERS_GENERATED_SERIALIZATION_FLATBUFFERDOCSPACE_H_

#include "flatbuffers/flatbuffers.h"

namespace FlatBufferDocSpace {

struct SnapPoint;
struct SnapPointBuilder;

struct ParDirection;
struct ParDirectionBuilder;

struct GeomData;
struct GeomDataBuilder;

struct RelConstraints;
struct RelConstraintsBuilder;

struct MessageData;
struct MessageDataBuilder;

struct GeomLineData;
struct GeomLineDataBuilder;

struct GeomArcData;
struct GeomArcDataBuilder;

struct GeomCircleData;
struct GeomCircleDataBuilder;

struct InterPositionNurbsData;
struct InterPositionNurbsDataBuilder;

struct NurbsCurveData;
struct NurbsCurveDataBuilder;

struct OffsetCurveData;
struct OffsetCurveDataBuilder;

struct EllipseArcData;
struct EllipseArcDataBuilder;

struct EquationCurvecData;
struct EquationCurvecDataBuilder;

struct GeometryPointData;
struct GeometryPointDataBuilder;

struct WorkPlaneData;
struct WorkPlaneDataBuilder;

struct GeometryIdData;
struct GeometryIdDataBuilder;

struct EditInstanceData;
struct EditInstanceDataBuilder;

struct VariableData;
struct VariableDataBuilder;

struct MaterialData;
struct MaterialDataBuilder;

struct ConstraintsData;
struct ConstraintsDataBuilder;

struct SketchTextsData;
struct SketchTextsDataBuilder;

struct SketchParam;
struct SketchParamBuilder;

struct CurrentFeatureData;
struct CurrentFeatureDataBuilder;

struct BoxData;
struct BoxDataBuilder;

struct AttributeGeomData;
struct AttributeGeomDataBuilder;

struct PlaneSurfaceData;
struct PlaneSurfaceDataBuilder;

struct CylSurfaceData;
struct CylSurfaceDataBuilder;

struct RevSrfAttribute;
struct RevSrfAttributeBuilder;

struct TabCylSrfAttribute;
struct TabCylSrfAttributeBuilder;

struct BaseCurveData;
struct BaseCurveDataBuilder;

struct NurbsHandleData;
struct NurbsHandleDataBuilder;

struct AttributeLineData;
struct AttributeLineDataBuilder;

struct AttributeArcData;
struct AttributeArcDataBuilder;

struct AttributeEllipseData;
struct AttributeEllipseDataBuilder;

struct AttributeNurbsData;
struct AttributeNurbsDataBuilder;

struct AttributeCrvOnSrfData;
struct AttributeCrvOnSrfDataBuilder;

struct AttributeOffsetData;
struct AttributeOffsetDataBuilder;

struct AttributeEquationData;
struct AttributeEquationDataBuilder;

struct AttributeData;
struct AttributeDataBuilder;

struct ElementData;
struct ElementDataBuilder;

struct LoopData;
struct LoopDataBuilder;

struct FaceTopoData;
struct FaceTopoDataBuilder;

struct EdgeTopoData;
struct EdgeTopoDataBuilder;

struct VerticeTopoData;
struct VerticeTopoDataBuilder;

struct TopoIdData;
struct TopoIdDataBuilder;

struct SketchLoopData;
struct SketchLoopDataBuilder;

struct SolidSketchTopoData;
struct SolidSketchTopoDataBuilder;

struct BorderData;
struct BorderDataBuilder;

struct EntityData;
struct EntityDataBuilder;

struct SimulationData;
struct SimulationDataBuilder;

struct PreviewSimulationData;
struct PreviewSimulationDataBuilder;

struct StudyData;
struct StudyDataBuilder;

struct EveryLocalGridPrecision;
struct EveryLocalGridPrecisionBuilder;

struct EveryLocalGridElementIds;
struct EveryLocalGridElementIdsBuilder;

struct ExternalLoadsData;
struct ExternalLoadsDataBuilder;

struct TorqueAxisData;
struct TorqueAxisDataBuilder;

struct FixturesData;
struct FixturesDataBuilder;

struct SimulationMaterialData;
struct SimulationMaterialDataBuilder;

struct SimulationGridData;
struct SimulationGridDataBuilder;

struct ConnectionData;
struct ConnectionDataBuilder;

struct DiscreteDatas;
struct DiscreteDatasBuilder;

struct BeadTextureData;
struct BeadTextureDataBuilder;

struct FeatureData;
struct FeatureDataBuilder;

struct DeleteVariable;
struct DeleteVariableBuilder;

struct DeleteAnnotView;
struct DeleteAnnotViewBuilder;

struct CompData;
struct CompDataBuilder;

struct NewMatingData;
struct NewMatingDataBuilder;

struct PickPos;
struct PickPosBuilder;

struct MateRefData;
struct MateRefDataBuilder;

struct InstanceNode;
struct InstanceNodeBuilder;

struct AppearanceData;
struct AppearanceDataBuilder;

struct TextureData;
struct TextureDataBuilder;

struct ProtoDataMessage;
struct ProtoDataMessageBuilder;

struct ViewData;
struct ViewDataBuilder;

struct ViewDataParam;
struct ViewDataParamBuilder;

struct IncrementalData;
struct IncrementalDataBuilder;

struct CutInfoData;
struct CutInfoDataBuilder;

struct CutUserDefData;
struct CutUserDefDataBuilder;

struct CutGroupData;
struct CutGroupDataBuilder;

struct RepeatGroupData;
struct RepeatGroupDataBuilder;

struct AssemblyPartData;
struct AssemblyPartDataBuilder;

struct InitDataForPart;
struct InitDataForPartBuilder;

struct InitDataForAssembly;
struct InitDataForAssemblyBuilder;

struct PlaneAxisData;
struct PlaneAxisDataBuilder;

struct InitCmdData;
struct InitCmdDataBuilder;

struct ArchData;
struct ArchDataBuilder;

struct IncrementalCompData;
struct IncrementalCompDataBuilder;

struct FileStructData;
struct FileStructDataBuilder;

struct FileData;
struct FileDataBuilder;

struct DiscreteData;
struct DiscreteDataBuilder;

struct MatrixData;
struct MatrixDataBuilder;

struct PreviewDataMessage;
struct PreviewDataMessageBuilder;

struct TransformInstanceData;
struct TransformInstanceDataBuilder;

struct TransformDataMessage;
struct TransformDataMessageBuilder;

struct MatInforData;
struct MatInforDataBuilder;

struct AnimationInstanceData;
struct AnimationInstanceDataBuilder;

struct AnimationDataMessage;
struct AnimationDataMessageBuilder;

struct DistanceHandleData;
struct DistanceHandleDataBuilder;

struct AngleHandleData;
struct AngleHandleDataBuilder;

struct RadiusHandleData;
struct RadiusHandleDataBuilder;

struct TangentHandleData;
struct TangentHandleDataBuilder;

struct PointHandleData;
struct PointHandleDataBuilder;

struct MatrixHandleData;
struct MatrixHandleDataBuilder;

struct DirectionHandleData;
struct DirectionHandleDataBuilder;

struct DimensionHandleData;
struct DimensionHandleDataBuilder;

struct HandleDataMessage;
struct HandleDataMessageBuilder;

struct TopoDataMessage;
struct TopoDataMessageBuilder;

struct SerializePreviewData;
struct SerializePreviewDataBuilder;

struct HoleParamDataMessage;
struct HoleParamDataMessageBuilder;

struct CosmeticThreadParamDataMessage;
struct CosmeticThreadParamDataMessageBuilder;

struct SweepPathParamDataMessage;
struct SweepPathParamDataMessageBuilder;

struct SolidPreviewData;
struct SolidPreviewDataBuilder;

struct SpecialPreviewInforData;
struct SpecialPreviewInforDataBuilder;

struct GeometrieData;
struct GeometrieDataBuilder;

struct DiscreteInforData;
struct DiscreteInforDataBuilder;

struct DiscreteGroupData;
struct DiscreteGroupDataBuilder;

struct ConstraintDataMessage;
struct ConstraintDataMessageBuilder;

struct GeometriesData;
struct GeometriesDataBuilder;

struct LeaderTreeData;
struct LeaderTreeDataBuilder;

struct AttributeDataValue;
struct AttributeDataValueBuilder;

struct TextData;
struct TextDataBuilder;

struct DimensionDataMessage;
struct DimensionDataMessageBuilder;

struct SketchPreviewData;
struct SketchPreviewDataBuilder;

struct GapsData;
struct GapsDataBuilder;

struct OverLapsData;
struct OverLapsDataBuilder;

struct SketchCheckData;
struct SketchCheckDataBuilder;

struct DefDataMessage;
struct DefDataMessageBuilder;

struct ArsDataMessage;
struct ArsDataMessageBuilder;

struct DatumPreviewData;
struct DatumPreviewDataBuilder;

struct ArsPreviewData;
struct ArsPreviewDataBuilder;

struct InitOffsetCurveData;
struct InitOffsetCurveDataBuilder;

struct WorkPlaneMatrixData;
struct WorkPlaneMatrixDataBuilder;

struct MeasureInforData;
struct MeasureInforDataBuilder;

struct VariableDataMessage;
struct VariableDataMessageBuilder;

struct DimensionDataInforMessage;
struct DimensionDataInforMessageBuilder;

struct ErrorStringData;
struct ErrorStringDataBuilder;

struct MassPropertyData;
struct MassPropertyDataBuilder;

struct IntegerValue;
struct IntegerValueBuilder;

struct SaveFileData;
struct SaveFileDataBuilder;

struct SaveData;
struct SaveDataBuilder;

struct IdData;
struct IdDataBuilder;

struct CurveCurvature;
struct CurveCurvatureBuilder;

struct CurvatureData;
struct CurvatureDataBuilder;

struct SurfaceCurvature;
struct SurfaceCurvatureBuilder;

struct SurfaceCurvatureData;
struct SurfaceCurvatureDataBuilder;

struct DraftAnalysis;
struct DraftAnalysisBuilder;

struct DraftAnalysisData;
struct DraftAnalysisDataBuilder;

struct ThicknessData;
struct ThicknessDataBuilder;

struct ThicknessAnalysisData;
struct ThicknessAnalysisDataBuilder;

struct CheckGap;
struct CheckGapBuilder;

struct CheckGapData;
struct CheckGapDataBuilder;

struct TotalMassData;
struct TotalMassDataBuilder;

struct CheckVariableData;
struct CheckVariableDataBuilder;

struct TubeData;
struct TubeDataBuilder;

struct PipeDocData;
struct PipeDocDataBuilder;

struct InstanceSuccessData;
struct InstanceSuccessDataBuilder;

struct InstanceFailData;
struct InstanceFailDataBuilder;

struct InstanceInfoData;
struct InstanceInfoDataBuilder;

struct ResultSolvePlane;
struct ResultSolvePlaneBuilder;

struct StudySolveData;
struct StudySolveDataBuilder;

struct StudyReportData;
struct StudyReportDataBuilder;

struct BoundingBoxData;
struct BoundingBoxDataBuilder;

struct TextureInfoData;
struct TextureInfoDataBuilder;

struct SerializeInitData;
struct SerializeInitDataBuilder;

struct DrawingPreviewData;
struct DrawingPreviewDataBuilder;

struct SelectLine;
struct SelectLineBuilder;

struct SectionElement;
struct SectionElementBuilder;

struct DraftSymbolEelement;
struct DraftSymbolEelementBuilder;

struct TableTextData;
struct TableTextDataBuilder;

struct CellInfoData;
struct CellInfoDataBuilder;

struct DelDrawingElement;
struct DelDrawingElementBuilder;

struct LinePnt;
struct LinePntBuilder;

struct AddBreakPts;
struct AddBreakPtsBuilder;

struct SketchData;
struct SketchDataBuilder;

struct BrokenSecElements;
struct BrokenSecElementsBuilder;

struct HatchEdgeElementsData;
struct HatchEdgeElementsDataBuilder;

struct HatchInfoData;
struct HatchInfoDataBuilder;

struct HatchRegionElements;
struct HatchRegionElementsBuilder;

struct ExplodeViewData;
struct ExplodeViewDataBuilder;

struct AddHistInfo;
struct AddHistInfoBuilder;

struct AddSolidInfo;
struct AddSolidInfoBuilder;

struct ViewPropertyData;
struct ViewPropertyDataBuilder;

struct TableInfoData;
struct TableInfoDataBuilder;

struct DrawingViewEntity;
struct DrawingViewEntityBuilder;

struct ChamferDataElement;
struct ChamferDataElementBuilder;

struct CloudPointData;
struct CloudPointDataBuilder;

struct HoleDataElement;
struct HoleDataElementBuilder;

struct HoleTableAxis;
struct HoleTableAxisBuilder;

struct HoleSizeData;
struct HoleSizeDataBuilder;

struct HolePosData;
struct HolePosDataBuilder;

struct CellVariableData;
struct CellVariableDataBuilder;

struct MergeCellsInfoData;
struct MergeCellsInfoDataBuilder;

struct IncrementalDrawingData;
struct IncrementalDrawingDataBuilder;

struct DrawingQueryInfo;
struct DrawingQueryInfoBuilder;

struct DrawingQueryData;
struct DrawingQueryDataBuilder;

struct LineDataElement;
struct LineDataElementBuilder;

struct CenterMarkElement;
struct CenterMarkElementBuilder;

struct DValuesData;
struct DValuesDataBuilder;

struct FolderGroupData;
struct FolderGroupDataBuilder;

struct FeatData;
struct FeatDataBuilder;

struct FeatRelations;
struct FeatRelationsBuilder;

struct ExtRefData;
struct ExtRefDataBuilder;

struct ExtHeadData;
struct ExtHeadDataBuilder;

struct ExtRefTree;
struct ExtRefTreeBuilder;

struct ErrorMessage;
struct ErrorMessageBuilder;

struct HypUpdateMessage;
struct HypUpdateMessageBuilder;

struct LayerDataInfo;
struct LayerDataInfoBuilder;

struct LayerType;
struct LayerTypeBuilder;

struct LayerDataManager;
struct LayerDataManagerBuilder;

struct SignalFeatureInfoData;
struct SignalFeatureInfoDataBuilder;

struct SignalProtoInfoData;
struct SignalProtoInfoDataBuilder;

struct InfoData;
struct InfoDataBuilder;

struct SupportAlignmentTypeData;
struct SupportAlignmentTypeDataBuilder;

struct MainsData;
struct MainsDataBuilder;

struct DrawinfoData;
struct DrawinfoDataBuilder;

struct ListData;
struct ListDataBuilder;

struct ViewDataInfo;
struct ViewDataInfoBuilder;

struct FlatBufferDrawingDoc;
struct FlatBufferDrawingDocBuilder;

struct FlatBufferDoc;
struct FlatBufferDocBuilder;

struct RelIntersDate;
struct RelIntersDateBuilder;

enum GeometryData {
  GeometryData_NONE = 0,
  GeometryData_GeometryPointData = 1,
  GeometryData_GeomLineData = 2,
  GeometryData_GeomArcData = 3,
  GeometryData_GeomCircleData = 4,
  GeometryData_InterPositionNurbsData = 5,
  GeometryData_NurbsCurveData = 6,
  GeometryData_OffsetCurveData = 7,
  GeometryData_EllipseArcData = 8,
  GeometryData_EquationCurvecData = 9,
  GeometryData_MIN = GeometryData_NONE,
  GeometryData_MAX = GeometryData_EquationCurvecData
};

inline const GeometryData (&EnumValuesGeometryData())[10] {
  static const GeometryData values[] = {
    GeometryData_NONE,
    GeometryData_GeometryPointData,
    GeometryData_GeomLineData,
    GeometryData_GeomArcData,
    GeometryData_GeomCircleData,
    GeometryData_InterPositionNurbsData,
    GeometryData_NurbsCurveData,
    GeometryData_OffsetCurveData,
    GeometryData_EllipseArcData,
    GeometryData_EquationCurvecData
  };
  return values;
}

inline const char * const *EnumNamesGeometryData() {
  static const char * const names[11] = {
    "NONE",
    "GeometryPointData",
    "GeomLineData",
    "GeomArcData",
    "GeomCircleData",
    "InterPositionNurbsData",
    "NurbsCurveData",
    "OffsetCurveData",
    "EllipseArcData",
    "EquationCurvecData",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeometryData(GeometryData e) {
  if (flatbuffers::IsOutRange(e, GeometryData_NONE, GeometryData_EquationCurvecData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGeometryData()[index];
}

template<typename T> struct GeometryDataTraits {
  static const GeometryData enum_value = GeometryData_NONE;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::GeometryPointData> {
  static const GeometryData enum_value = GeometryData_GeometryPointData;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::GeomLineData> {
  static const GeometryData enum_value = GeometryData_GeomLineData;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::GeomArcData> {
  static const GeometryData enum_value = GeometryData_GeomArcData;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::GeomCircleData> {
  static const GeometryData enum_value = GeometryData_GeomCircleData;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::InterPositionNurbsData> {
  static const GeometryData enum_value = GeometryData_InterPositionNurbsData;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::NurbsCurveData> {
  static const GeometryData enum_value = GeometryData_NurbsCurveData;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::OffsetCurveData> {
  static const GeometryData enum_value = GeometryData_OffsetCurveData;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::EllipseArcData> {
  static const GeometryData enum_value = GeometryData_EllipseArcData;
};

template<> struct GeometryDataTraits<FlatBufferDocSpace::EquationCurvecData> {
  static const GeometryData enum_value = GeometryData_EquationCurvecData;
};

bool VerifyGeometryData(flatbuffers::Verifier &verifier, const void *obj, GeometryData type);
bool VerifyGeometryDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum AttributeSurfaceData {
  AttributeSurfaceData_NONE = 0,
  AttributeSurfaceData_PlaneSurfaceData = 1,
  AttributeSurfaceData_CylSurfaceData = 2,
  AttributeSurfaceData_RevSrfAttribute = 3,
  AttributeSurfaceData_TabCylSrfAttribute = 4,
  AttributeSurfaceData_MIN = AttributeSurfaceData_NONE,
  AttributeSurfaceData_MAX = AttributeSurfaceData_TabCylSrfAttribute
};

inline const AttributeSurfaceData (&EnumValuesAttributeSurfaceData())[5] {
  static const AttributeSurfaceData values[] = {
    AttributeSurfaceData_NONE,
    AttributeSurfaceData_PlaneSurfaceData,
    AttributeSurfaceData_CylSurfaceData,
    AttributeSurfaceData_RevSrfAttribute,
    AttributeSurfaceData_TabCylSrfAttribute
  };
  return values;
}

inline const char * const *EnumNamesAttributeSurfaceData() {
  static const char * const names[6] = {
    "NONE",
    "PlaneSurfaceData",
    "CylSurfaceData",
    "RevSrfAttribute",
    "TabCylSrfAttribute",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeSurfaceData(AttributeSurfaceData e) {
  if (flatbuffers::IsOutRange(e, AttributeSurfaceData_NONE, AttributeSurfaceData_TabCylSrfAttribute)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeSurfaceData()[index];
}

template<typename T> struct AttributeSurfaceDataTraits {
  static const AttributeSurfaceData enum_value = AttributeSurfaceData_NONE;
};

template<> struct AttributeSurfaceDataTraits<FlatBufferDocSpace::PlaneSurfaceData> {
  static const AttributeSurfaceData enum_value = AttributeSurfaceData_PlaneSurfaceData;
};

template<> struct AttributeSurfaceDataTraits<FlatBufferDocSpace::CylSurfaceData> {
  static const AttributeSurfaceData enum_value = AttributeSurfaceData_CylSurfaceData;
};

template<> struct AttributeSurfaceDataTraits<FlatBufferDocSpace::RevSrfAttribute> {
  static const AttributeSurfaceData enum_value = AttributeSurfaceData_RevSrfAttribute;
};

template<> struct AttributeSurfaceDataTraits<FlatBufferDocSpace::TabCylSrfAttribute> {
  static const AttributeSurfaceData enum_value = AttributeSurfaceData_TabCylSrfAttribute;
};

bool VerifyAttributeSurfaceData(flatbuffers::Verifier &verifier, const void *obj, AttributeSurfaceData type);
bool VerifyAttributeSurfaceDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum AttributeCurveData {
  AttributeCurveData_NONE = 0,
  AttributeCurveData_AttributeLineData = 1,
  AttributeCurveData_AttributeArcData = 2,
  AttributeCurveData_AttributeEllipseData = 3,
  AttributeCurveData_AttributeNurbsData = 4,
  AttributeCurveData_AttributeCrvOnSrfData = 5,
  AttributeCurveData_AttributeOffsetData = 6,
  AttributeCurveData_AttributeEquationData = 7,
  AttributeCurveData_MIN = AttributeCurveData_NONE,
  AttributeCurveData_MAX = AttributeCurveData_AttributeEquationData
};

inline const AttributeCurveData (&EnumValuesAttributeCurveData())[8] {
  static const AttributeCurveData values[] = {
    AttributeCurveData_NONE,
    AttributeCurveData_AttributeLineData,
    AttributeCurveData_AttributeArcData,
    AttributeCurveData_AttributeEllipseData,
    AttributeCurveData_AttributeNurbsData,
    AttributeCurveData_AttributeCrvOnSrfData,
    AttributeCurveData_AttributeOffsetData,
    AttributeCurveData_AttributeEquationData
  };
  return values;
}

inline const char * const *EnumNamesAttributeCurveData() {
  static const char * const names[9] = {
    "NONE",
    "AttributeLineData",
    "AttributeArcData",
    "AttributeEllipseData",
    "AttributeNurbsData",
    "AttributeCrvOnSrfData",
    "AttributeOffsetData",
    "AttributeEquationData",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeCurveData(AttributeCurveData e) {
  if (flatbuffers::IsOutRange(e, AttributeCurveData_NONE, AttributeCurveData_AttributeEquationData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeCurveData()[index];
}

template<typename T> struct AttributeCurveDataTraits {
  static const AttributeCurveData enum_value = AttributeCurveData_NONE;
};

template<> struct AttributeCurveDataTraits<FlatBufferDocSpace::AttributeLineData> {
  static const AttributeCurveData enum_value = AttributeCurveData_AttributeLineData;
};

template<> struct AttributeCurveDataTraits<FlatBufferDocSpace::AttributeArcData> {
  static const AttributeCurveData enum_value = AttributeCurveData_AttributeArcData;
};

template<> struct AttributeCurveDataTraits<FlatBufferDocSpace::AttributeEllipseData> {
  static const AttributeCurveData enum_value = AttributeCurveData_AttributeEllipseData;
};

template<> struct AttributeCurveDataTraits<FlatBufferDocSpace::AttributeNurbsData> {
  static const AttributeCurveData enum_value = AttributeCurveData_AttributeNurbsData;
};

template<> struct AttributeCurveDataTraits<FlatBufferDocSpace::AttributeCrvOnSrfData> {
  static const AttributeCurveData enum_value = AttributeCurveData_AttributeCrvOnSrfData;
};

template<> struct AttributeCurveDataTraits<FlatBufferDocSpace::AttributeOffsetData> {
  static const AttributeCurveData enum_value = AttributeCurveData_AttributeOffsetData;
};

template<> struct AttributeCurveDataTraits<FlatBufferDocSpace::AttributeEquationData> {
  static const AttributeCurveData enum_value = AttributeCurveData_AttributeEquationData;
};

bool VerifyAttributeCurveData(flatbuffers::Verifier &verifier, const void *obj, AttributeCurveData type);
bool VerifyAttributeCurveDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum SimulationEntityData {
  SimulationEntityData_NONE = 0,
  SimulationEntityData_StudyData = 1,
  SimulationEntityData_ExternalLoadsData = 2,
  SimulationEntityData_FixturesData = 3,
  SimulationEntityData_SimulationMaterialData = 4,
  SimulationEntityData_SimulationGridData = 5,
  SimulationEntityData_ConnectionData = 6,
  SimulationEntityData_MIN = SimulationEntityData_NONE,
  SimulationEntityData_MAX = SimulationEntityData_ConnectionData
};

inline const SimulationEntityData (&EnumValuesSimulationEntityData())[7] {
  static const SimulationEntityData values[] = {
    SimulationEntityData_NONE,
    SimulationEntityData_StudyData,
    SimulationEntityData_ExternalLoadsData,
    SimulationEntityData_FixturesData,
    SimulationEntityData_SimulationMaterialData,
    SimulationEntityData_SimulationGridData,
    SimulationEntityData_ConnectionData
  };
  return values;
}

inline const char * const *EnumNamesSimulationEntityData() {
  static const char * const names[8] = {
    "NONE",
    "StudyData",
    "ExternalLoadsData",
    "FixturesData",
    "SimulationMaterialData",
    "SimulationGridData",
    "ConnectionData",
    nullptr
  };
  return names;
}

inline const char *EnumNameSimulationEntityData(SimulationEntityData e) {
  if (flatbuffers::IsOutRange(e, SimulationEntityData_NONE, SimulationEntityData_ConnectionData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSimulationEntityData()[index];
}

template<typename T> struct SimulationEntityDataTraits {
  static const SimulationEntityData enum_value = SimulationEntityData_NONE;
};

template<> struct SimulationEntityDataTraits<FlatBufferDocSpace::StudyData> {
  static const SimulationEntityData enum_value = SimulationEntityData_StudyData;
};

template<> struct SimulationEntityDataTraits<FlatBufferDocSpace::ExternalLoadsData> {
  static const SimulationEntityData enum_value = SimulationEntityData_ExternalLoadsData;
};

template<> struct SimulationEntityDataTraits<FlatBufferDocSpace::FixturesData> {
  static const SimulationEntityData enum_value = SimulationEntityData_FixturesData;
};

template<> struct SimulationEntityDataTraits<FlatBufferDocSpace::SimulationMaterialData> {
  static const SimulationEntityData enum_value = SimulationEntityData_SimulationMaterialData;
};

template<> struct SimulationEntityDataTraits<FlatBufferDocSpace::SimulationGridData> {
  static const SimulationEntityData enum_value = SimulationEntityData_SimulationGridData;
};

template<> struct SimulationEntityDataTraits<FlatBufferDocSpace::ConnectionData> {
  static const SimulationEntityData enum_value = SimulationEntityData_ConnectionData;
};

bool VerifySimulationEntityData(flatbuffers::Verifier &verifier, const void *obj, SimulationEntityData type);
bool VerifySimulationEntityDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum InitDataMessage {
  InitDataMessage_NONE = 0,
  InitDataMessage_InitDataForPart = 1,
  InitDataMessage_InitDataForAssembly = 2,
  InitDataMessage_MIN = InitDataMessage_NONE,
  InitDataMessage_MAX = InitDataMessage_InitDataForAssembly
};

inline const InitDataMessage (&EnumValuesInitDataMessage())[3] {
  static const InitDataMessage values[] = {
    InitDataMessage_NONE,
    InitDataMessage_InitDataForPart,
    InitDataMessage_InitDataForAssembly
  };
  return values;
}

inline const char * const *EnumNamesInitDataMessage() {
  static const char * const names[4] = {
    "NONE",
    "InitDataForPart",
    "InitDataForAssembly",
    nullptr
  };
  return names;
}

inline const char *EnumNameInitDataMessage(InitDataMessage e) {
  if (flatbuffers::IsOutRange(e, InitDataMessage_NONE, InitDataMessage_InitDataForAssembly)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInitDataMessage()[index];
}

template<typename T> struct InitDataMessageTraits {
  static const InitDataMessage enum_value = InitDataMessage_NONE;
};

template<> struct InitDataMessageTraits<FlatBufferDocSpace::InitDataForPart> {
  static const InitDataMessage enum_value = InitDataMessage_InitDataForPart;
};

template<> struct InitDataMessageTraits<FlatBufferDocSpace::InitDataForAssembly> {
  static const InitDataMessage enum_value = InitDataMessage_InitDataForAssembly;
};

bool VerifyInitDataMessage(flatbuffers::Verifier &verifier, const void *obj, InitDataMessage type);
bool VerifyInitDataMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DefineDataMessage {
  DefineDataMessage_NONE = 0,
  DefineDataMessage_DistanceHandleData = 1,
  DefineDataMessage_AngleHandleData = 2,
  DefineDataMessage_RadiusHandleData = 3,
  DefineDataMessage_TangentHandleData = 4,
  DefineDataMessage_PointHandleData = 5,
  DefineDataMessage_MatrixHandleData = 6,
  DefineDataMessage_DirectionHandleData = 7,
  DefineDataMessage_DimensionHandleData = 8,
  DefineDataMessage_MIN = DefineDataMessage_NONE,
  DefineDataMessage_MAX = DefineDataMessage_DimensionHandleData
};

inline const DefineDataMessage (&EnumValuesDefineDataMessage())[9] {
  static const DefineDataMessage values[] = {
    DefineDataMessage_NONE,
    DefineDataMessage_DistanceHandleData,
    DefineDataMessage_AngleHandleData,
    DefineDataMessage_RadiusHandleData,
    DefineDataMessage_TangentHandleData,
    DefineDataMessage_PointHandleData,
    DefineDataMessage_MatrixHandleData,
    DefineDataMessage_DirectionHandleData,
    DefineDataMessage_DimensionHandleData
  };
  return values;
}

inline const char * const *EnumNamesDefineDataMessage() {
  static const char * const names[10] = {
    "NONE",
    "DistanceHandleData",
    "AngleHandleData",
    "RadiusHandleData",
    "TangentHandleData",
    "PointHandleData",
    "MatrixHandleData",
    "DirectionHandleData",
    "DimensionHandleData",
    nullptr
  };
  return names;
}

inline const char *EnumNameDefineDataMessage(DefineDataMessage e) {
  if (flatbuffers::IsOutRange(e, DefineDataMessage_NONE, DefineDataMessage_DimensionHandleData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDefineDataMessage()[index];
}

template<typename T> struct DefineDataMessageTraits {
  static const DefineDataMessage enum_value = DefineDataMessage_NONE;
};

template<> struct DefineDataMessageTraits<FlatBufferDocSpace::DistanceHandleData> {
  static const DefineDataMessage enum_value = DefineDataMessage_DistanceHandleData;
};

template<> struct DefineDataMessageTraits<FlatBufferDocSpace::AngleHandleData> {
  static const DefineDataMessage enum_value = DefineDataMessage_AngleHandleData;
};

template<> struct DefineDataMessageTraits<FlatBufferDocSpace::RadiusHandleData> {
  static const DefineDataMessage enum_value = DefineDataMessage_RadiusHandleData;
};

template<> struct DefineDataMessageTraits<FlatBufferDocSpace::TangentHandleData> {
  static const DefineDataMessage enum_value = DefineDataMessage_TangentHandleData;
};

template<> struct DefineDataMessageTraits<FlatBufferDocSpace::PointHandleData> {
  static const DefineDataMessage enum_value = DefineDataMessage_PointHandleData;
};

template<> struct DefineDataMessageTraits<FlatBufferDocSpace::MatrixHandleData> {
  static const DefineDataMessage enum_value = DefineDataMessage_MatrixHandleData;
};

template<> struct DefineDataMessageTraits<FlatBufferDocSpace::DirectionHandleData> {
  static const DefineDataMessage enum_value = DefineDataMessage_DirectionHandleData;
};

template<> struct DefineDataMessageTraits<FlatBufferDocSpace::DimensionHandleData> {
  static const DefineDataMessage enum_value = DefineDataMessage_DimensionHandleData;
};

bool VerifyDefineDataMessage(flatbuffers::Verifier &verifier, const void *obj, DefineDataMessage type);
bool VerifyDefineDataMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DataMessage {
  DataMessage_NONE = 0,
  DataMessage_IncrementalData = 1,
  DataMessage_AssemblyPartData = 2,
  DataMessage_InitCmdData = 3,
  DataMessage_IncrementalCompData = 4,
  DataMessage_SerializePreviewData = 5,
  DataMessage_SpecialPreviewInforData = 6,
  DataMessage_SketchPreviewData = 7,
  DataMessage_SketchCheckData = 8,
  DataMessage_DatumPreviewData = 9,
  DataMessage_InitOffsetCurveData = 10,
  DataMessage_WorkPlaneMatrixData = 11,
  DataMessage_MeasureInforData = 12,
  DataMessage_VariableDataMessage = 13,
  DataMessage_DimensionDataInforMessage = 14,
  DataMessage_ElementData = 15,
  DataMessage_ErrorStringData = 16,
  DataMessage_MassPropertyData = 17,
  DataMessage_IntegerValue = 18,
  DataMessage_SaveData = 19,
  DataMessage_CurvatureData = 20,
  DataMessage_SurfaceCurvatureData = 21,
  DataMessage_IdData = 22,
  DataMessage_CheckGapData = 23,
  DataMessage_TotalMassData = 24,
  DataMessage_CheckVariableData = 25,
  DataMessage_ArsPreviewData = 26,
  DataMessage_HoleParamDataMessage = 27,
  DataMessage_CosmeticThreadParamDataMessage = 28,
  DataMessage_SweepPathParamDataMessage = 29,
  DataMessage_BoundingBoxData = 30,
  DataMessage_TextureInfoData = 31,
  DataMessage_TorqueAxisData = 32,
  DataMessage_IncrementalDrawingData = 33,
  DataMessage_DrawingPreviewData = 34,
  DataMessage_SerializeInitData = 35,
  DataMessage_FolderGroupData = 36,
  DataMessage_FeatRelations = 37,
  DataMessage_DraftAnalysisData = 38,
  DataMessage_ThicknessAnalysisData = 39,
  DataMessage_PreviewSimulationData = 40,
  DataMessage_ExtRefTree = 41,
  DataMessage_MIN = DataMessage_NONE,
  DataMessage_MAX = DataMessage_ExtRefTree
};

inline const DataMessage (&EnumValuesDataMessage())[42] {
  static const DataMessage values[] = {
    DataMessage_NONE,
    DataMessage_IncrementalData,
    DataMessage_AssemblyPartData,
    DataMessage_InitCmdData,
    DataMessage_IncrementalCompData,
    DataMessage_SerializePreviewData,
    DataMessage_SpecialPreviewInforData,
    DataMessage_SketchPreviewData,
    DataMessage_SketchCheckData,
    DataMessage_DatumPreviewData,
    DataMessage_InitOffsetCurveData,
    DataMessage_WorkPlaneMatrixData,
    DataMessage_MeasureInforData,
    DataMessage_VariableDataMessage,
    DataMessage_DimensionDataInforMessage,
    DataMessage_ElementData,
    DataMessage_ErrorStringData,
    DataMessage_MassPropertyData,
    DataMessage_IntegerValue,
    DataMessage_SaveData,
    DataMessage_CurvatureData,
    DataMessage_SurfaceCurvatureData,
    DataMessage_IdData,
    DataMessage_CheckGapData,
    DataMessage_TotalMassData,
    DataMessage_CheckVariableData,
    DataMessage_ArsPreviewData,
    DataMessage_HoleParamDataMessage,
    DataMessage_CosmeticThreadParamDataMessage,
    DataMessage_SweepPathParamDataMessage,
    DataMessage_BoundingBoxData,
    DataMessage_TextureInfoData,
    DataMessage_TorqueAxisData,
    DataMessage_IncrementalDrawingData,
    DataMessage_DrawingPreviewData,
    DataMessage_SerializeInitData,
    DataMessage_FolderGroupData,
    DataMessage_FeatRelations,
    DataMessage_DraftAnalysisData,
    DataMessage_ThicknessAnalysisData,
    DataMessage_PreviewSimulationData,
    DataMessage_ExtRefTree
  };
  return values;
}

inline const char * const *EnumNamesDataMessage() {
  static const char * const names[43] = {
    "NONE",
    "IncrementalData",
    "AssemblyPartData",
    "InitCmdData",
    "IncrementalCompData",
    "SerializePreviewData",
    "SpecialPreviewInforData",
    "SketchPreviewData",
    "SketchCheckData",
    "DatumPreviewData",
    "InitOffsetCurveData",
    "WorkPlaneMatrixData",
    "MeasureInforData",
    "VariableDataMessage",
    "DimensionDataInforMessage",
    "ElementData",
    "ErrorStringData",
    "MassPropertyData",
    "IntegerValue",
    "SaveData",
    "CurvatureData",
    "SurfaceCurvatureData",
    "IdData",
    "CheckGapData",
    "TotalMassData",
    "CheckVariableData",
    "ArsPreviewData",
    "HoleParamDataMessage",
    "CosmeticThreadParamDataMessage",
    "SweepPathParamDataMessage",
    "BoundingBoxData",
    "TextureInfoData",
    "TorqueAxisData",
    "IncrementalDrawingData",
    "DrawingPreviewData",
    "SerializeInitData",
    "FolderGroupData",
    "FeatRelations",
    "DraftAnalysisData",
    "ThicknessAnalysisData",
    "PreviewSimulationData",
    "ExtRefTree",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataMessage(DataMessage e) {
  if (flatbuffers::IsOutRange(e, DataMessage_NONE, DataMessage_ExtRefTree)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataMessage()[index];
}

template<typename T> struct DataMessageTraits {
  static const DataMessage enum_value = DataMessage_NONE;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::IncrementalData> {
  static const DataMessage enum_value = DataMessage_IncrementalData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::AssemblyPartData> {
  static const DataMessage enum_value = DataMessage_AssemblyPartData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::InitCmdData> {
  static const DataMessage enum_value = DataMessage_InitCmdData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::IncrementalCompData> {
  static const DataMessage enum_value = DataMessage_IncrementalCompData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::SerializePreviewData> {
  static const DataMessage enum_value = DataMessage_SerializePreviewData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::SpecialPreviewInforData> {
  static const DataMessage enum_value = DataMessage_SpecialPreviewInforData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::SketchPreviewData> {
  static const DataMessage enum_value = DataMessage_SketchPreviewData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::SketchCheckData> {
  static const DataMessage enum_value = DataMessage_SketchCheckData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::DatumPreviewData> {
  static const DataMessage enum_value = DataMessage_DatumPreviewData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::InitOffsetCurveData> {
  static const DataMessage enum_value = DataMessage_InitOffsetCurveData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::WorkPlaneMatrixData> {
  static const DataMessage enum_value = DataMessage_WorkPlaneMatrixData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::MeasureInforData> {
  static const DataMessage enum_value = DataMessage_MeasureInforData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::VariableDataMessage> {
  static const DataMessage enum_value = DataMessage_VariableDataMessage;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::DimensionDataInforMessage> {
  static const DataMessage enum_value = DataMessage_DimensionDataInforMessage;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::ElementData> {
  static const DataMessage enum_value = DataMessage_ElementData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::ErrorStringData> {
  static const DataMessage enum_value = DataMessage_ErrorStringData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::MassPropertyData> {
  static const DataMessage enum_value = DataMessage_MassPropertyData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::IntegerValue> {
  static const DataMessage enum_value = DataMessage_IntegerValue;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::SaveData> {
  static const DataMessage enum_value = DataMessage_SaveData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::CurvatureData> {
  static const DataMessage enum_value = DataMessage_CurvatureData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::SurfaceCurvatureData> {
  static const DataMessage enum_value = DataMessage_SurfaceCurvatureData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::IdData> {
  static const DataMessage enum_value = DataMessage_IdData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::CheckGapData> {
  static const DataMessage enum_value = DataMessage_CheckGapData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::TotalMassData> {
  static const DataMessage enum_value = DataMessage_TotalMassData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::CheckVariableData> {
  static const DataMessage enum_value = DataMessage_CheckVariableData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::ArsPreviewData> {
  static const DataMessage enum_value = DataMessage_ArsPreviewData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::HoleParamDataMessage> {
  static const DataMessage enum_value = DataMessage_HoleParamDataMessage;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::CosmeticThreadParamDataMessage> {
  static const DataMessage enum_value = DataMessage_CosmeticThreadParamDataMessage;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::SweepPathParamDataMessage> {
  static const DataMessage enum_value = DataMessage_SweepPathParamDataMessage;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::BoundingBoxData> {
  static const DataMessage enum_value = DataMessage_BoundingBoxData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::TextureInfoData> {
  static const DataMessage enum_value = DataMessage_TextureInfoData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::TorqueAxisData> {
  static const DataMessage enum_value = DataMessage_TorqueAxisData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::IncrementalDrawingData> {
  static const DataMessage enum_value = DataMessage_IncrementalDrawingData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::DrawingPreviewData> {
  static const DataMessage enum_value = DataMessage_DrawingPreviewData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::SerializeInitData> {
  static const DataMessage enum_value = DataMessage_SerializeInitData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::FolderGroupData> {
  static const DataMessage enum_value = DataMessage_FolderGroupData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::FeatRelations> {
  static const DataMessage enum_value = DataMessage_FeatRelations;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::DraftAnalysisData> {
  static const DataMessage enum_value = DataMessage_DraftAnalysisData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::ThicknessAnalysisData> {
  static const DataMessage enum_value = DataMessage_ThicknessAnalysisData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::PreviewSimulationData> {
  static const DataMessage enum_value = DataMessage_PreviewSimulationData;
};

template<> struct DataMessageTraits<FlatBufferDocSpace::ExtRefTree> {
  static const DataMessage enum_value = DataMessage_ExtRefTree;
};

bool VerifyDataMessage(flatbuffers::Verifier &verifier, const void *obj, DataMessage type);
bool VerifyDataMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct SnapPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SnapPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SNAPID = 4,
    VT_COMPID = 6,
    VT_T = 8,
    VT_U = 10,
    VT_V = 12,
    VT_PNT = 14,
    VT_SNAPTYPE = 16,
    VT_POINTTYPE = 18
  };
  int64_t SnapId() const {
    return GetField<int64_t>(VT_SNAPID, 0);
  }
  const flatbuffers::String *CompId() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPID);
  }
  double t() const {
    return GetField<double>(VT_T, 0.0);
  }
  double u() const {
    return GetField<double>(VT_U, 0.0);
  }
  double v() const {
    return GetField<double>(VT_V, 0.0);
  }
  const flatbuffers::Vector<double> *Pnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PNT);
  }
  int32_t SnapType() const {
    return GetField<int32_t>(VT_SNAPTYPE, 0);
  }
  int32_t PointType() const {
    return GetField<int32_t>(VT_POINTTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SNAPID) &&
           VerifyOffset(verifier, VT_COMPID) &&
           verifier.VerifyString(CompId()) &&
           VerifyField<double>(verifier, VT_T) &&
           VerifyField<double>(verifier, VT_U) &&
           VerifyField<double>(verifier, VT_V) &&
           VerifyOffset(verifier, VT_PNT) &&
           verifier.VerifyVector(Pnt()) &&
           VerifyField<int32_t>(verifier, VT_SNAPTYPE) &&
           VerifyField<int32_t>(verifier, VT_POINTTYPE) &&
           verifier.EndTable();
  }
};

struct SnapPointBuilder {
  typedef SnapPoint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SnapId(int64_t SnapId) {
    fbb_.AddElement<int64_t>(SnapPoint::VT_SNAPID, SnapId, 0);
  }
  void add_CompId(flatbuffers::Offset<flatbuffers::String> CompId) {
    fbb_.AddOffset(SnapPoint::VT_COMPID, CompId);
  }
  void add_t(double t) {
    fbb_.AddElement<double>(SnapPoint::VT_T, t, 0.0);
  }
  void add_u(double u) {
    fbb_.AddElement<double>(SnapPoint::VT_U, u, 0.0);
  }
  void add_v(double v) {
    fbb_.AddElement<double>(SnapPoint::VT_V, v, 0.0);
  }
  void add_Pnt(flatbuffers::Offset<flatbuffers::Vector<double>> Pnt) {
    fbb_.AddOffset(SnapPoint::VT_PNT, Pnt);
  }
  void add_SnapType(int32_t SnapType) {
    fbb_.AddElement<int32_t>(SnapPoint::VT_SNAPTYPE, SnapType, 0);
  }
  void add_PointType(int32_t PointType) {
    fbb_.AddElement<int32_t>(SnapPoint::VT_POINTTYPE, PointType, 0);
  }
  explicit SnapPointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SnapPointBuilder &operator=(const SnapPointBuilder &);
  flatbuffers::Offset<SnapPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SnapPoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<SnapPoint> CreateSnapPoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t SnapId = 0,
    flatbuffers::Offset<flatbuffers::String> CompId = 0,
    double t = 0.0,
    double u = 0.0,
    double v = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Pnt = 0,
    int32_t SnapType = 0,
    int32_t PointType = 0) {
  SnapPointBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_u(u);
  builder_.add_t(t);
  builder_.add_SnapId(SnapId);
  builder_.add_PointType(PointType);
  builder_.add_SnapType(SnapType);
  builder_.add_Pnt(Pnt);
  builder_.add_CompId(CompId);
  return builder_.Finish();
}

inline flatbuffers::Offset<SnapPoint> CreateSnapPointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t SnapId = 0,
    const char *CompId = nullptr,
    double t = 0.0,
    double u = 0.0,
    double v = 0.0,
    const std::vector<double> *Pnt = nullptr,
    int32_t SnapType = 0,
    int32_t PointType = 0) {
  auto CompId__ = CompId ? _fbb.CreateString(CompId) : 0;
  auto Pnt__ = Pnt ? _fbb.CreateVector<double>(*Pnt) : 0;
  return FlatBufferDocSpace::CreateSnapPoint(
      _fbb,
      SnapId,
      CompId__,
      t,
      u,
      v,
      Pnt__,
      SnapType,
      PointType);
}

struct ParDirection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParDirectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIRTYPE = 4,
    VT_LINEID = 6,
    VT_COMPID = 8,
    VT_PNT1 = 10,
    VT_PNT2 = 12,
    VT_ROW = 14,
    VT_COL = 16,
    VT_WPDIR = 18
  };
  int32_t DirType() const {
    return GetField<int32_t>(VT_DIRTYPE, 0);
  }
  int32_t LineId() const {
    return GetField<int32_t>(VT_LINEID, 0);
  }
  const flatbuffers::String *CompId() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPID);
  }
  const FlatBufferDocSpace::SnapPoint *Pnt1() const {
    return GetPointer<const FlatBufferDocSpace::SnapPoint *>(VT_PNT1);
  }
  const FlatBufferDocSpace::SnapPoint *Pnt2() const {
    return GetPointer<const FlatBufferDocSpace::SnapPoint *>(VT_PNT2);
  }
  int32_t row() const {
    return GetField<int32_t>(VT_ROW, 0);
  }
  int32_t Col() const {
    return GetField<int32_t>(VT_COL, 0);
  }
  int32_t WpDir() const {
    return GetField<int32_t>(VT_WPDIR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DIRTYPE) &&
           VerifyField<int32_t>(verifier, VT_LINEID) &&
           VerifyOffset(verifier, VT_COMPID) &&
           verifier.VerifyString(CompId()) &&
           VerifyOffset(verifier, VT_PNT1) &&
           verifier.VerifyTable(Pnt1()) &&
           VerifyOffset(verifier, VT_PNT2) &&
           verifier.VerifyTable(Pnt2()) &&
           VerifyField<int32_t>(verifier, VT_ROW) &&
           VerifyField<int32_t>(verifier, VT_COL) &&
           VerifyField<int32_t>(verifier, VT_WPDIR) &&
           verifier.EndTable();
  }
};

struct ParDirectionBuilder {
  typedef ParDirection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DirType(int32_t DirType) {
    fbb_.AddElement<int32_t>(ParDirection::VT_DIRTYPE, DirType, 0);
  }
  void add_LineId(int32_t LineId) {
    fbb_.AddElement<int32_t>(ParDirection::VT_LINEID, LineId, 0);
  }
  void add_CompId(flatbuffers::Offset<flatbuffers::String> CompId) {
    fbb_.AddOffset(ParDirection::VT_COMPID, CompId);
  }
  void add_Pnt1(flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt1) {
    fbb_.AddOffset(ParDirection::VT_PNT1, Pnt1);
  }
  void add_Pnt2(flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt2) {
    fbb_.AddOffset(ParDirection::VT_PNT2, Pnt2);
  }
  void add_row(int32_t row) {
    fbb_.AddElement<int32_t>(ParDirection::VT_ROW, row, 0);
  }
  void add_Col(int32_t Col) {
    fbb_.AddElement<int32_t>(ParDirection::VT_COL, Col, 0);
  }
  void add_WpDir(int32_t WpDir) {
    fbb_.AddElement<int32_t>(ParDirection::VT_WPDIR, WpDir, 0);
  }
  explicit ParDirectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ParDirectionBuilder &operator=(const ParDirectionBuilder &);
  flatbuffers::Offset<ParDirection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParDirection>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParDirection> CreateParDirection(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t DirType = 0,
    int32_t LineId = 0,
    flatbuffers::Offset<flatbuffers::String> CompId = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt1 = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt2 = 0,
    int32_t row = 0,
    int32_t Col = 0,
    int32_t WpDir = 0) {
  ParDirectionBuilder builder_(_fbb);
  builder_.add_WpDir(WpDir);
  builder_.add_Col(Col);
  builder_.add_row(row);
  builder_.add_Pnt2(Pnt2);
  builder_.add_Pnt1(Pnt1);
  builder_.add_CompId(CompId);
  builder_.add_LineId(LineId);
  builder_.add_DirType(DirType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ParDirection> CreateParDirectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t DirType = 0,
    int32_t LineId = 0,
    const char *CompId = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt1 = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt2 = 0,
    int32_t row = 0,
    int32_t Col = 0,
    int32_t WpDir = 0) {
  auto CompId__ = CompId ? _fbb.CreateString(CompId) : 0;
  return FlatBufferDocSpace::CreateParDirection(
      _fbb,
      DirType,
      LineId,
      CompId__,
      Pnt1,
      Pnt2,
      row,
      Col,
      WpDir);
}

struct GeomData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeomDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_L = 4,
    VT_SP = 6,
    VT_EP = 8,
    VT_MP = 10,
    VT_SV = 12,
    VT_EV = 14
  };
  double L() const {
    return GetField<double>(VT_L, 0.0);
  }
  const flatbuffers::Vector<double> *SP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_SP);
  }
  const flatbuffers::Vector<double> *EP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_EP);
  }
  const flatbuffers::Vector<double> *MP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MP);
  }
  const flatbuffers::Vector<double> *SV() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_SV);
  }
  const flatbuffers::Vector<double> *EV() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_EV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_L) &&
           VerifyOffset(verifier, VT_SP) &&
           verifier.VerifyVector(SP()) &&
           VerifyOffset(verifier, VT_EP) &&
           verifier.VerifyVector(EP()) &&
           VerifyOffset(verifier, VT_MP) &&
           verifier.VerifyVector(MP()) &&
           VerifyOffset(verifier, VT_SV) &&
           verifier.VerifyVector(SV()) &&
           VerifyOffset(verifier, VT_EV) &&
           verifier.VerifyVector(EV()) &&
           verifier.EndTable();
  }
};

struct GeomDataBuilder {
  typedef GeomData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_L(double L) {
    fbb_.AddElement<double>(GeomData::VT_L, L, 0.0);
  }
  void add_SP(flatbuffers::Offset<flatbuffers::Vector<double>> SP) {
    fbb_.AddOffset(GeomData::VT_SP, SP);
  }
  void add_EP(flatbuffers::Offset<flatbuffers::Vector<double>> EP) {
    fbb_.AddOffset(GeomData::VT_EP, EP);
  }
  void add_MP(flatbuffers::Offset<flatbuffers::Vector<double>> MP) {
    fbb_.AddOffset(GeomData::VT_MP, MP);
  }
  void add_SV(flatbuffers::Offset<flatbuffers::Vector<double>> SV) {
    fbb_.AddOffset(GeomData::VT_SV, SV);
  }
  void add_EV(flatbuffers::Offset<flatbuffers::Vector<double>> EV) {
    fbb_.AddOffset(GeomData::VT_EV, EV);
  }
  explicit GeomDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeomDataBuilder &operator=(const GeomDataBuilder &);
  flatbuffers::Offset<GeomData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeomData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeomData> CreateGeomData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double L = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> SP = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EP = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MP = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> SV = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EV = 0) {
  GeomDataBuilder builder_(_fbb);
  builder_.add_L(L);
  builder_.add_EV(EV);
  builder_.add_SV(SV);
  builder_.add_MP(MP);
  builder_.add_EP(EP);
  builder_.add_SP(SP);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeomData> CreateGeomDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double L = 0.0,
    const std::vector<double> *SP = nullptr,
    const std::vector<double> *EP = nullptr,
    const std::vector<double> *MP = nullptr,
    const std::vector<double> *SV = nullptr,
    const std::vector<double> *EV = nullptr) {
  auto SP__ = SP ? _fbb.CreateVector<double>(*SP) : 0;
  auto EP__ = EP ? _fbb.CreateVector<double>(*EP) : 0;
  auto MP__ = MP ? _fbb.CreateVector<double>(*MP) : 0;
  auto SV__ = SV ? _fbb.CreateVector<double>(*SV) : 0;
  auto EV__ = EV ? _fbb.CreateVector<double>(*EV) : 0;
  return FlatBufferDocSpace::CreateGeomData(
      _fbb,
      L,
      SP__,
      EP__,
      MP__,
      SV__,
      EV__);
}

struct RelConstraints FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelConstraintsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMENSIONS = 4,
    VT_LOGICS = 6
  };
  const flatbuffers::Vector<int32_t> *Dimensions() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMENSIONS);
  }
  const flatbuffers::Vector<int32_t> *Logics() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LOGICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMENSIONS) &&
           verifier.VerifyVector(Dimensions()) &&
           VerifyOffset(verifier, VT_LOGICS) &&
           verifier.VerifyVector(Logics()) &&
           verifier.EndTable();
  }
};

struct RelConstraintsBuilder {
  typedef RelConstraints Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Dimensions(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Dimensions) {
    fbb_.AddOffset(RelConstraints::VT_DIMENSIONS, Dimensions);
  }
  void add_Logics(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Logics) {
    fbb_.AddOffset(RelConstraints::VT_LOGICS, Logics);
  }
  explicit RelConstraintsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelConstraintsBuilder &operator=(const RelConstraintsBuilder &);
  flatbuffers::Offset<RelConstraints> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelConstraints>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelConstraints> CreateRelConstraints(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Dimensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Logics = 0) {
  RelConstraintsBuilder builder_(_fbb);
  builder_.add_Logics(Logics);
  builder_.add_Dimensions(Dimensions);
  return builder_.Finish();
}

inline flatbuffers::Offset<RelConstraints> CreateRelConstraintsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *Dimensions = nullptr,
    const std::vector<int32_t> *Logics = nullptr) {
  auto Dimensions__ = Dimensions ? _fbb.CreateVector<int32_t>(*Dimensions) : 0;
  auto Logics__ = Logics ? _fbb.CreateVector<int32_t>(*Logics) : 0;
  return FlatBufferDocSpace::CreateRelConstraints(
      _fbb,
      Dimensions__,
      Logics__);
}

struct MessageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_CONSTRAINTS = 6,
    VT_REFERENCE = 8,
    VT_STATUS = 10,
    VT_SNAPSTATUS = 12,
    VT_AUXILIARY = 14,
    VT_INTERSPOINT = 16
  };
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const FlatBufferDocSpace::RelConstraints *Constraints() const {
    return GetPointer<const FlatBufferDocSpace::RelConstraints *>(VT_CONSTRAINTS);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  const flatbuffers::Vector<int32_t> *SnapStatus() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SNAPSTATUS);
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  const FlatBufferDocSpace::RelIntersDate *IntersPoint() const {
    return GetPointer<const FlatBufferDocSpace::RelIntersDate *>(VT_INTERSPOINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_CONSTRAINTS) &&
           verifier.VerifyTable(Constraints()) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_SNAPSTATUS) &&
           verifier.VerifyVector(SnapStatus()) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           VerifyOffset(verifier, VT_INTERSPOINT) &&
           verifier.VerifyTable(IntersPoint()) &&
           verifier.EndTable();
  }
};

struct MessageDataBuilder {
  typedef MessageData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(MessageData::VT_INDEX, Index, 0);
  }
  void add_Constraints(flatbuffers::Offset<FlatBufferDocSpace::RelConstraints> Constraints) {
    fbb_.AddOffset(MessageData::VT_CONSTRAINTS, Constraints);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(MessageData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(MessageData::VT_STATUS, Status, 0);
  }
  void add_SnapStatus(flatbuffers::Offset<flatbuffers::Vector<int32_t>> SnapStatus) {
    fbb_.AddOffset(MessageData::VT_SNAPSTATUS, SnapStatus);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(MessageData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  void add_IntersPoint(flatbuffers::Offset<FlatBufferDocSpace::RelIntersDate> IntersPoint) {
    fbb_.AddOffset(MessageData::VT_INTERSPOINT, IntersPoint);
  }
  explicit MessageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageDataBuilder &operator=(const MessageDataBuilder &);
  flatbuffers::Offset<MessageData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageData> CreateMessageData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = 0,
    flatbuffers::Offset<FlatBufferDocSpace::RelConstraints> Constraints = 0,
    bool Reference = false,
    int32_t Status = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> SnapStatus = 0,
    bool Auxiliary = false,
    flatbuffers::Offset<FlatBufferDocSpace::RelIntersDate> IntersPoint = 0) {
  MessageDataBuilder builder_(_fbb);
  builder_.add_IntersPoint(IntersPoint);
  builder_.add_SnapStatus(SnapStatus);
  builder_.add_Status(Status);
  builder_.add_Constraints(Constraints);
  builder_.add_Index(Index);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageData> CreateMessageDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = 0,
    flatbuffers::Offset<FlatBufferDocSpace::RelConstraints> Constraints = 0,
    bool Reference = false,
    int32_t Status = 0,
    const std::vector<int32_t> *SnapStatus = nullptr,
    bool Auxiliary = false,
    flatbuffers::Offset<FlatBufferDocSpace::RelIntersDate> IntersPoint = 0) {
  auto SnapStatus__ = SnapStatus ? _fbb.CreateVector<int32_t>(*SnapStatus) : 0;
  return FlatBufferDocSpace::CreateMessageData(
      _fbb,
      Index,
      Constraints,
      Reference,
      Status,
      SnapStatus__,
      Auxiliary,
      IntersPoint);
}

struct GeomLineData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeomLineDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_INDEX = 8,
    VT_REFERENCE = 10,
    VT_STARTPNT = 12,
    VT_ENDPNT = 14,
    VT_AUXILIARY = 16
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  const flatbuffers::Vector<double> *StartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTPNT);
  }
  const flatbuffers::Vector<double> *EndPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDPNT);
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyOffset(verifier, VT_STARTPNT) &&
           verifier.VerifyVector(StartPnt()) &&
           VerifyOffset(verifier, VT_ENDPNT) &&
           verifier.VerifyVector(EndPnt()) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           verifier.EndTable();
  }
};

struct GeomLineDataBuilder {
  typedef GeomLineData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(GeomLineData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(GeomLineData::VT_GT, GT, 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(GeomLineData::VT_INDEX, Index, 0);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(GeomLineData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_StartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt) {
    fbb_.AddOffset(GeomLineData::VT_STARTPNT, StartPnt);
  }
  void add_EndPnt(flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt) {
    fbb_.AddOffset(GeomLineData::VT_ENDPNT, EndPnt);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(GeomLineData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  explicit GeomLineDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeomLineDataBuilder &operator=(const GeomLineDataBuilder &);
  flatbuffers::Offset<GeomLineData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeomLineData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeomLineData> CreateGeomLineData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt = 0,
    bool Auxiliary = false) {
  GeomLineDataBuilder builder_(_fbb);
  builder_.add_EndPnt(EndPnt);
  builder_.add_StartPnt(StartPnt);
  builder_.add_Index(Index);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeomLineData> CreateGeomLineDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    const std::vector<double> *StartPnt = nullptr,
    const std::vector<double> *EndPnt = nullptr,
    bool Auxiliary = false) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto StartPnt__ = StartPnt ? _fbb.CreateVector<double>(*StartPnt) : 0;
  auto EndPnt__ = EndPnt ? _fbb.CreateVector<double>(*EndPnt) : 0;
  return FlatBufferDocSpace::CreateGeomLineData(
      _fbb,
      TopoId__,
      GT,
      Index,
      Reference,
      StartPnt__,
      EndPnt__,
      Auxiliary);
}

struct GeomArcData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeomArcDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_INDEX = 8,
    VT_REFERENCE = 10,
    VT_STARTPNT = 12,
    VT_MIDPNT = 14,
    VT_ENDPNT = 16,
    VT_NORMAL = 18,
    VT_AUXILIARY = 20
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  const flatbuffers::Vector<double> *StartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTPNT);
  }
  const flatbuffers::Vector<double> *MidPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MIDPNT);
  }
  const flatbuffers::Vector<double> *EndPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDPNT);
  }
  const flatbuffers::Vector<double> *Normal() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_NORMAL);
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyOffset(verifier, VT_STARTPNT) &&
           verifier.VerifyVector(StartPnt()) &&
           VerifyOffset(verifier, VT_MIDPNT) &&
           verifier.VerifyVector(MidPnt()) &&
           VerifyOffset(verifier, VT_ENDPNT) &&
           verifier.VerifyVector(EndPnt()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyVector(Normal()) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           verifier.EndTable();
  }
};

struct GeomArcDataBuilder {
  typedef GeomArcData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(GeomArcData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(GeomArcData::VT_GT, GT, 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(GeomArcData::VT_INDEX, Index, 0);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(GeomArcData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_StartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt) {
    fbb_.AddOffset(GeomArcData::VT_STARTPNT, StartPnt);
  }
  void add_MidPnt(flatbuffers::Offset<flatbuffers::Vector<double>> MidPnt) {
    fbb_.AddOffset(GeomArcData::VT_MIDPNT, MidPnt);
  }
  void add_EndPnt(flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt) {
    fbb_.AddOffset(GeomArcData::VT_ENDPNT, EndPnt);
  }
  void add_Normal(flatbuffers::Offset<flatbuffers::Vector<double>> Normal) {
    fbb_.AddOffset(GeomArcData::VT_NORMAL, Normal);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(GeomArcData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  explicit GeomArcDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeomArcDataBuilder &operator=(const GeomArcDataBuilder &);
  flatbuffers::Offset<GeomArcData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeomArcData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeomArcData> CreateGeomArcData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MidPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Normal = 0,
    bool Auxiliary = false) {
  GeomArcDataBuilder builder_(_fbb);
  builder_.add_Normal(Normal);
  builder_.add_EndPnt(EndPnt);
  builder_.add_MidPnt(MidPnt);
  builder_.add_StartPnt(StartPnt);
  builder_.add_Index(Index);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeomArcData> CreateGeomArcDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    const std::vector<double> *StartPnt = nullptr,
    const std::vector<double> *MidPnt = nullptr,
    const std::vector<double> *EndPnt = nullptr,
    const std::vector<double> *Normal = nullptr,
    bool Auxiliary = false) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto StartPnt__ = StartPnt ? _fbb.CreateVector<double>(*StartPnt) : 0;
  auto MidPnt__ = MidPnt ? _fbb.CreateVector<double>(*MidPnt) : 0;
  auto EndPnt__ = EndPnt ? _fbb.CreateVector<double>(*EndPnt) : 0;
  auto Normal__ = Normal ? _fbb.CreateVector<double>(*Normal) : 0;
  return FlatBufferDocSpace::CreateGeomArcData(
      _fbb,
      TopoId__,
      GT,
      Index,
      Reference,
      StartPnt__,
      MidPnt__,
      EndPnt__,
      Normal__,
      Auxiliary);
}

struct GeomCircleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeomCircleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_INDEX = 8,
    VT_REFERENCE = 10,
    VT_STARTPNT = 12,
    VT_CENTERPNT = 14,
    VT_NORMAL = 16,
    VT_AUXILIARY = 18
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  const flatbuffers::Vector<double> *StartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTPNT);
  }
  const flatbuffers::Vector<double> *CenterPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CENTERPNT);
  }
  const flatbuffers::Vector<double> *Normal() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_NORMAL);
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyOffset(verifier, VT_STARTPNT) &&
           verifier.VerifyVector(StartPnt()) &&
           VerifyOffset(verifier, VT_CENTERPNT) &&
           verifier.VerifyVector(CenterPnt()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyVector(Normal()) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           verifier.EndTable();
  }
};

struct GeomCircleDataBuilder {
  typedef GeomCircleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(GeomCircleData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(GeomCircleData::VT_GT, GT, 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(GeomCircleData::VT_INDEX, Index, 0);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(GeomCircleData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_StartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt) {
    fbb_.AddOffset(GeomCircleData::VT_STARTPNT, StartPnt);
  }
  void add_CenterPnt(flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt) {
    fbb_.AddOffset(GeomCircleData::VT_CENTERPNT, CenterPnt);
  }
  void add_Normal(flatbuffers::Offset<flatbuffers::Vector<double>> Normal) {
    fbb_.AddOffset(GeomCircleData::VT_NORMAL, Normal);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(GeomCircleData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  explicit GeomCircleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeomCircleDataBuilder &operator=(const GeomCircleDataBuilder &);
  flatbuffers::Offset<GeomCircleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeomCircleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeomCircleData> CreateGeomCircleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Normal = 0,
    bool Auxiliary = false) {
  GeomCircleDataBuilder builder_(_fbb);
  builder_.add_Normal(Normal);
  builder_.add_CenterPnt(CenterPnt);
  builder_.add_StartPnt(StartPnt);
  builder_.add_Index(Index);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeomCircleData> CreateGeomCircleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    const std::vector<double> *StartPnt = nullptr,
    const std::vector<double> *CenterPnt = nullptr,
    const std::vector<double> *Normal = nullptr,
    bool Auxiliary = false) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto StartPnt__ = StartPnt ? _fbb.CreateVector<double>(*StartPnt) : 0;
  auto CenterPnt__ = CenterPnt ? _fbb.CreateVector<double>(*CenterPnt) : 0;
  auto Normal__ = Normal ? _fbb.CreateVector<double>(*Normal) : 0;
  return FlatBufferDocSpace::CreateGeomCircleData(
      _fbb,
      TopoId__,
      GT,
      Index,
      Reference,
      StartPnt__,
      CenterPnt__,
      Normal__,
      Auxiliary);
}

struct InterPositionNurbsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterPositionNurbsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_INDEX = 8,
    VT_REFERENCE = 10,
    VT_ISCLOSED = 12,
    VT_MAGNITUDE = 14,
    VT_DIRECTIONS = 16,
    VT_PICKPNTS = 18,
    VT_AUXILIARY = 20,
    VT_SCL = 22
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  bool IsClosed() const {
    return GetField<uint8_t>(VT_ISCLOSED, 0) != 0;
  }
  const flatbuffers::Vector<double> *Magnitude() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAGNITUDE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ParDirection>> *Directions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ParDirection>> *>(VT_DIRECTIONS);
  }
  const flatbuffers::Vector<double> *PickPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PICKPNTS);
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  bool SCL() const {
    return GetField<uint8_t>(VT_SCL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyField<uint8_t>(verifier, VT_ISCLOSED) &&
           VerifyOffset(verifier, VT_MAGNITUDE) &&
           verifier.VerifyVector(Magnitude()) &&
           VerifyOffset(verifier, VT_DIRECTIONS) &&
           verifier.VerifyVector(Directions()) &&
           verifier.VerifyVectorOfTables(Directions()) &&
           VerifyOffset(verifier, VT_PICKPNTS) &&
           verifier.VerifyVector(PickPnts()) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           VerifyField<uint8_t>(verifier, VT_SCL) &&
           verifier.EndTable();
  }
};

struct InterPositionNurbsDataBuilder {
  typedef InterPositionNurbsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(InterPositionNurbsData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(InterPositionNurbsData::VT_GT, GT, 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(InterPositionNurbsData::VT_INDEX, Index, 0);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(InterPositionNurbsData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_IsClosed(bool IsClosed) {
    fbb_.AddElement<uint8_t>(InterPositionNurbsData::VT_ISCLOSED, static_cast<uint8_t>(IsClosed), 0);
  }
  void add_Magnitude(flatbuffers::Offset<flatbuffers::Vector<double>> Magnitude) {
    fbb_.AddOffset(InterPositionNurbsData::VT_MAGNITUDE, Magnitude);
  }
  void add_Directions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ParDirection>>> Directions) {
    fbb_.AddOffset(InterPositionNurbsData::VT_DIRECTIONS, Directions);
  }
  void add_PickPnts(flatbuffers::Offset<flatbuffers::Vector<double>> PickPnts) {
    fbb_.AddOffset(InterPositionNurbsData::VT_PICKPNTS, PickPnts);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(InterPositionNurbsData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  void add_SCL(bool SCL) {
    fbb_.AddElement<uint8_t>(InterPositionNurbsData::VT_SCL, static_cast<uint8_t>(SCL), 0);
  }
  explicit InterPositionNurbsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InterPositionNurbsDataBuilder &operator=(const InterPositionNurbsDataBuilder &);
  flatbuffers::Offset<InterPositionNurbsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InterPositionNurbsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<InterPositionNurbsData> CreateInterPositionNurbsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    bool IsClosed = false,
    flatbuffers::Offset<flatbuffers::Vector<double>> Magnitude = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ParDirection>>> Directions = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> PickPnts = 0,
    bool Auxiliary = false,
    bool SCL = false) {
  InterPositionNurbsDataBuilder builder_(_fbb);
  builder_.add_PickPnts(PickPnts);
  builder_.add_Directions(Directions);
  builder_.add_Magnitude(Magnitude);
  builder_.add_Index(Index);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  builder_.add_SCL(SCL);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_IsClosed(IsClosed);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<InterPositionNurbsData> CreateInterPositionNurbsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    bool IsClosed = false,
    const std::vector<double> *Magnitude = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ParDirection>> *Directions = nullptr,
    const std::vector<double> *PickPnts = nullptr,
    bool Auxiliary = false,
    bool SCL = false) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto Magnitude__ = Magnitude ? _fbb.CreateVector<double>(*Magnitude) : 0;
  auto Directions__ = Directions ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ParDirection>>(*Directions) : 0;
  auto PickPnts__ = PickPnts ? _fbb.CreateVector<double>(*PickPnts) : 0;
  return FlatBufferDocSpace::CreateInterPositionNurbsData(
      _fbb,
      TopoId__,
      GT,
      Index,
      Reference,
      IsClosed,
      Magnitude__,
      Directions__,
      PickPnts__,
      Auxiliary,
      SCL);
}

struct NurbsCurveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NurbsCurveDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_INDEX = 8,
    VT_REFERENCE = 10,
    VT_CPS = 12,
    VT_W = 14,
    VT_K = 16,
    VT_B0 = 18,
    VT_B1 = 20,
    VT_D = 22,
    VT_P = 24,
    VT_AUXILIARY = 26,
    VT_SCL = 28,
    VT_ISCLOSED = 30
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  const flatbuffers::Vector<double> *CPS() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CPS);
  }
  const flatbuffers::Vector<double> *W() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_W);
  }
  const flatbuffers::Vector<double> *K() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_K);
  }
  double B0() const {
    return GetField<double>(VT_B0, 0.0);
  }
  double B1() const {
    return GetField<double>(VT_B1, 0.0);
  }
  int32_t D() const {
    return GetField<int32_t>(VT_D, 0);
  }
  bool P() const {
    return GetField<uint8_t>(VT_P, 0) != 0;
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  bool SCL() const {
    return GetField<uint8_t>(VT_SCL, 0) != 0;
  }
  bool IsClosed() const {
    return GetField<uint8_t>(VT_ISCLOSED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyOffset(verifier, VT_CPS) &&
           verifier.VerifyVector(CPS()) &&
           VerifyOffset(verifier, VT_W) &&
           verifier.VerifyVector(W()) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.VerifyVector(K()) &&
           VerifyField<double>(verifier, VT_B0) &&
           VerifyField<double>(verifier, VT_B1) &&
           VerifyField<int32_t>(verifier, VT_D) &&
           VerifyField<uint8_t>(verifier, VT_P) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           VerifyField<uint8_t>(verifier, VT_SCL) &&
           VerifyField<uint8_t>(verifier, VT_ISCLOSED) &&
           verifier.EndTable();
  }
};

struct NurbsCurveDataBuilder {
  typedef NurbsCurveData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(NurbsCurveData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(NurbsCurveData::VT_GT, GT, 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(NurbsCurveData::VT_INDEX, Index, 0);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(NurbsCurveData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_CPS(flatbuffers::Offset<flatbuffers::Vector<double>> CPS) {
    fbb_.AddOffset(NurbsCurveData::VT_CPS, CPS);
  }
  void add_W(flatbuffers::Offset<flatbuffers::Vector<double>> W) {
    fbb_.AddOffset(NurbsCurveData::VT_W, W);
  }
  void add_K(flatbuffers::Offset<flatbuffers::Vector<double>> K) {
    fbb_.AddOffset(NurbsCurveData::VT_K, K);
  }
  void add_B0(double B0) {
    fbb_.AddElement<double>(NurbsCurveData::VT_B0, B0, 0.0);
  }
  void add_B1(double B1) {
    fbb_.AddElement<double>(NurbsCurveData::VT_B1, B1, 0.0);
  }
  void add_D(int32_t D) {
    fbb_.AddElement<int32_t>(NurbsCurveData::VT_D, D, 0);
  }
  void add_P(bool P) {
    fbb_.AddElement<uint8_t>(NurbsCurveData::VT_P, static_cast<uint8_t>(P), 0);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(NurbsCurveData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  void add_SCL(bool SCL) {
    fbb_.AddElement<uint8_t>(NurbsCurveData::VT_SCL, static_cast<uint8_t>(SCL), 0);
  }
  void add_IsClosed(bool IsClosed) {
    fbb_.AddElement<uint8_t>(NurbsCurveData::VT_ISCLOSED, static_cast<uint8_t>(IsClosed), 0);
  }
  explicit NurbsCurveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NurbsCurveDataBuilder &operator=(const NurbsCurveDataBuilder &);
  flatbuffers::Offset<NurbsCurveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NurbsCurveData>(end);
    return o;
  }
};

inline flatbuffers::Offset<NurbsCurveData> CreateNurbsCurveData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    flatbuffers::Offset<flatbuffers::Vector<double>> CPS = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> W = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> K = 0,
    double B0 = 0.0,
    double B1 = 0.0,
    int32_t D = 0,
    bool P = false,
    bool Auxiliary = false,
    bool SCL = false,
    bool IsClosed = false) {
  NurbsCurveDataBuilder builder_(_fbb);
  builder_.add_B1(B1);
  builder_.add_B0(B0);
  builder_.add_D(D);
  builder_.add_K(K);
  builder_.add_W(W);
  builder_.add_CPS(CPS);
  builder_.add_Index(Index);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  builder_.add_IsClosed(IsClosed);
  builder_.add_SCL(SCL);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_P(P);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<NurbsCurveData> CreateNurbsCurveDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    const std::vector<double> *CPS = nullptr,
    const std::vector<double> *W = nullptr,
    const std::vector<double> *K = nullptr,
    double B0 = 0.0,
    double B1 = 0.0,
    int32_t D = 0,
    bool P = false,
    bool Auxiliary = false,
    bool SCL = false,
    bool IsClosed = false) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto CPS__ = CPS ? _fbb.CreateVector<double>(*CPS) : 0;
  auto W__ = W ? _fbb.CreateVector<double>(*W) : 0;
  auto K__ = K ? _fbb.CreateVector<double>(*K) : 0;
  return FlatBufferDocSpace::CreateNurbsCurveData(
      _fbb,
      TopoId__,
      GT,
      Index,
      Reference,
      CPS__,
      W__,
      K__,
      B0,
      B1,
      D,
      P,
      Auxiliary,
      SCL,
      IsClosed);
}

struct OffsetCurveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OffsetCurveDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_INDEX = 8,
    VT_REFERENCE = 10,
    VT_BASECURVE = 12,
    VT_OFFSETDIS = 14,
    VT_OFFSETDIR = 16,
    VT_SWP = 18,
    VT_B0 = 20,
    VT_B1 = 22,
    VT_AUXILIARY = 24,
    VT_BASECURVETYPE = 26,
    VT_ISCLOSED = 28
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  const FlatBufferDocSpace::BaseCurveData *BaseCurve() const {
    return GetPointer<const FlatBufferDocSpace::BaseCurveData *>(VT_BASECURVE);
  }
  double OffsetDis() const {
    return GetField<double>(VT_OFFSETDIS, 0.0);
  }
  const flatbuffers::Vector<double> *OffsetDir() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_OFFSETDIR);
  }
  int32_t Swp() const {
    return GetField<int32_t>(VT_SWP, 0);
  }
  double B0() const {
    return GetField<double>(VT_B0, 0.0);
  }
  double B1() const {
    return GetField<double>(VT_B1, 0.0);
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  int32_t BaseCurveType() const {
    return GetField<int32_t>(VT_BASECURVETYPE, 0);
  }
  bool IsClosed() const {
    return GetField<uint8_t>(VT_ISCLOSED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyOffset(verifier, VT_BASECURVE) &&
           verifier.VerifyTable(BaseCurve()) &&
           VerifyField<double>(verifier, VT_OFFSETDIS) &&
           VerifyOffset(verifier, VT_OFFSETDIR) &&
           verifier.VerifyVector(OffsetDir()) &&
           VerifyField<int32_t>(verifier, VT_SWP) &&
           VerifyField<double>(verifier, VT_B0) &&
           VerifyField<double>(verifier, VT_B1) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           VerifyField<int32_t>(verifier, VT_BASECURVETYPE) &&
           VerifyField<uint8_t>(verifier, VT_ISCLOSED) &&
           verifier.EndTable();
  }
};

struct OffsetCurveDataBuilder {
  typedef OffsetCurveData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(OffsetCurveData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(OffsetCurveData::VT_GT, GT, 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(OffsetCurveData::VT_INDEX, Index, 0);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(OffsetCurveData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_BaseCurve(flatbuffers::Offset<FlatBufferDocSpace::BaseCurveData> BaseCurve) {
    fbb_.AddOffset(OffsetCurveData::VT_BASECURVE, BaseCurve);
  }
  void add_OffsetDis(double OffsetDis) {
    fbb_.AddElement<double>(OffsetCurveData::VT_OFFSETDIS, OffsetDis, 0.0);
  }
  void add_OffsetDir(flatbuffers::Offset<flatbuffers::Vector<double>> OffsetDir) {
    fbb_.AddOffset(OffsetCurveData::VT_OFFSETDIR, OffsetDir);
  }
  void add_Swp(int32_t Swp) {
    fbb_.AddElement<int32_t>(OffsetCurveData::VT_SWP, Swp, 0);
  }
  void add_B0(double B0) {
    fbb_.AddElement<double>(OffsetCurveData::VT_B0, B0, 0.0);
  }
  void add_B1(double B1) {
    fbb_.AddElement<double>(OffsetCurveData::VT_B1, B1, 0.0);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(OffsetCurveData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  void add_BaseCurveType(int32_t BaseCurveType) {
    fbb_.AddElement<int32_t>(OffsetCurveData::VT_BASECURVETYPE, BaseCurveType, 0);
  }
  void add_IsClosed(bool IsClosed) {
    fbb_.AddElement<uint8_t>(OffsetCurveData::VT_ISCLOSED, static_cast<uint8_t>(IsClosed), 0);
  }
  explicit OffsetCurveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OffsetCurveDataBuilder &operator=(const OffsetCurveDataBuilder &);
  flatbuffers::Offset<OffsetCurveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OffsetCurveData>(end);
    return o;
  }
};

inline flatbuffers::Offset<OffsetCurveData> CreateOffsetCurveData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    flatbuffers::Offset<FlatBufferDocSpace::BaseCurveData> BaseCurve = 0,
    double OffsetDis = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> OffsetDir = 0,
    int32_t Swp = 0,
    double B0 = 0.0,
    double B1 = 0.0,
    bool Auxiliary = false,
    int32_t BaseCurveType = 0,
    bool IsClosed = false) {
  OffsetCurveDataBuilder builder_(_fbb);
  builder_.add_B1(B1);
  builder_.add_B0(B0);
  builder_.add_OffsetDis(OffsetDis);
  builder_.add_BaseCurveType(BaseCurveType);
  builder_.add_Swp(Swp);
  builder_.add_OffsetDir(OffsetDir);
  builder_.add_BaseCurve(BaseCurve);
  builder_.add_Index(Index);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  builder_.add_IsClosed(IsClosed);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<OffsetCurveData> CreateOffsetCurveDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    flatbuffers::Offset<FlatBufferDocSpace::BaseCurveData> BaseCurve = 0,
    double OffsetDis = 0.0,
    const std::vector<double> *OffsetDir = nullptr,
    int32_t Swp = 0,
    double B0 = 0.0,
    double B1 = 0.0,
    bool Auxiliary = false,
    int32_t BaseCurveType = 0,
    bool IsClosed = false) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto OffsetDir__ = OffsetDir ? _fbb.CreateVector<double>(*OffsetDir) : 0;
  return FlatBufferDocSpace::CreateOffsetCurveData(
      _fbb,
      TopoId__,
      GT,
      Index,
      Reference,
      BaseCurve,
      OffsetDis,
      OffsetDir__,
      Swp,
      B0,
      B1,
      Auxiliary,
      BaseCurveType,
      IsClosed);
}

struct EllipseArcData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EllipseArcDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_INDEX = 8,
    VT_REFERENCE = 10,
    VT_CENTERPNT = 12,
    VT_MINORPNT = 14,
    VT_MAJORPNT = 16,
    VT_SA = 18,
    VT_EA = 20,
    VT_AUXILIARY = 22
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  const flatbuffers::Vector<double> *CenterPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CENTERPNT);
  }
  const flatbuffers::Vector<double> *MinorPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MINORPNT);
  }
  const flatbuffers::Vector<double> *MajorPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAJORPNT);
  }
  double SA() const {
    return GetField<double>(VT_SA, 0.0);
  }
  double EA() const {
    return GetField<double>(VT_EA, 0.0);
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyOffset(verifier, VT_CENTERPNT) &&
           verifier.VerifyVector(CenterPnt()) &&
           VerifyOffset(verifier, VT_MINORPNT) &&
           verifier.VerifyVector(MinorPnt()) &&
           VerifyOffset(verifier, VT_MAJORPNT) &&
           verifier.VerifyVector(MajorPnt()) &&
           VerifyField<double>(verifier, VT_SA) &&
           VerifyField<double>(verifier, VT_EA) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           verifier.EndTable();
  }
};

struct EllipseArcDataBuilder {
  typedef EllipseArcData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(EllipseArcData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(EllipseArcData::VT_GT, GT, 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(EllipseArcData::VT_INDEX, Index, 0);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(EllipseArcData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_CenterPnt(flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt) {
    fbb_.AddOffset(EllipseArcData::VT_CENTERPNT, CenterPnt);
  }
  void add_MinorPnt(flatbuffers::Offset<flatbuffers::Vector<double>> MinorPnt) {
    fbb_.AddOffset(EllipseArcData::VT_MINORPNT, MinorPnt);
  }
  void add_MajorPnt(flatbuffers::Offset<flatbuffers::Vector<double>> MajorPnt) {
    fbb_.AddOffset(EllipseArcData::VT_MAJORPNT, MajorPnt);
  }
  void add_SA(double SA) {
    fbb_.AddElement<double>(EllipseArcData::VT_SA, SA, 0.0);
  }
  void add_EA(double EA) {
    fbb_.AddElement<double>(EllipseArcData::VT_EA, EA, 0.0);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(EllipseArcData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  explicit EllipseArcDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EllipseArcDataBuilder &operator=(const EllipseArcDataBuilder &);
  flatbuffers::Offset<EllipseArcData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EllipseArcData>(end);
    return o;
  }
};

inline flatbuffers::Offset<EllipseArcData> CreateEllipseArcData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MinorPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MajorPnt = 0,
    double SA = 0.0,
    double EA = 0.0,
    bool Auxiliary = false) {
  EllipseArcDataBuilder builder_(_fbb);
  builder_.add_EA(EA);
  builder_.add_SA(SA);
  builder_.add_MajorPnt(MajorPnt);
  builder_.add_MinorPnt(MinorPnt);
  builder_.add_CenterPnt(CenterPnt);
  builder_.add_Index(Index);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<EllipseArcData> CreateEllipseArcDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    const std::vector<double> *CenterPnt = nullptr,
    const std::vector<double> *MinorPnt = nullptr,
    const std::vector<double> *MajorPnt = nullptr,
    double SA = 0.0,
    double EA = 0.0,
    bool Auxiliary = false) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto CenterPnt__ = CenterPnt ? _fbb.CreateVector<double>(*CenterPnt) : 0;
  auto MinorPnt__ = MinorPnt ? _fbb.CreateVector<double>(*MinorPnt) : 0;
  auto MajorPnt__ = MajorPnt ? _fbb.CreateVector<double>(*MajorPnt) : 0;
  return FlatBufferDocSpace::CreateEllipseArcData(
      _fbb,
      TopoId__,
      GT,
      Index,
      Reference,
      CenterPnt__,
      MinorPnt__,
      MajorPnt__,
      SA,
      EA,
      Auxiliary);
}

struct EquationCurvecData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EquationCurvecDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_INDEX = 8,
    VT_REFERENCE = 10,
    VT_AUXILIARY = 12,
    VT_ISCLOSED = 14,
    VT_TYPE = 16,
    VT_ET1 = 18,
    VT_ET2 = 20,
    VT_SV = 22,
    VT_EV = 24,
    VT_COOTYPE = 26,
    VT_SISD = 28,
    VT_EISD = 30
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Reference() const {
    return GetField<uint8_t>(VT_REFERENCE, 0) != 0;
  }
  bool Auxiliary() const {
    return GetField<uint8_t>(VT_AUXILIARY, 0) != 0;
  }
  bool IsClosed() const {
    return GetField<uint8_t>(VT_ISCLOSED, 0) != 0;
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *ET1() const {
    return GetPointer<const flatbuffers::String *>(VT_ET1);
  }
  const flatbuffers::String *ET2() const {
    return GetPointer<const flatbuffers::String *>(VT_ET2);
  }
  double SV() const {
    return GetField<double>(VT_SV, 0.0);
  }
  double EV() const {
    return GetField<double>(VT_EV, 0.0);
  }
  int32_t CooType() const {
    return GetField<int32_t>(VT_COOTYPE, 0);
  }
  int32_t SIsD() const {
    return GetField<int32_t>(VT_SISD, 0);
  }
  int32_t EIsD() const {
    return GetField<int32_t>(VT_EISD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_REFERENCE) &&
           VerifyField<uint8_t>(verifier, VT_AUXILIARY) &&
           VerifyField<uint8_t>(verifier, VT_ISCLOSED) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ET1) &&
           verifier.VerifyString(ET1()) &&
           VerifyOffset(verifier, VT_ET2) &&
           verifier.VerifyString(ET2()) &&
           VerifyField<double>(verifier, VT_SV) &&
           VerifyField<double>(verifier, VT_EV) &&
           VerifyField<int32_t>(verifier, VT_COOTYPE) &&
           VerifyField<int32_t>(verifier, VT_SISD) &&
           VerifyField<int32_t>(verifier, VT_EISD) &&
           verifier.EndTable();
  }
};

struct EquationCurvecDataBuilder {
  typedef EquationCurvecData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(EquationCurvecData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(EquationCurvecData::VT_GT, GT, 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(EquationCurvecData::VT_INDEX, Index, 0);
  }
  void add_Reference(bool Reference) {
    fbb_.AddElement<uint8_t>(EquationCurvecData::VT_REFERENCE, static_cast<uint8_t>(Reference), 0);
  }
  void add_Auxiliary(bool Auxiliary) {
    fbb_.AddElement<uint8_t>(EquationCurvecData::VT_AUXILIARY, static_cast<uint8_t>(Auxiliary), 0);
  }
  void add_IsClosed(bool IsClosed) {
    fbb_.AddElement<uint8_t>(EquationCurvecData::VT_ISCLOSED, static_cast<uint8_t>(IsClosed), 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(EquationCurvecData::VT_TYPE, Type, 0);
  }
  void add_ET1(flatbuffers::Offset<flatbuffers::String> ET1) {
    fbb_.AddOffset(EquationCurvecData::VT_ET1, ET1);
  }
  void add_ET2(flatbuffers::Offset<flatbuffers::String> ET2) {
    fbb_.AddOffset(EquationCurvecData::VT_ET2, ET2);
  }
  void add_SV(double SV) {
    fbb_.AddElement<double>(EquationCurvecData::VT_SV, SV, 0.0);
  }
  void add_EV(double EV) {
    fbb_.AddElement<double>(EquationCurvecData::VT_EV, EV, 0.0);
  }
  void add_CooType(int32_t CooType) {
    fbb_.AddElement<int32_t>(EquationCurvecData::VT_COOTYPE, CooType, 0);
  }
  void add_SIsD(int32_t SIsD) {
    fbb_.AddElement<int32_t>(EquationCurvecData::VT_SISD, SIsD, 0);
  }
  void add_EIsD(int32_t EIsD) {
    fbb_.AddElement<int32_t>(EquationCurvecData::VT_EISD, EIsD, 0);
  }
  explicit EquationCurvecDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquationCurvecDataBuilder &operator=(const EquationCurvecDataBuilder &);
  flatbuffers::Offset<EquationCurvecData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquationCurvecData>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquationCurvecData> CreateEquationCurvecData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    bool Auxiliary = false,
    bool IsClosed = false,
    int32_t Type = 0,
    flatbuffers::Offset<flatbuffers::String> ET1 = 0,
    flatbuffers::Offset<flatbuffers::String> ET2 = 0,
    double SV = 0.0,
    double EV = 0.0,
    int32_t CooType = 0,
    int32_t SIsD = 0,
    int32_t EIsD = 0) {
  EquationCurvecDataBuilder builder_(_fbb);
  builder_.add_EV(EV);
  builder_.add_SV(SV);
  builder_.add_EIsD(EIsD);
  builder_.add_SIsD(SIsD);
  builder_.add_CooType(CooType);
  builder_.add_ET2(ET2);
  builder_.add_ET1(ET1);
  builder_.add_Type(Type);
  builder_.add_Index(Index);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  builder_.add_IsClosed(IsClosed);
  builder_.add_Auxiliary(Auxiliary);
  builder_.add_Reference(Reference);
  return builder_.Finish();
}

inline flatbuffers::Offset<EquationCurvecData> CreateEquationCurvecDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    int32_t Index = 0,
    bool Reference = false,
    bool Auxiliary = false,
    bool IsClosed = false,
    int32_t Type = 0,
    const char *ET1 = nullptr,
    const char *ET2 = nullptr,
    double SV = 0.0,
    double EV = 0.0,
    int32_t CooType = 0,
    int32_t SIsD = 0,
    int32_t EIsD = 0) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto ET1__ = ET1 ? _fbb.CreateString(ET1) : 0;
  auto ET2__ = ET2 ? _fbb.CreateString(ET2) : 0;
  return FlatBufferDocSpace::CreateEquationCurvecData(
      _fbb,
      TopoId__,
      GT,
      Index,
      Reference,
      Auxiliary,
      IsClosed,
      Type,
      ET1__,
      ET2__,
      SV,
      EV,
      CooType,
      SIsD,
      EIsD);
}

struct GeometryPointData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryPointDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GT = 6,
    VT_POINT = 8,
    VT_INDEX = 10,
    VT_T = 12,
    VT_INTERSPOINT = 14
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  const flatbuffers::Vector<double> *Point() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINT);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  int32_t T() const {
    return GetField<int32_t>(VT_T, 0);
  }
  const FlatBufferDocSpace::RelIntersDate *IntersPoint() const {
    return GetPointer<const FlatBufferDocSpace::RelIntersDate *>(VT_INTERSPOINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyOffset(verifier, VT_POINT) &&
           verifier.VerifyVector(Point()) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyOffset(verifier, VT_INTERSPOINT) &&
           verifier.VerifyTable(IntersPoint()) &&
           verifier.EndTable();
  }
};

struct GeometryPointDataBuilder {
  typedef GeometryPointData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(GeometryPointData::VT_TOPOID, TopoId);
  }
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(GeometryPointData::VT_GT, GT, 0);
  }
  void add_Point(flatbuffers::Offset<flatbuffers::Vector<double>> Point) {
    fbb_.AddOffset(GeometryPointData::VT_POINT, Point);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(GeometryPointData::VT_INDEX, Index, 0);
  }
  void add_T(int32_t T) {
    fbb_.AddElement<int32_t>(GeometryPointData::VT_T, T, 0);
  }
  void add_IntersPoint(flatbuffers::Offset<FlatBufferDocSpace::RelIntersDate> IntersPoint) {
    fbb_.AddOffset(GeometryPointData::VT_INTERSPOINT, IntersPoint);
  }
  explicit GeometryPointDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryPointDataBuilder &operator=(const GeometryPointDataBuilder &);
  flatbuffers::Offset<GeometryPointData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryPointData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometryPointData> CreateGeometryPointData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GT = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Point = 0,
    int32_t Index = 0,
    int32_t T = 0,
    flatbuffers::Offset<FlatBufferDocSpace::RelIntersDate> IntersPoint = 0) {
  GeometryPointDataBuilder builder_(_fbb);
  builder_.add_IntersPoint(IntersPoint);
  builder_.add_T(T);
  builder_.add_Index(Index);
  builder_.add_Point(Point);
  builder_.add_GT(GT);
  builder_.add_TopoId(TopoId);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeometryPointData> CreateGeometryPointDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GT = 0,
    const std::vector<double> *Point = nullptr,
    int32_t Index = 0,
    int32_t T = 0,
    flatbuffers::Offset<FlatBufferDocSpace::RelIntersDate> IntersPoint = 0) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  auto Point__ = Point ? _fbb.CreateVector<double>(*Point) : 0;
  return FlatBufferDocSpace::CreateGeometryPointData(
      _fbb,
      TopoId__,
      GT,
      Point__,
      Index,
      T,
      IntersPoint);
}

struct WorkPlaneData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorkPlaneDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WPONSKETCH = 4,
    VT_WPONFACE = 6,
    VT_PLANETYPE = 8,
    VT_WPSKETCHTOPOID = 10,
    VT_WPSKETCHID = 12,
    VT_WPFACETOPOID = 14,
    VT_WPFACEID = 16,
    VT_WPORIGINTOPOID = 18,
    VT_WPDIRECTIONYTOPOID1 = 20,
    VT_WPDIRECTIONYTOPOID2 = 22,
    VT_REVERSEY = 24,
    VT_REVERSENORMAL = 26,
    VT_WPORIGIN = 28,
    VT_WPDIRECTIONY = 30
  };
  int32_t WPOnSketch() const {
    return GetField<int32_t>(VT_WPONSKETCH, 0);
  }
  int32_t WPOnFace() const {
    return GetField<int32_t>(VT_WPONFACE, 0);
  }
  const flatbuffers::String *PlaneType() const {
    return GetPointer<const flatbuffers::String *>(VT_PLANETYPE);
  }
  const flatbuffers::String *WPSketchTopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_WPSKETCHTOPOID);
  }
  int32_t WPSketchId() const {
    return GetField<int32_t>(VT_WPSKETCHID, 0);
  }
  const flatbuffers::String *WPFaceTopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_WPFACETOPOID);
  }
  int32_t WPFaceId() const {
    return GetField<int32_t>(VT_WPFACEID, 0);
  }
  const flatbuffers::String *WPOriginTopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_WPORIGINTOPOID);
  }
  const flatbuffers::String *WPDirectionYTopoId1() const {
    return GetPointer<const flatbuffers::String *>(VT_WPDIRECTIONYTOPOID1);
  }
  const flatbuffers::String *WPDirectionYTopoId2() const {
    return GetPointer<const flatbuffers::String *>(VT_WPDIRECTIONYTOPOID2);
  }
  int32_t ReverseY() const {
    return GetField<int32_t>(VT_REVERSEY, 0);
  }
  int32_t ReverseNormal() const {
    return GetField<int32_t>(VT_REVERSENORMAL, 0);
  }
  const FlatBufferDocSpace::SnapPoint *WPOrigin() const {
    return GetPointer<const FlatBufferDocSpace::SnapPoint *>(VT_WPORIGIN);
  }
  const FlatBufferDocSpace::ParDirection *WPDirectionY() const {
    return GetPointer<const FlatBufferDocSpace::ParDirection *>(VT_WPDIRECTIONY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WPONSKETCH) &&
           VerifyField<int32_t>(verifier, VT_WPONFACE) &&
           VerifyOffset(verifier, VT_PLANETYPE) &&
           verifier.VerifyString(PlaneType()) &&
           VerifyOffset(verifier, VT_WPSKETCHTOPOID) &&
           verifier.VerifyString(WPSketchTopoId()) &&
           VerifyField<int32_t>(verifier, VT_WPSKETCHID) &&
           VerifyOffset(verifier, VT_WPFACETOPOID) &&
           verifier.VerifyString(WPFaceTopoId()) &&
           VerifyField<int32_t>(verifier, VT_WPFACEID) &&
           VerifyOffset(verifier, VT_WPORIGINTOPOID) &&
           verifier.VerifyString(WPOriginTopoId()) &&
           VerifyOffset(verifier, VT_WPDIRECTIONYTOPOID1) &&
           verifier.VerifyString(WPDirectionYTopoId1()) &&
           VerifyOffset(verifier, VT_WPDIRECTIONYTOPOID2) &&
           verifier.VerifyString(WPDirectionYTopoId2()) &&
           VerifyField<int32_t>(verifier, VT_REVERSEY) &&
           VerifyField<int32_t>(verifier, VT_REVERSENORMAL) &&
           VerifyOffset(verifier, VT_WPORIGIN) &&
           verifier.VerifyTable(WPOrigin()) &&
           VerifyOffset(verifier, VT_WPDIRECTIONY) &&
           verifier.VerifyTable(WPDirectionY()) &&
           verifier.EndTable();
  }
};

struct WorkPlaneDataBuilder {
  typedef WorkPlaneData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_WPOnSketch(int32_t WPOnSketch) {
    fbb_.AddElement<int32_t>(WorkPlaneData::VT_WPONSKETCH, WPOnSketch, 0);
  }
  void add_WPOnFace(int32_t WPOnFace) {
    fbb_.AddElement<int32_t>(WorkPlaneData::VT_WPONFACE, WPOnFace, 0);
  }
  void add_PlaneType(flatbuffers::Offset<flatbuffers::String> PlaneType) {
    fbb_.AddOffset(WorkPlaneData::VT_PLANETYPE, PlaneType);
  }
  void add_WPSketchTopoId(flatbuffers::Offset<flatbuffers::String> WPSketchTopoId) {
    fbb_.AddOffset(WorkPlaneData::VT_WPSKETCHTOPOID, WPSketchTopoId);
  }
  void add_WPSketchId(int32_t WPSketchId) {
    fbb_.AddElement<int32_t>(WorkPlaneData::VT_WPSKETCHID, WPSketchId, 0);
  }
  void add_WPFaceTopoId(flatbuffers::Offset<flatbuffers::String> WPFaceTopoId) {
    fbb_.AddOffset(WorkPlaneData::VT_WPFACETOPOID, WPFaceTopoId);
  }
  void add_WPFaceId(int32_t WPFaceId) {
    fbb_.AddElement<int32_t>(WorkPlaneData::VT_WPFACEID, WPFaceId, 0);
  }
  void add_WPOriginTopoId(flatbuffers::Offset<flatbuffers::String> WPOriginTopoId) {
    fbb_.AddOffset(WorkPlaneData::VT_WPORIGINTOPOID, WPOriginTopoId);
  }
  void add_WPDirectionYTopoId1(flatbuffers::Offset<flatbuffers::String> WPDirectionYTopoId1) {
    fbb_.AddOffset(WorkPlaneData::VT_WPDIRECTIONYTOPOID1, WPDirectionYTopoId1);
  }
  void add_WPDirectionYTopoId2(flatbuffers::Offset<flatbuffers::String> WPDirectionYTopoId2) {
    fbb_.AddOffset(WorkPlaneData::VT_WPDIRECTIONYTOPOID2, WPDirectionYTopoId2);
  }
  void add_ReverseY(int32_t ReverseY) {
    fbb_.AddElement<int32_t>(WorkPlaneData::VT_REVERSEY, ReverseY, 0);
  }
  void add_ReverseNormal(int32_t ReverseNormal) {
    fbb_.AddElement<int32_t>(WorkPlaneData::VT_REVERSENORMAL, ReverseNormal, 0);
  }
  void add_WPOrigin(flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> WPOrigin) {
    fbb_.AddOffset(WorkPlaneData::VT_WPORIGIN, WPOrigin);
  }
  void add_WPDirectionY(flatbuffers::Offset<FlatBufferDocSpace::ParDirection> WPDirectionY) {
    fbb_.AddOffset(WorkPlaneData::VT_WPDIRECTIONY, WPDirectionY);
  }
  explicit WorkPlaneDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkPlaneDataBuilder &operator=(const WorkPlaneDataBuilder &);
  flatbuffers::Offset<WorkPlaneData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkPlaneData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkPlaneData> CreateWorkPlaneData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t WPOnSketch = 0,
    int32_t WPOnFace = 0,
    flatbuffers::Offset<flatbuffers::String> PlaneType = 0,
    flatbuffers::Offset<flatbuffers::String> WPSketchTopoId = 0,
    int32_t WPSketchId = 0,
    flatbuffers::Offset<flatbuffers::String> WPFaceTopoId = 0,
    int32_t WPFaceId = 0,
    flatbuffers::Offset<flatbuffers::String> WPOriginTopoId = 0,
    flatbuffers::Offset<flatbuffers::String> WPDirectionYTopoId1 = 0,
    flatbuffers::Offset<flatbuffers::String> WPDirectionYTopoId2 = 0,
    int32_t ReverseY = 0,
    int32_t ReverseNormal = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> WPOrigin = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ParDirection> WPDirectionY = 0) {
  WorkPlaneDataBuilder builder_(_fbb);
  builder_.add_WPDirectionY(WPDirectionY);
  builder_.add_WPOrigin(WPOrigin);
  builder_.add_ReverseNormal(ReverseNormal);
  builder_.add_ReverseY(ReverseY);
  builder_.add_WPDirectionYTopoId2(WPDirectionYTopoId2);
  builder_.add_WPDirectionYTopoId1(WPDirectionYTopoId1);
  builder_.add_WPOriginTopoId(WPOriginTopoId);
  builder_.add_WPFaceId(WPFaceId);
  builder_.add_WPFaceTopoId(WPFaceTopoId);
  builder_.add_WPSketchId(WPSketchId);
  builder_.add_WPSketchTopoId(WPSketchTopoId);
  builder_.add_PlaneType(PlaneType);
  builder_.add_WPOnFace(WPOnFace);
  builder_.add_WPOnSketch(WPOnSketch);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkPlaneData> CreateWorkPlaneDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t WPOnSketch = 0,
    int32_t WPOnFace = 0,
    const char *PlaneType = nullptr,
    const char *WPSketchTopoId = nullptr,
    int32_t WPSketchId = 0,
    const char *WPFaceTopoId = nullptr,
    int32_t WPFaceId = 0,
    const char *WPOriginTopoId = nullptr,
    const char *WPDirectionYTopoId1 = nullptr,
    const char *WPDirectionYTopoId2 = nullptr,
    int32_t ReverseY = 0,
    int32_t ReverseNormal = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> WPOrigin = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ParDirection> WPDirectionY = 0) {
  auto PlaneType__ = PlaneType ? _fbb.CreateString(PlaneType) : 0;
  auto WPSketchTopoId__ = WPSketchTopoId ? _fbb.CreateString(WPSketchTopoId) : 0;
  auto WPFaceTopoId__ = WPFaceTopoId ? _fbb.CreateString(WPFaceTopoId) : 0;
  auto WPOriginTopoId__ = WPOriginTopoId ? _fbb.CreateString(WPOriginTopoId) : 0;
  auto WPDirectionYTopoId1__ = WPDirectionYTopoId1 ? _fbb.CreateString(WPDirectionYTopoId1) : 0;
  auto WPDirectionYTopoId2__ = WPDirectionYTopoId2 ? _fbb.CreateString(WPDirectionYTopoId2) : 0;
  return FlatBufferDocSpace::CreateWorkPlaneData(
      _fbb,
      WPOnSketch,
      WPOnFace,
      PlaneType__,
      WPSketchTopoId__,
      WPSketchId,
      WPFaceTopoId__,
      WPFaceId,
      WPOriginTopoId__,
      WPDirectionYTopoId1__,
      WPDirectionYTopoId2__,
      ReverseY,
      ReverseNormal,
      WPOrigin,
      WPDirectionY);
}

struct GeometryIdData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryIdDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPOID = 4,
    VT_GEOMID = 6
  };
  const flatbuffers::String *TopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPOID);
  }
  int32_t GeomId() const {
    return GetField<int32_t>(VT_GEOMID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPOID) &&
           verifier.VerifyString(TopoId()) &&
           VerifyField<int32_t>(verifier, VT_GEOMID) &&
           verifier.EndTable();
  }
};

struct GeometryIdDataBuilder {
  typedef GeometryIdData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TopoId(flatbuffers::Offset<flatbuffers::String> TopoId) {
    fbb_.AddOffset(GeometryIdData::VT_TOPOID, TopoId);
  }
  void add_GeomId(int32_t GeomId) {
    fbb_.AddElement<int32_t>(GeometryIdData::VT_GEOMID, GeomId, 0);
  }
  explicit GeometryIdDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryIdDataBuilder &operator=(const GeometryIdDataBuilder &);
  flatbuffers::Offset<GeometryIdData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryIdData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometryIdData> CreateGeometryIdData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TopoId = 0,
    int32_t GeomId = 0) {
  GeometryIdDataBuilder builder_(_fbb);
  builder_.add_GeomId(GeomId);
  builder_.add_TopoId(TopoId);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeometryIdData> CreateGeometryIdDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TopoId = nullptr,
    int32_t GeomId = 0) {
  auto TopoId__ = TopoId ? _fbb.CreateString(TopoId) : 0;
  return FlatBufferDocSpace::CreateGeometryIdData(
      _fbb,
      TopoId__,
      GeomId);
}

struct EditInstanceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EditInstanceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCEID = 4
  };
  const flatbuffers::String *InstanceId() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCEID) &&
           verifier.VerifyString(InstanceId()) &&
           verifier.EndTable();
  }
};

struct EditInstanceDataBuilder {
  typedef EditInstanceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_InstanceId(flatbuffers::Offset<flatbuffers::String> InstanceId) {
    fbb_.AddOffset(EditInstanceData::VT_INSTANCEID, InstanceId);
  }
  explicit EditInstanceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EditInstanceDataBuilder &operator=(const EditInstanceDataBuilder &);
  flatbuffers::Offset<EditInstanceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EditInstanceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<EditInstanceData> CreateEditInstanceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> InstanceId = 0) {
  EditInstanceDataBuilder builder_(_fbb);
  builder_.add_InstanceId(InstanceId);
  return builder_.Finish();
}

inline flatbuffers::Offset<EditInstanceData> CreateEditInstanceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *InstanceId = nullptr) {
  auto InstanceId__ = InstanceId ? _fbb.CreateString(InstanceId) : 0;
  return FlatBufferDocSpace::CreateEditInstanceData(
      _fbb,
      InstanceId__);
}

struct VariableData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VariableDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLENAME = 4,
    VT_VARIABLEEXPRESSION = 6,
    VT_VARIABLEDESCRIPTION = 8,
    VT_VARIABLETYPE = 10,
    VT_VARIABLEUNIT = 12,
    VT_VARIABLEVALUE = 14,
    VT_NEWNAME = 16,
    VT_SYSTEMVALUE = 18,
    VT_CREATETYPE = 20,
    VT_CONFIGISACTIVE = 22,
    VT_INSTANCEGROUP = 24,
    VT_EXTERNALREFFLG = 26
  };
  const flatbuffers::String *VariableName() const {
    return GetPointer<const flatbuffers::String *>(VT_VARIABLENAME);
  }
  const flatbuffers::String *VariableExpression() const {
    return GetPointer<const flatbuffers::String *>(VT_VARIABLEEXPRESSION);
  }
  const flatbuffers::String *VariableDescription() const {
    return GetPointer<const flatbuffers::String *>(VT_VARIABLEDESCRIPTION);
  }
  const flatbuffers::String *VariableType() const {
    return GetPointer<const flatbuffers::String *>(VT_VARIABLETYPE);
  }
  const flatbuffers::String *VariableUnit() const {
    return GetPointer<const flatbuffers::String *>(VT_VARIABLEUNIT);
  }
  double VariableValue() const {
    return GetField<double>(VT_VARIABLEVALUE, 0.0);
  }
  const flatbuffers::String *NewName() const {
    return GetPointer<const flatbuffers::String *>(VT_NEWNAME);
  }
  double SystemValue() const {
    return GetField<double>(VT_SYSTEMVALUE, 0.0);
  }
  int32_t CreateType() const {
    return GetField<int32_t>(VT_CREATETYPE, 0);
  }
  int32_t ConfigIsActive() const {
    return GetField<int32_t>(VT_CONFIGISACTIVE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EditInstanceData>> *InstanceGroup() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EditInstanceData>> *>(VT_INSTANCEGROUP);
  }
  bool ExternalRefFlg() const {
    return GetField<uint8_t>(VT_EXTERNALREFFLG, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLENAME) &&
           verifier.VerifyString(VariableName()) &&
           VerifyOffset(verifier, VT_VARIABLEEXPRESSION) &&
           verifier.VerifyString(VariableExpression()) &&
           VerifyOffset(verifier, VT_VARIABLEDESCRIPTION) &&
           verifier.VerifyString(VariableDescription()) &&
           VerifyOffset(verifier, VT_VARIABLETYPE) &&
           verifier.VerifyString(VariableType()) &&
           VerifyOffset(verifier, VT_VARIABLEUNIT) &&
           verifier.VerifyString(VariableUnit()) &&
           VerifyField<double>(verifier, VT_VARIABLEVALUE) &&
           VerifyOffset(verifier, VT_NEWNAME) &&
           verifier.VerifyString(NewName()) &&
           VerifyField<double>(verifier, VT_SYSTEMVALUE) &&
           VerifyField<int32_t>(verifier, VT_CREATETYPE) &&
           VerifyField<int32_t>(verifier, VT_CONFIGISACTIVE) &&
           VerifyOffset(verifier, VT_INSTANCEGROUP) &&
           verifier.VerifyVector(InstanceGroup()) &&
           verifier.VerifyVectorOfTables(InstanceGroup()) &&
           VerifyField<uint8_t>(verifier, VT_EXTERNALREFFLG) &&
           verifier.EndTable();
  }
};

struct VariableDataBuilder {
  typedef VariableData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_VariableName(flatbuffers::Offset<flatbuffers::String> VariableName) {
    fbb_.AddOffset(VariableData::VT_VARIABLENAME, VariableName);
  }
  void add_VariableExpression(flatbuffers::Offset<flatbuffers::String> VariableExpression) {
    fbb_.AddOffset(VariableData::VT_VARIABLEEXPRESSION, VariableExpression);
  }
  void add_VariableDescription(flatbuffers::Offset<flatbuffers::String> VariableDescription) {
    fbb_.AddOffset(VariableData::VT_VARIABLEDESCRIPTION, VariableDescription);
  }
  void add_VariableType(flatbuffers::Offset<flatbuffers::String> VariableType) {
    fbb_.AddOffset(VariableData::VT_VARIABLETYPE, VariableType);
  }
  void add_VariableUnit(flatbuffers::Offset<flatbuffers::String> VariableUnit) {
    fbb_.AddOffset(VariableData::VT_VARIABLEUNIT, VariableUnit);
  }
  void add_VariableValue(double VariableValue) {
    fbb_.AddElement<double>(VariableData::VT_VARIABLEVALUE, VariableValue, 0.0);
  }
  void add_NewName(flatbuffers::Offset<flatbuffers::String> NewName) {
    fbb_.AddOffset(VariableData::VT_NEWNAME, NewName);
  }
  void add_SystemValue(double SystemValue) {
    fbb_.AddElement<double>(VariableData::VT_SYSTEMVALUE, SystemValue, 0.0);
  }
  void add_CreateType(int32_t CreateType) {
    fbb_.AddElement<int32_t>(VariableData::VT_CREATETYPE, CreateType, 0);
  }
  void add_ConfigIsActive(int32_t ConfigIsActive) {
    fbb_.AddElement<int32_t>(VariableData::VT_CONFIGISACTIVE, ConfigIsActive, 0);
  }
  void add_InstanceGroup(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EditInstanceData>>> InstanceGroup) {
    fbb_.AddOffset(VariableData::VT_INSTANCEGROUP, InstanceGroup);
  }
  void add_ExternalRefFlg(bool ExternalRefFlg) {
    fbb_.AddElement<uint8_t>(VariableData::VT_EXTERNALREFFLG, static_cast<uint8_t>(ExternalRefFlg), 0);
  }
  explicit VariableDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VariableDataBuilder &operator=(const VariableDataBuilder &);
  flatbuffers::Offset<VariableData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VariableData>(end);
    return o;
  }
};

inline flatbuffers::Offset<VariableData> CreateVariableData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> VariableName = 0,
    flatbuffers::Offset<flatbuffers::String> VariableExpression = 0,
    flatbuffers::Offset<flatbuffers::String> VariableDescription = 0,
    flatbuffers::Offset<flatbuffers::String> VariableType = 0,
    flatbuffers::Offset<flatbuffers::String> VariableUnit = 0,
    double VariableValue = 0.0,
    flatbuffers::Offset<flatbuffers::String> NewName = 0,
    double SystemValue = 0.0,
    int32_t CreateType = 0,
    int32_t ConfigIsActive = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EditInstanceData>>> InstanceGroup = 0,
    bool ExternalRefFlg = false) {
  VariableDataBuilder builder_(_fbb);
  builder_.add_SystemValue(SystemValue);
  builder_.add_VariableValue(VariableValue);
  builder_.add_InstanceGroup(InstanceGroup);
  builder_.add_ConfigIsActive(ConfigIsActive);
  builder_.add_CreateType(CreateType);
  builder_.add_NewName(NewName);
  builder_.add_VariableUnit(VariableUnit);
  builder_.add_VariableType(VariableType);
  builder_.add_VariableDescription(VariableDescription);
  builder_.add_VariableExpression(VariableExpression);
  builder_.add_VariableName(VariableName);
  builder_.add_ExternalRefFlg(ExternalRefFlg);
  return builder_.Finish();
}

inline flatbuffers::Offset<VariableData> CreateVariableDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *VariableName = nullptr,
    const char *VariableExpression = nullptr,
    const char *VariableDescription = nullptr,
    const char *VariableType = nullptr,
    const char *VariableUnit = nullptr,
    double VariableValue = 0.0,
    const char *NewName = nullptr,
    double SystemValue = 0.0,
    int32_t CreateType = 0,
    int32_t ConfigIsActive = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EditInstanceData>> *InstanceGroup = nullptr,
    bool ExternalRefFlg = false) {
  auto VariableName__ = VariableName ? _fbb.CreateString(VariableName) : 0;
  auto VariableExpression__ = VariableExpression ? _fbb.CreateString(VariableExpression) : 0;
  auto VariableDescription__ = VariableDescription ? _fbb.CreateString(VariableDescription) : 0;
  auto VariableType__ = VariableType ? _fbb.CreateString(VariableType) : 0;
  auto VariableUnit__ = VariableUnit ? _fbb.CreateString(VariableUnit) : 0;
  auto NewName__ = NewName ? _fbb.CreateString(NewName) : 0;
  auto InstanceGroup__ = InstanceGroup ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EditInstanceData>>(*InstanceGroup) : 0;
  return FlatBufferDocSpace::CreateVariableData(
      _fbb,
      VariableName__,
      VariableExpression__,
      VariableDescription__,
      VariableType__,
      VariableUnit__,
      VariableValue,
      NewName__,
      SystemValue,
      CreateType,
      ConfigIsActive,
      InstanceGroup__,
      ExternalRefFlg);
}

struct MaterialData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIALINDEX = 4,
    VT_MATERIALDENSITY = 6,
    VT_DOCFLAG = 8
  };
  const flatbuffers::String *MaterialIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIALINDEX);
  }
  double MaterialDensity() const {
    return GetField<double>(VT_MATERIALDENSITY, 0.0);
  }
  int32_t DocFlag() const {
    return GetField<int32_t>(VT_DOCFLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MATERIALINDEX) &&
           verifier.VerifyString(MaterialIndex()) &&
           VerifyField<double>(verifier, VT_MATERIALDENSITY) &&
           VerifyField<int32_t>(verifier, VT_DOCFLAG) &&
           verifier.EndTable();
  }
};

struct MaterialDataBuilder {
  typedef MaterialData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MaterialIndex(flatbuffers::Offset<flatbuffers::String> MaterialIndex) {
    fbb_.AddOffset(MaterialData::VT_MATERIALINDEX, MaterialIndex);
  }
  void add_MaterialDensity(double MaterialDensity) {
    fbb_.AddElement<double>(MaterialData::VT_MATERIALDENSITY, MaterialDensity, 0.0);
  }
  void add_DocFlag(int32_t DocFlag) {
    fbb_.AddElement<int32_t>(MaterialData::VT_DOCFLAG, DocFlag, 0);
  }
  explicit MaterialDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialDataBuilder &operator=(const MaterialDataBuilder &);
  flatbuffers::Offset<MaterialData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialData> CreateMaterialData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> MaterialIndex = 0,
    double MaterialDensity = 0.0,
    int32_t DocFlag = 0) {
  MaterialDataBuilder builder_(_fbb);
  builder_.add_MaterialDensity(MaterialDensity);
  builder_.add_DocFlag(DocFlag);
  builder_.add_MaterialIndex(MaterialIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaterialData> CreateMaterialDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *MaterialIndex = nullptr,
    double MaterialDensity = 0.0,
    int32_t DocFlag = 0) {
  auto MaterialIndex__ = MaterialIndex ? _fbb.CreateString(MaterialIndex) : 0;
  return FlatBufferDocSpace::CreateMaterialData(
      _fbb,
      MaterialIndex__,
      MaterialDensity,
      DocFlag);
}

struct ConstraintsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstraintsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINTTYPE = 4,
    VT_TYPE = 6,
    VT_FIRSTSNAPTOPOID = 8,
    VT_FIRSTSNAPID = 10,
    VT_FIRSTSNAPTYPE = 12,
    VT_FIRSTPICKPNT = 14,
    VT_SECONDSNAPTOPOID = 16,
    VT_SECONDSNAPID = 18,
    VT_SECONDSNAPTYPE = 20,
    VT_SECONDPICKPNT = 22,
    VT_THIRDSNAPTOPOID = 24,
    VT_THIRDSNAPID = 26,
    VT_THIRDSNAPTYPE = 28,
    VT_THIRDPICKPNT = 30,
    VT_TEXTCONTENT = 32,
    VT_PARAMINDEX = 34,
    VT_DIMPOSITION = 36,
    VT_DIRECTION = 38,
    VT_DIMVARIABLE = 40,
    VT_DIMSTATUS = 42,
    VT_DIAMETERFLAG = 44,
    VT_DIMTEXTPOS = 46,
    VT_ISREFERENCE = 48,
    VT_VALPRECISION = 50,
    VT_TOLPRECISION = 52,
    VT_TOLTYPE = 54,
    VT_ARROWPOS = 56,
    VT_LEFTARROWTYPE = 58,
    VT_RIGHTARROWTYPE = 60,
    VT_DIMLINETYPE = 62,
    VT_DIMLINEWIDTH = 64,
    VT_DIMCOLOR = 66,
    VT_FONTNAME = 68,
    VT_FONTSIZE = 70,
    VT_FONTGAP = 72,
    VT_FONTCOLOR = 74,
    VT_ISITALIC = 76,
    VT_ISBOLD = 78,
    VT_ISUNDERLINE = 80,
    VT_TEXT = 82,
    VT_PATTERNTYPE = 84,
    VT_PATTERNELENUM = 86,
    VT_COPYNUM1 = 88,
    VT_COPYNUM2 = 90,
    VT_SKIPINSTANCE = 92,
    VT_DELETEELEMENT = 94,
    VT_ANGLEFLAG = 96,
    VT_COPYNUM = 98,
    VT_COPYNUMINDEX = 100,
    VT_PATTERNCONSTINDEX = 102,
    VT_GEOMETRIES = 104,
    VT_FIRSTARCFLAG = 106,
    VT_SECONDARCFLAG = 108,
    VT_FIRSTSILHOUETTEINDEX = 110,
    VT_SECONDSILHOUETTEINDEX = 112,
    VT_THIRDSILHOUETTEINDEX = 114,
    VT_RADIUSORDIAMETER = 116,
    VT_FIRSTINSTANCEINDEX = 118,
    VT_SECONDINSTANCEINDEX = 120,
    VT_THIRDINSTANCEINDEX = 122,
    VT_IMAGEDATABASEID = 124,
    VT_FILENAME = 126,
    VT_ORIGINXPOS = 128,
    VT_ORIGINYPOS = 130,
    VT_ANGLE = 132,
    VT_WIDTH = 134,
    VT_HEIGHT = 136,
    VT_SCALETOOL = 138,
    VT_STARTPNT = 140,
    VT_ENDPNT = 142,
    VT_STARTSTATUS = 144,
    VT_ENDSTATUS = 146,
    VT_CLOCKPRO = 148,
    VT_HORIZONALFLG = 150,
    VT_VERTICALFLG = 152,
    VT_LUCENCYMODE = 154,
    VT_LUCENCYCOLOR = 156,
    VT_MATCHTOL = 158,
    VT_LUCENCYLEVEL = 160,
    VT_DIMMODE = 162,
    VT_RELATIONTYPE = 164,
    VT_ORIGINID = 166,
    VT_FIRSTGEOMID = 168,
    VT_FIRSTGEOMPNT = 170,
    VT_ISALIGNDIMCHAIN = 172,
    VT_DIMCHAINSIDELINEVIS = 174,
    VT_DIMCHAINSIDELINEJOG = 176,
    VT_CROSSCURVEINDEX = 178,
    VT_ORIGININDEX = 180,
    VT_ARCDIMSTYLE = 182,
    VT_ARCLEADSTYLE = 184,
    VT_REFERENCEANDINSPECTION1 = 186,
    VT_REFERENCEANDINSPECTION2 = 188,
    VT_ISMANUAL = 190,
    VT_MANUALVALUE = 192,
    VT_ARCLENBOUNDTYPE = 194,
    VT_ARCLENSYMBOLPOS = 196,
    VT_AUTOADJUSTBOUNDARYPNT = 198
  };
  const flatbuffers::String *ConstraintType() const {
    return GetPointer<const flatbuffers::String *>(VT_CONSTRAINTTYPE);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *FirstSnapTopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRSTSNAPTOPOID);
  }
  int32_t FirstSnapId() const {
    return GetField<int32_t>(VT_FIRSTSNAPID, 0);
  }
  int32_t FirstSnapType() const {
    return GetField<int32_t>(VT_FIRSTSNAPTYPE, 0);
  }
  const flatbuffers::Vector<double> *FirstPickPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_FIRSTPICKPNT);
  }
  const flatbuffers::String *SecondSnapTopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_SECONDSNAPTOPOID);
  }
  int32_t SecondSnapId() const {
    return GetField<int32_t>(VT_SECONDSNAPID, 0);
  }
  int32_t SecondSnapType() const {
    return GetField<int32_t>(VT_SECONDSNAPTYPE, 0);
  }
  const flatbuffers::Vector<double> *SecondPickPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_SECONDPICKPNT);
  }
  const flatbuffers::String *ThirdSnapTopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_THIRDSNAPTOPOID);
  }
  int32_t ThirdSnapId() const {
    return GetField<int32_t>(VT_THIRDSNAPID, 0);
  }
  int32_t ThirdSnapType() const {
    return GetField<int32_t>(VT_THIRDSNAPTYPE, 0);
  }
  const flatbuffers::Vector<double> *ThirdPickPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_THIRDPICKPNT);
  }
  const flatbuffers::String *TextContent() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTCONTENT);
  }
  int32_t ParamIndex() const {
    return GetField<int32_t>(VT_PARAMINDEX, 0);
  }
  const flatbuffers::Vector<double> *DimPosition() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIMPOSITION);
  }
  int32_t Direction() const {
    return GetField<int32_t>(VT_DIRECTION, 0);
  }
  const FlatBufferDocSpace::VariableData *DimVariable() const {
    return GetPointer<const FlatBufferDocSpace::VariableData *>(VT_DIMVARIABLE);
  }
  int32_t DimStatus() const {
    return GetField<int32_t>(VT_DIMSTATUS, 0);
  }
  int32_t DiameterFlag() const {
    return GetField<int32_t>(VT_DIAMETERFLAG, 0);
  }
  int32_t DimTextPos() const {
    return GetField<int32_t>(VT_DIMTEXTPOS, 0);
  }
  int32_t IsReference() const {
    return GetField<int32_t>(VT_ISREFERENCE, 0);
  }
  int32_t ValPrecision() const {
    return GetField<int32_t>(VT_VALPRECISION, 0);
  }
  int32_t TolPrecision() const {
    return GetField<int32_t>(VT_TOLPRECISION, 0);
  }
  int32_t TolType() const {
    return GetField<int32_t>(VT_TOLTYPE, 0);
  }
  int32_t ArrowPos() const {
    return GetField<int32_t>(VT_ARROWPOS, 0);
  }
  int32_t LeftArrowType() const {
    return GetField<int32_t>(VT_LEFTARROWTYPE, 0);
  }
  int32_t RightArrowType() const {
    return GetField<int32_t>(VT_RIGHTARROWTYPE, 0);
  }
  int32_t DimLineType() const {
    return GetField<int32_t>(VT_DIMLINETYPE, 0);
  }
  int32_t DimLineWidth() const {
    return GetField<int32_t>(VT_DIMLINEWIDTH, 0);
  }
  int32_t DimColor() const {
    return GetField<int32_t>(VT_DIMCOLOR, 0);
  }
  const flatbuffers::String *FontName() const {
    return GetPointer<const flatbuffers::String *>(VT_FONTNAME);
  }
  double FontSize() const {
    return GetField<double>(VT_FONTSIZE, 0.0);
  }
  int32_t FontGap() const {
    return GetField<int32_t>(VT_FONTGAP, 0);
  }
  int32_t FontColor() const {
    return GetField<int32_t>(VT_FONTCOLOR, 0);
  }
  int32_t IsItalic() const {
    return GetField<int32_t>(VT_ISITALIC, 0);
  }
  int32_t IsBold() const {
    return GetField<int32_t>(VT_ISBOLD, 0);
  }
  int32_t IsUnderLine() const {
    return GetField<int32_t>(VT_ISUNDERLINE, 0);
  }
  const flatbuffers::String *Text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  int32_t PatternType() const {
    return GetField<int32_t>(VT_PATTERNTYPE, 0);
  }
  int32_t PatternEleNum() const {
    return GetField<int32_t>(VT_PATTERNELENUM, 0);
  }
  int32_t CopyNum1() const {
    return GetField<int32_t>(VT_COPYNUM1, 0);
  }
  int32_t CopyNum2() const {
    return GetField<int32_t>(VT_COPYNUM2, 0);
  }
  const flatbuffers::String *SkipInstance() const {
    return GetPointer<const flatbuffers::String *>(VT_SKIPINSTANCE);
  }
  const flatbuffers::String *DeleteElement() const {
    return GetPointer<const flatbuffers::String *>(VT_DELETEELEMENT);
  }
  int32_t AngleFlag() const {
    return GetField<int32_t>(VT_ANGLEFLAG, 0);
  }
  int32_t CopyNum() const {
    return GetField<int32_t>(VT_COPYNUM, 0);
  }
  int32_t CopyNumIndex() const {
    return GetField<int32_t>(VT_COPYNUMINDEX, 0);
  }
  int32_t PatternConstIndex() const {
    return GetField<int32_t>(VT_PATTERNCONSTINDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *Geometries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *>(VT_GEOMETRIES);
  }
  int32_t FirstArcFlag() const {
    return GetField<int32_t>(VT_FIRSTARCFLAG, 0);
  }
  int32_t SecondArcFlag() const {
    return GetField<int32_t>(VT_SECONDARCFLAG, 0);
  }
  int32_t FirstSilhouetteIndex() const {
    return GetField<int32_t>(VT_FIRSTSILHOUETTEINDEX, 0);
  }
  int32_t SecondSilhouetteIndex() const {
    return GetField<int32_t>(VT_SECONDSILHOUETTEINDEX, 0);
  }
  int32_t ThirdSilhouetteIndex() const {
    return GetField<int32_t>(VT_THIRDSILHOUETTEINDEX, 0);
  }
  int32_t RadiusOrDiameter() const {
    return GetField<int32_t>(VT_RADIUSORDIAMETER, 0);
  }
  const flatbuffers::String *FirstInstanceIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRSTINSTANCEINDEX);
  }
  const flatbuffers::String *SecondInstanceIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_SECONDINSTANCEINDEX);
  }
  const flatbuffers::String *ThirdInstanceIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_THIRDINSTANCEINDEX);
  }
  const flatbuffers::String *ImageDatabaseId() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGEDATABASEID);
  }
  const flatbuffers::String *FileName() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  double OriginXPos() const {
    return GetField<double>(VT_ORIGINXPOS, 0.0);
  }
  double OriginYPos() const {
    return GetField<double>(VT_ORIGINYPOS, 0.0);
  }
  double Angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  double Width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  double Height() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  int32_t ScaleTool() const {
    return GetField<int32_t>(VT_SCALETOOL, 0);
  }
  const flatbuffers::Vector<double> *StartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTPNT);
  }
  const flatbuffers::Vector<double> *EndPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDPNT);
  }
  int32_t StartStatus() const {
    return GetField<int32_t>(VT_STARTSTATUS, 0);
  }
  int32_t EndStatus() const {
    return GetField<int32_t>(VT_ENDSTATUS, 0);
  }
  int32_t ClockPro() const {
    return GetField<int32_t>(VT_CLOCKPRO, 0);
  }
  int32_t HorizonalFlg() const {
    return GetField<int32_t>(VT_HORIZONALFLG, 0);
  }
  int32_t VerticalFlg() const {
    return GetField<int32_t>(VT_VERTICALFLG, 0);
  }
  int32_t LucencyMode() const {
    return GetField<int32_t>(VT_LUCENCYMODE, 0);
  }
  const flatbuffers::String *LucencyColor() const {
    return GetPointer<const flatbuffers::String *>(VT_LUCENCYCOLOR);
  }
  double MatchTol() const {
    return GetField<double>(VT_MATCHTOL, 0.0);
  }
  double LucencyLevel() const {
    return GetField<double>(VT_LUCENCYLEVEL, 0.0);
  }
  int32_t DimMode() const {
    return GetField<int32_t>(VT_DIMMODE, 0);
  }
  int32_t RelationType() const {
    return GetField<int32_t>(VT_RELATIONTYPE, 0);
  }
  int32_t OriginId() const {
    return GetField<int32_t>(VT_ORIGINID, 0);
  }
  int32_t FirstGeomId() const {
    return GetField<int32_t>(VT_FIRSTGEOMID, 0);
  }
  const flatbuffers::Vector<double> *FirstGeomPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_FIRSTGEOMPNT);
  }
  int32_t IsAlignDimChain() const {
    return GetField<int32_t>(VT_ISALIGNDIMCHAIN, 0);
  }
  int32_t DimChainSideLineVis() const {
    return GetField<int32_t>(VT_DIMCHAINSIDELINEVIS, 0);
  }
  int32_t DimChainSideLineJog() const {
    return GetField<int32_t>(VT_DIMCHAINSIDELINEJOG, 0);
  }
  int32_t CrossCurveIndex() const {
    return GetField<int32_t>(VT_CROSSCURVEINDEX, 0);
  }
  int32_t OriginIndex() const {
    return GetField<int32_t>(VT_ORIGININDEX, 0);
  }
  int32_t ArcDimStyle() const {
    return GetField<int32_t>(VT_ARCDIMSTYLE, 0);
  }
  int32_t ArcLeadStyle() const {
    return GetField<int32_t>(VT_ARCLEADSTYLE, 0);
  }
  int32_t ReferenceAndInspection1() const {
    return GetField<int32_t>(VT_REFERENCEANDINSPECTION1, 0);
  }
  int32_t ReferenceAndInspection2() const {
    return GetField<int32_t>(VT_REFERENCEANDINSPECTION2, 0);
  }
  int32_t IsManual() const {
    return GetField<int32_t>(VT_ISMANUAL, 0);
  }
  const flatbuffers::String *ManualValue() const {
    return GetPointer<const flatbuffers::String *>(VT_MANUALVALUE);
  }
  int32_t ArcLenBoundType() const {
    return GetField<int32_t>(VT_ARCLENBOUNDTYPE, 0);
  }
  int32_t ArcLenSymbolPos() const {
    return GetField<int32_t>(VT_ARCLENSYMBOLPOS, 0);
  }
  int32_t AutoAdjustBoundaryPnt() const {
    return GetField<int32_t>(VT_AUTOADJUSTBOUNDARYPNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONSTRAINTTYPE) &&
           verifier.VerifyString(ConstraintType()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FIRSTSNAPTOPOID) &&
           verifier.VerifyString(FirstSnapTopoId()) &&
           VerifyField<int32_t>(verifier, VT_FIRSTSNAPID) &&
           VerifyField<int32_t>(verifier, VT_FIRSTSNAPTYPE) &&
           VerifyOffset(verifier, VT_FIRSTPICKPNT) &&
           verifier.VerifyVector(FirstPickPnt()) &&
           VerifyOffset(verifier, VT_SECONDSNAPTOPOID) &&
           verifier.VerifyString(SecondSnapTopoId()) &&
           VerifyField<int32_t>(verifier, VT_SECONDSNAPID) &&
           VerifyField<int32_t>(verifier, VT_SECONDSNAPTYPE) &&
           VerifyOffset(verifier, VT_SECONDPICKPNT) &&
           verifier.VerifyVector(SecondPickPnt()) &&
           VerifyOffset(verifier, VT_THIRDSNAPTOPOID) &&
           verifier.VerifyString(ThirdSnapTopoId()) &&
           VerifyField<int32_t>(verifier, VT_THIRDSNAPID) &&
           VerifyField<int32_t>(verifier, VT_THIRDSNAPTYPE) &&
           VerifyOffset(verifier, VT_THIRDPICKPNT) &&
           verifier.VerifyVector(ThirdPickPnt()) &&
           VerifyOffset(verifier, VT_TEXTCONTENT) &&
           verifier.VerifyString(TextContent()) &&
           VerifyField<int32_t>(verifier, VT_PARAMINDEX) &&
           VerifyOffset(verifier, VT_DIMPOSITION) &&
           verifier.VerifyVector(DimPosition()) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION) &&
           VerifyOffset(verifier, VT_DIMVARIABLE) &&
           verifier.VerifyTable(DimVariable()) &&
           VerifyField<int32_t>(verifier, VT_DIMSTATUS) &&
           VerifyField<int32_t>(verifier, VT_DIAMETERFLAG) &&
           VerifyField<int32_t>(verifier, VT_DIMTEXTPOS) &&
           VerifyField<int32_t>(verifier, VT_ISREFERENCE) &&
           VerifyField<int32_t>(verifier, VT_VALPRECISION) &&
           VerifyField<int32_t>(verifier, VT_TOLPRECISION) &&
           VerifyField<int32_t>(verifier, VT_TOLTYPE) &&
           VerifyField<int32_t>(verifier, VT_ARROWPOS) &&
           VerifyField<int32_t>(verifier, VT_LEFTARROWTYPE) &&
           VerifyField<int32_t>(verifier, VT_RIGHTARROWTYPE) &&
           VerifyField<int32_t>(verifier, VT_DIMLINETYPE) &&
           VerifyField<int32_t>(verifier, VT_DIMLINEWIDTH) &&
           VerifyField<int32_t>(verifier, VT_DIMCOLOR) &&
           VerifyOffset(verifier, VT_FONTNAME) &&
           verifier.VerifyString(FontName()) &&
           VerifyField<double>(verifier, VT_FONTSIZE) &&
           VerifyField<int32_t>(verifier, VT_FONTGAP) &&
           VerifyField<int32_t>(verifier, VT_FONTCOLOR) &&
           VerifyField<int32_t>(verifier, VT_ISITALIC) &&
           VerifyField<int32_t>(verifier, VT_ISBOLD) &&
           VerifyField<int32_t>(verifier, VT_ISUNDERLINE) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(Text()) &&
           VerifyField<int32_t>(verifier, VT_PATTERNTYPE) &&
           VerifyField<int32_t>(verifier, VT_PATTERNELENUM) &&
           VerifyField<int32_t>(verifier, VT_COPYNUM1) &&
           VerifyField<int32_t>(verifier, VT_COPYNUM2) &&
           VerifyOffset(verifier, VT_SKIPINSTANCE) &&
           verifier.VerifyString(SkipInstance()) &&
           VerifyOffset(verifier, VT_DELETEELEMENT) &&
           verifier.VerifyString(DeleteElement()) &&
           VerifyField<int32_t>(verifier, VT_ANGLEFLAG) &&
           VerifyField<int32_t>(verifier, VT_COPYNUM) &&
           VerifyField<int32_t>(verifier, VT_COPYNUMINDEX) &&
           VerifyField<int32_t>(verifier, VT_PATTERNCONSTINDEX) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.VerifyVector(Geometries()) &&
           verifier.VerifyVectorOfTables(Geometries()) &&
           VerifyField<int32_t>(verifier, VT_FIRSTARCFLAG) &&
           VerifyField<int32_t>(verifier, VT_SECONDARCFLAG) &&
           VerifyField<int32_t>(verifier, VT_FIRSTSILHOUETTEINDEX) &&
           VerifyField<int32_t>(verifier, VT_SECONDSILHOUETTEINDEX) &&
           VerifyField<int32_t>(verifier, VT_THIRDSILHOUETTEINDEX) &&
           VerifyField<int32_t>(verifier, VT_RADIUSORDIAMETER) &&
           VerifyOffset(verifier, VT_FIRSTINSTANCEINDEX) &&
           verifier.VerifyString(FirstInstanceIndex()) &&
           VerifyOffset(verifier, VT_SECONDINSTANCEINDEX) &&
           verifier.VerifyString(SecondInstanceIndex()) &&
           VerifyOffset(verifier, VT_THIRDINSTANCEINDEX) &&
           verifier.VerifyString(ThirdInstanceIndex()) &&
           VerifyOffset(verifier, VT_IMAGEDATABASEID) &&
           verifier.VerifyString(ImageDatabaseId()) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(FileName()) &&
           VerifyField<double>(verifier, VT_ORIGINXPOS) &&
           VerifyField<double>(verifier, VT_ORIGINYPOS) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           VerifyField<double>(verifier, VT_WIDTH) &&
           VerifyField<double>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_SCALETOOL) &&
           VerifyOffset(verifier, VT_STARTPNT) &&
           verifier.VerifyVector(StartPnt()) &&
           VerifyOffset(verifier, VT_ENDPNT) &&
           verifier.VerifyVector(EndPnt()) &&
           VerifyField<int32_t>(verifier, VT_STARTSTATUS) &&
           VerifyField<int32_t>(verifier, VT_ENDSTATUS) &&
           VerifyField<int32_t>(verifier, VT_CLOCKPRO) &&
           VerifyField<int32_t>(verifier, VT_HORIZONALFLG) &&
           VerifyField<int32_t>(verifier, VT_VERTICALFLG) &&
           VerifyField<int32_t>(verifier, VT_LUCENCYMODE) &&
           VerifyOffset(verifier, VT_LUCENCYCOLOR) &&
           verifier.VerifyString(LucencyColor()) &&
           VerifyField<double>(verifier, VT_MATCHTOL) &&
           VerifyField<double>(verifier, VT_LUCENCYLEVEL) &&
           VerifyField<int32_t>(verifier, VT_DIMMODE) &&
           VerifyField<int32_t>(verifier, VT_RELATIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_ORIGINID) &&
           VerifyField<int32_t>(verifier, VT_FIRSTGEOMID) &&
           VerifyOffset(verifier, VT_FIRSTGEOMPNT) &&
           verifier.VerifyVector(FirstGeomPnt()) &&
           VerifyField<int32_t>(verifier, VT_ISALIGNDIMCHAIN) &&
           VerifyField<int32_t>(verifier, VT_DIMCHAINSIDELINEVIS) &&
           VerifyField<int32_t>(verifier, VT_DIMCHAINSIDELINEJOG) &&
           VerifyField<int32_t>(verifier, VT_CROSSCURVEINDEX) &&
           VerifyField<int32_t>(verifier, VT_ORIGININDEX) &&
           VerifyField<int32_t>(verifier, VT_ARCDIMSTYLE) &&
           VerifyField<int32_t>(verifier, VT_ARCLEADSTYLE) &&
           VerifyField<int32_t>(verifier, VT_REFERENCEANDINSPECTION1) &&
           VerifyField<int32_t>(verifier, VT_REFERENCEANDINSPECTION2) &&
           VerifyField<int32_t>(verifier, VT_ISMANUAL) &&
           VerifyOffset(verifier, VT_MANUALVALUE) &&
           verifier.VerifyString(ManualValue()) &&
           VerifyField<int32_t>(verifier, VT_ARCLENBOUNDTYPE) &&
           VerifyField<int32_t>(verifier, VT_ARCLENSYMBOLPOS) &&
           VerifyField<int32_t>(verifier, VT_AUTOADJUSTBOUNDARYPNT) &&
           verifier.EndTable();
  }
};

struct ConstraintsDataBuilder {
  typedef ConstraintsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ConstraintType(flatbuffers::Offset<flatbuffers::String> ConstraintType) {
    fbb_.AddOffset(ConstraintsData::VT_CONSTRAINTTYPE, ConstraintType);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_TYPE, Type, 0);
  }
  void add_FirstSnapTopoId(flatbuffers::Offset<flatbuffers::String> FirstSnapTopoId) {
    fbb_.AddOffset(ConstraintsData::VT_FIRSTSNAPTOPOID, FirstSnapTopoId);
  }
  void add_FirstSnapId(int32_t FirstSnapId) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_FIRSTSNAPID, FirstSnapId, 0);
  }
  void add_FirstSnapType(int32_t FirstSnapType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_FIRSTSNAPTYPE, FirstSnapType, 0);
  }
  void add_FirstPickPnt(flatbuffers::Offset<flatbuffers::Vector<double>> FirstPickPnt) {
    fbb_.AddOffset(ConstraintsData::VT_FIRSTPICKPNT, FirstPickPnt);
  }
  void add_SecondSnapTopoId(flatbuffers::Offset<flatbuffers::String> SecondSnapTopoId) {
    fbb_.AddOffset(ConstraintsData::VT_SECONDSNAPTOPOID, SecondSnapTopoId);
  }
  void add_SecondSnapId(int32_t SecondSnapId) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_SECONDSNAPID, SecondSnapId, 0);
  }
  void add_SecondSnapType(int32_t SecondSnapType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_SECONDSNAPTYPE, SecondSnapType, 0);
  }
  void add_SecondPickPnt(flatbuffers::Offset<flatbuffers::Vector<double>> SecondPickPnt) {
    fbb_.AddOffset(ConstraintsData::VT_SECONDPICKPNT, SecondPickPnt);
  }
  void add_ThirdSnapTopoId(flatbuffers::Offset<flatbuffers::String> ThirdSnapTopoId) {
    fbb_.AddOffset(ConstraintsData::VT_THIRDSNAPTOPOID, ThirdSnapTopoId);
  }
  void add_ThirdSnapId(int32_t ThirdSnapId) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_THIRDSNAPID, ThirdSnapId, 0);
  }
  void add_ThirdSnapType(int32_t ThirdSnapType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_THIRDSNAPTYPE, ThirdSnapType, 0);
  }
  void add_ThirdPickPnt(flatbuffers::Offset<flatbuffers::Vector<double>> ThirdPickPnt) {
    fbb_.AddOffset(ConstraintsData::VT_THIRDPICKPNT, ThirdPickPnt);
  }
  void add_TextContent(flatbuffers::Offset<flatbuffers::String> TextContent) {
    fbb_.AddOffset(ConstraintsData::VT_TEXTCONTENT, TextContent);
  }
  void add_ParamIndex(int32_t ParamIndex) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_PARAMINDEX, ParamIndex, 0);
  }
  void add_DimPosition(flatbuffers::Offset<flatbuffers::Vector<double>> DimPosition) {
    fbb_.AddOffset(ConstraintsData::VT_DIMPOSITION, DimPosition);
  }
  void add_Direction(int32_t Direction) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIRECTION, Direction, 0);
  }
  void add_DimVariable(flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable) {
    fbb_.AddOffset(ConstraintsData::VT_DIMVARIABLE, DimVariable);
  }
  void add_DimStatus(int32_t DimStatus) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIMSTATUS, DimStatus, 0);
  }
  void add_DiameterFlag(int32_t DiameterFlag) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIAMETERFLAG, DiameterFlag, 0);
  }
  void add_DimTextPos(int32_t DimTextPos) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIMTEXTPOS, DimTextPos, 0);
  }
  void add_IsReference(int32_t IsReference) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ISREFERENCE, IsReference, 0);
  }
  void add_ValPrecision(int32_t ValPrecision) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_VALPRECISION, ValPrecision, 0);
  }
  void add_TolPrecision(int32_t TolPrecision) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_TOLPRECISION, TolPrecision, 0);
  }
  void add_TolType(int32_t TolType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_TOLTYPE, TolType, 0);
  }
  void add_ArrowPos(int32_t ArrowPos) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ARROWPOS, ArrowPos, 0);
  }
  void add_LeftArrowType(int32_t LeftArrowType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_LEFTARROWTYPE, LeftArrowType, 0);
  }
  void add_RightArrowType(int32_t RightArrowType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_RIGHTARROWTYPE, RightArrowType, 0);
  }
  void add_DimLineType(int32_t DimLineType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIMLINETYPE, DimLineType, 0);
  }
  void add_DimLineWidth(int32_t DimLineWidth) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIMLINEWIDTH, DimLineWidth, 0);
  }
  void add_DimColor(int32_t DimColor) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIMCOLOR, DimColor, 0);
  }
  void add_FontName(flatbuffers::Offset<flatbuffers::String> FontName) {
    fbb_.AddOffset(ConstraintsData::VT_FONTNAME, FontName);
  }
  void add_FontSize(double FontSize) {
    fbb_.AddElement<double>(ConstraintsData::VT_FONTSIZE, FontSize, 0.0);
  }
  void add_FontGap(int32_t FontGap) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_FONTGAP, FontGap, 0);
  }
  void add_FontColor(int32_t FontColor) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_FONTCOLOR, FontColor, 0);
  }
  void add_IsItalic(int32_t IsItalic) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ISITALIC, IsItalic, 0);
  }
  void add_IsBold(int32_t IsBold) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ISBOLD, IsBold, 0);
  }
  void add_IsUnderLine(int32_t IsUnderLine) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ISUNDERLINE, IsUnderLine, 0);
  }
  void add_Text(flatbuffers::Offset<flatbuffers::String> Text) {
    fbb_.AddOffset(ConstraintsData::VT_TEXT, Text);
  }
  void add_PatternType(int32_t PatternType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_PATTERNTYPE, PatternType, 0);
  }
  void add_PatternEleNum(int32_t PatternEleNum) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_PATTERNELENUM, PatternEleNum, 0);
  }
  void add_CopyNum1(int32_t CopyNum1) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_COPYNUM1, CopyNum1, 0);
  }
  void add_CopyNum2(int32_t CopyNum2) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_COPYNUM2, CopyNum2, 0);
  }
  void add_SkipInstance(flatbuffers::Offset<flatbuffers::String> SkipInstance) {
    fbb_.AddOffset(ConstraintsData::VT_SKIPINSTANCE, SkipInstance);
  }
  void add_DeleteElement(flatbuffers::Offset<flatbuffers::String> DeleteElement) {
    fbb_.AddOffset(ConstraintsData::VT_DELETEELEMENT, DeleteElement);
  }
  void add_AngleFlag(int32_t AngleFlag) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ANGLEFLAG, AngleFlag, 0);
  }
  void add_CopyNum(int32_t CopyNum) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_COPYNUM, CopyNum, 0);
  }
  void add_CopyNumIndex(int32_t CopyNumIndex) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_COPYNUMINDEX, CopyNumIndex, 0);
  }
  void add_PatternConstIndex(int32_t PatternConstIndex) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_PATTERNCONSTINDEX, PatternConstIndex, 0);
  }
  void add_Geometries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>> Geometries) {
    fbb_.AddOffset(ConstraintsData::VT_GEOMETRIES, Geometries);
  }
  void add_FirstArcFlag(int32_t FirstArcFlag) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_FIRSTARCFLAG, FirstArcFlag, 0);
  }
  void add_SecondArcFlag(int32_t SecondArcFlag) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_SECONDARCFLAG, SecondArcFlag, 0);
  }
  void add_FirstSilhouetteIndex(int32_t FirstSilhouetteIndex) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_FIRSTSILHOUETTEINDEX, FirstSilhouetteIndex, 0);
  }
  void add_SecondSilhouetteIndex(int32_t SecondSilhouetteIndex) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_SECONDSILHOUETTEINDEX, SecondSilhouetteIndex, 0);
  }
  void add_ThirdSilhouetteIndex(int32_t ThirdSilhouetteIndex) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_THIRDSILHOUETTEINDEX, ThirdSilhouetteIndex, 0);
  }
  void add_RadiusOrDiameter(int32_t RadiusOrDiameter) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_RADIUSORDIAMETER, RadiusOrDiameter, 0);
  }
  void add_FirstInstanceIndex(flatbuffers::Offset<flatbuffers::String> FirstInstanceIndex) {
    fbb_.AddOffset(ConstraintsData::VT_FIRSTINSTANCEINDEX, FirstInstanceIndex);
  }
  void add_SecondInstanceIndex(flatbuffers::Offset<flatbuffers::String> SecondInstanceIndex) {
    fbb_.AddOffset(ConstraintsData::VT_SECONDINSTANCEINDEX, SecondInstanceIndex);
  }
  void add_ThirdInstanceIndex(flatbuffers::Offset<flatbuffers::String> ThirdInstanceIndex) {
    fbb_.AddOffset(ConstraintsData::VT_THIRDINSTANCEINDEX, ThirdInstanceIndex);
  }
  void add_ImageDatabaseId(flatbuffers::Offset<flatbuffers::String> ImageDatabaseId) {
    fbb_.AddOffset(ConstraintsData::VT_IMAGEDATABASEID, ImageDatabaseId);
  }
  void add_FileName(flatbuffers::Offset<flatbuffers::String> FileName) {
    fbb_.AddOffset(ConstraintsData::VT_FILENAME, FileName);
  }
  void add_OriginXPos(double OriginXPos) {
    fbb_.AddElement<double>(ConstraintsData::VT_ORIGINXPOS, OriginXPos, 0.0);
  }
  void add_OriginYPos(double OriginYPos) {
    fbb_.AddElement<double>(ConstraintsData::VT_ORIGINYPOS, OriginYPos, 0.0);
  }
  void add_Angle(double Angle) {
    fbb_.AddElement<double>(ConstraintsData::VT_ANGLE, Angle, 0.0);
  }
  void add_Width(double Width) {
    fbb_.AddElement<double>(ConstraintsData::VT_WIDTH, Width, 0.0);
  }
  void add_Height(double Height) {
    fbb_.AddElement<double>(ConstraintsData::VT_HEIGHT, Height, 0.0);
  }
  void add_ScaleTool(int32_t ScaleTool) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_SCALETOOL, ScaleTool, 0);
  }
  void add_StartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt) {
    fbb_.AddOffset(ConstraintsData::VT_STARTPNT, StartPnt);
  }
  void add_EndPnt(flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt) {
    fbb_.AddOffset(ConstraintsData::VT_ENDPNT, EndPnt);
  }
  void add_StartStatus(int32_t StartStatus) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_STARTSTATUS, StartStatus, 0);
  }
  void add_EndStatus(int32_t EndStatus) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ENDSTATUS, EndStatus, 0);
  }
  void add_ClockPro(int32_t ClockPro) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_CLOCKPRO, ClockPro, 0);
  }
  void add_HorizonalFlg(int32_t HorizonalFlg) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_HORIZONALFLG, HorizonalFlg, 0);
  }
  void add_VerticalFlg(int32_t VerticalFlg) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_VERTICALFLG, VerticalFlg, 0);
  }
  void add_LucencyMode(int32_t LucencyMode) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_LUCENCYMODE, LucencyMode, 0);
  }
  void add_LucencyColor(flatbuffers::Offset<flatbuffers::String> LucencyColor) {
    fbb_.AddOffset(ConstraintsData::VT_LUCENCYCOLOR, LucencyColor);
  }
  void add_MatchTol(double MatchTol) {
    fbb_.AddElement<double>(ConstraintsData::VT_MATCHTOL, MatchTol, 0.0);
  }
  void add_LucencyLevel(double LucencyLevel) {
    fbb_.AddElement<double>(ConstraintsData::VT_LUCENCYLEVEL, LucencyLevel, 0.0);
  }
  void add_DimMode(int32_t DimMode) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIMMODE, DimMode, 0);
  }
  void add_RelationType(int32_t RelationType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_RELATIONTYPE, RelationType, 0);
  }
  void add_OriginId(int32_t OriginId) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ORIGINID, OriginId, 0);
  }
  void add_FirstGeomId(int32_t FirstGeomId) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_FIRSTGEOMID, FirstGeomId, 0);
  }
  void add_FirstGeomPnt(flatbuffers::Offset<flatbuffers::Vector<double>> FirstGeomPnt) {
    fbb_.AddOffset(ConstraintsData::VT_FIRSTGEOMPNT, FirstGeomPnt);
  }
  void add_IsAlignDimChain(int32_t IsAlignDimChain) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ISALIGNDIMCHAIN, IsAlignDimChain, 0);
  }
  void add_DimChainSideLineVis(int32_t DimChainSideLineVis) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIMCHAINSIDELINEVIS, DimChainSideLineVis, 0);
  }
  void add_DimChainSideLineJog(int32_t DimChainSideLineJog) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_DIMCHAINSIDELINEJOG, DimChainSideLineJog, 0);
  }
  void add_CrossCurveIndex(int32_t CrossCurveIndex) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_CROSSCURVEINDEX, CrossCurveIndex, 0);
  }
  void add_OriginIndex(int32_t OriginIndex) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ORIGININDEX, OriginIndex, 0);
  }
  void add_ArcDimStyle(int32_t ArcDimStyle) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ARCDIMSTYLE, ArcDimStyle, 0);
  }
  void add_ArcLeadStyle(int32_t ArcLeadStyle) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ARCLEADSTYLE, ArcLeadStyle, 0);
  }
  void add_ReferenceAndInspection1(int32_t ReferenceAndInspection1) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_REFERENCEANDINSPECTION1, ReferenceAndInspection1, 0);
  }
  void add_ReferenceAndInspection2(int32_t ReferenceAndInspection2) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_REFERENCEANDINSPECTION2, ReferenceAndInspection2, 0);
  }
  void add_IsManual(int32_t IsManual) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ISMANUAL, IsManual, 0);
  }
  void add_ManualValue(flatbuffers::Offset<flatbuffers::String> ManualValue) {
    fbb_.AddOffset(ConstraintsData::VT_MANUALVALUE, ManualValue);
  }
  void add_ArcLenBoundType(int32_t ArcLenBoundType) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ARCLENBOUNDTYPE, ArcLenBoundType, 0);
  }
  void add_ArcLenSymbolPos(int32_t ArcLenSymbolPos) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_ARCLENSYMBOLPOS, ArcLenSymbolPos, 0);
  }
  void add_AutoAdjustBoundaryPnt(int32_t AutoAdjustBoundaryPnt) {
    fbb_.AddElement<int32_t>(ConstraintsData::VT_AUTOADJUSTBOUNDARYPNT, AutoAdjustBoundaryPnt, 0);
  }
  explicit ConstraintsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstraintsDataBuilder &operator=(const ConstraintsDataBuilder &);
  flatbuffers::Offset<ConstraintsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstraintsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstraintsData> CreateConstraintsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ConstraintType = 0,
    int32_t Type = 0,
    flatbuffers::Offset<flatbuffers::String> FirstSnapTopoId = 0,
    int32_t FirstSnapId = 0,
    int32_t FirstSnapType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> FirstPickPnt = 0,
    flatbuffers::Offset<flatbuffers::String> SecondSnapTopoId = 0,
    int32_t SecondSnapId = 0,
    int32_t SecondSnapType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> SecondPickPnt = 0,
    flatbuffers::Offset<flatbuffers::String> ThirdSnapTopoId = 0,
    int32_t ThirdSnapId = 0,
    int32_t ThirdSnapType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ThirdPickPnt = 0,
    flatbuffers::Offset<flatbuffers::String> TextContent = 0,
    int32_t ParamIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> DimPosition = 0,
    int32_t Direction = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable = 0,
    int32_t DimStatus = 0,
    int32_t DiameterFlag = 0,
    int32_t DimTextPos = 0,
    int32_t IsReference = 0,
    int32_t ValPrecision = 0,
    int32_t TolPrecision = 0,
    int32_t TolType = 0,
    int32_t ArrowPos = 0,
    int32_t LeftArrowType = 0,
    int32_t RightArrowType = 0,
    int32_t DimLineType = 0,
    int32_t DimLineWidth = 0,
    int32_t DimColor = 0,
    flatbuffers::Offset<flatbuffers::String> FontName = 0,
    double FontSize = 0.0,
    int32_t FontGap = 0,
    int32_t FontColor = 0,
    int32_t IsItalic = 0,
    int32_t IsBold = 0,
    int32_t IsUnderLine = 0,
    flatbuffers::Offset<flatbuffers::String> Text = 0,
    int32_t PatternType = 0,
    int32_t PatternEleNum = 0,
    int32_t CopyNum1 = 0,
    int32_t CopyNum2 = 0,
    flatbuffers::Offset<flatbuffers::String> SkipInstance = 0,
    flatbuffers::Offset<flatbuffers::String> DeleteElement = 0,
    int32_t AngleFlag = 0,
    int32_t CopyNum = 0,
    int32_t CopyNumIndex = 0,
    int32_t PatternConstIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>> Geometries = 0,
    int32_t FirstArcFlag = 0,
    int32_t SecondArcFlag = 0,
    int32_t FirstSilhouetteIndex = 0,
    int32_t SecondSilhouetteIndex = 0,
    int32_t ThirdSilhouetteIndex = 0,
    int32_t RadiusOrDiameter = 0,
    flatbuffers::Offset<flatbuffers::String> FirstInstanceIndex = 0,
    flatbuffers::Offset<flatbuffers::String> SecondInstanceIndex = 0,
    flatbuffers::Offset<flatbuffers::String> ThirdInstanceIndex = 0,
    flatbuffers::Offset<flatbuffers::String> ImageDatabaseId = 0,
    flatbuffers::Offset<flatbuffers::String> FileName = 0,
    double OriginXPos = 0.0,
    double OriginYPos = 0.0,
    double Angle = 0.0,
    double Width = 0.0,
    double Height = 0.0,
    int32_t ScaleTool = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt = 0,
    int32_t StartStatus = 0,
    int32_t EndStatus = 0,
    int32_t ClockPro = 0,
    int32_t HorizonalFlg = 0,
    int32_t VerticalFlg = 0,
    int32_t LucencyMode = 0,
    flatbuffers::Offset<flatbuffers::String> LucencyColor = 0,
    double MatchTol = 0.0,
    double LucencyLevel = 0.0,
    int32_t DimMode = 0,
    int32_t RelationType = 0,
    int32_t OriginId = 0,
    int32_t FirstGeomId = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> FirstGeomPnt = 0,
    int32_t IsAlignDimChain = 0,
    int32_t DimChainSideLineVis = 0,
    int32_t DimChainSideLineJog = 0,
    int32_t CrossCurveIndex = 0,
    int32_t OriginIndex = 0,
    int32_t ArcDimStyle = 0,
    int32_t ArcLeadStyle = 0,
    int32_t ReferenceAndInspection1 = 0,
    int32_t ReferenceAndInspection2 = 0,
    int32_t IsManual = 0,
    flatbuffers::Offset<flatbuffers::String> ManualValue = 0,
    int32_t ArcLenBoundType = 0,
    int32_t ArcLenSymbolPos = 0,
    int32_t AutoAdjustBoundaryPnt = 0) {
  ConstraintsDataBuilder builder_(_fbb);
  builder_.add_LucencyLevel(LucencyLevel);
  builder_.add_MatchTol(MatchTol);
  builder_.add_Height(Height);
  builder_.add_Width(Width);
  builder_.add_Angle(Angle);
  builder_.add_OriginYPos(OriginYPos);
  builder_.add_OriginXPos(OriginXPos);
  builder_.add_FontSize(FontSize);
  builder_.add_AutoAdjustBoundaryPnt(AutoAdjustBoundaryPnt);
  builder_.add_ArcLenSymbolPos(ArcLenSymbolPos);
  builder_.add_ArcLenBoundType(ArcLenBoundType);
  builder_.add_ManualValue(ManualValue);
  builder_.add_IsManual(IsManual);
  builder_.add_ReferenceAndInspection2(ReferenceAndInspection2);
  builder_.add_ReferenceAndInspection1(ReferenceAndInspection1);
  builder_.add_ArcLeadStyle(ArcLeadStyle);
  builder_.add_ArcDimStyle(ArcDimStyle);
  builder_.add_OriginIndex(OriginIndex);
  builder_.add_CrossCurveIndex(CrossCurveIndex);
  builder_.add_DimChainSideLineJog(DimChainSideLineJog);
  builder_.add_DimChainSideLineVis(DimChainSideLineVis);
  builder_.add_IsAlignDimChain(IsAlignDimChain);
  builder_.add_FirstGeomPnt(FirstGeomPnt);
  builder_.add_FirstGeomId(FirstGeomId);
  builder_.add_OriginId(OriginId);
  builder_.add_RelationType(RelationType);
  builder_.add_DimMode(DimMode);
  builder_.add_LucencyColor(LucencyColor);
  builder_.add_LucencyMode(LucencyMode);
  builder_.add_VerticalFlg(VerticalFlg);
  builder_.add_HorizonalFlg(HorizonalFlg);
  builder_.add_ClockPro(ClockPro);
  builder_.add_EndStatus(EndStatus);
  builder_.add_StartStatus(StartStatus);
  builder_.add_EndPnt(EndPnt);
  builder_.add_StartPnt(StartPnt);
  builder_.add_ScaleTool(ScaleTool);
  builder_.add_FileName(FileName);
  builder_.add_ImageDatabaseId(ImageDatabaseId);
  builder_.add_ThirdInstanceIndex(ThirdInstanceIndex);
  builder_.add_SecondInstanceIndex(SecondInstanceIndex);
  builder_.add_FirstInstanceIndex(FirstInstanceIndex);
  builder_.add_RadiusOrDiameter(RadiusOrDiameter);
  builder_.add_ThirdSilhouetteIndex(ThirdSilhouetteIndex);
  builder_.add_SecondSilhouetteIndex(SecondSilhouetteIndex);
  builder_.add_FirstSilhouetteIndex(FirstSilhouetteIndex);
  builder_.add_SecondArcFlag(SecondArcFlag);
  builder_.add_FirstArcFlag(FirstArcFlag);
  builder_.add_Geometries(Geometries);
  builder_.add_PatternConstIndex(PatternConstIndex);
  builder_.add_CopyNumIndex(CopyNumIndex);
  builder_.add_CopyNum(CopyNum);
  builder_.add_AngleFlag(AngleFlag);
  builder_.add_DeleteElement(DeleteElement);
  builder_.add_SkipInstance(SkipInstance);
  builder_.add_CopyNum2(CopyNum2);
  builder_.add_CopyNum1(CopyNum1);
  builder_.add_PatternEleNum(PatternEleNum);
  builder_.add_PatternType(PatternType);
  builder_.add_Text(Text);
  builder_.add_IsUnderLine(IsUnderLine);
  builder_.add_IsBold(IsBold);
  builder_.add_IsItalic(IsItalic);
  builder_.add_FontColor(FontColor);
  builder_.add_FontGap(FontGap);
  builder_.add_FontName(FontName);
  builder_.add_DimColor(DimColor);
  builder_.add_DimLineWidth(DimLineWidth);
  builder_.add_DimLineType(DimLineType);
  builder_.add_RightArrowType(RightArrowType);
  builder_.add_LeftArrowType(LeftArrowType);
  builder_.add_ArrowPos(ArrowPos);
  builder_.add_TolType(TolType);
  builder_.add_TolPrecision(TolPrecision);
  builder_.add_ValPrecision(ValPrecision);
  builder_.add_IsReference(IsReference);
  builder_.add_DimTextPos(DimTextPos);
  builder_.add_DiameterFlag(DiameterFlag);
  builder_.add_DimStatus(DimStatus);
  builder_.add_DimVariable(DimVariable);
  builder_.add_Direction(Direction);
  builder_.add_DimPosition(DimPosition);
  builder_.add_ParamIndex(ParamIndex);
  builder_.add_TextContent(TextContent);
  builder_.add_ThirdPickPnt(ThirdPickPnt);
  builder_.add_ThirdSnapType(ThirdSnapType);
  builder_.add_ThirdSnapId(ThirdSnapId);
  builder_.add_ThirdSnapTopoId(ThirdSnapTopoId);
  builder_.add_SecondPickPnt(SecondPickPnt);
  builder_.add_SecondSnapType(SecondSnapType);
  builder_.add_SecondSnapId(SecondSnapId);
  builder_.add_SecondSnapTopoId(SecondSnapTopoId);
  builder_.add_FirstPickPnt(FirstPickPnt);
  builder_.add_FirstSnapType(FirstSnapType);
  builder_.add_FirstSnapId(FirstSnapId);
  builder_.add_FirstSnapTopoId(FirstSnapTopoId);
  builder_.add_Type(Type);
  builder_.add_ConstraintType(ConstraintType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConstraintsData> CreateConstraintsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ConstraintType = nullptr,
    int32_t Type = 0,
    const char *FirstSnapTopoId = nullptr,
    int32_t FirstSnapId = 0,
    int32_t FirstSnapType = 0,
    const std::vector<double> *FirstPickPnt = nullptr,
    const char *SecondSnapTopoId = nullptr,
    int32_t SecondSnapId = 0,
    int32_t SecondSnapType = 0,
    const std::vector<double> *SecondPickPnt = nullptr,
    const char *ThirdSnapTopoId = nullptr,
    int32_t ThirdSnapId = 0,
    int32_t ThirdSnapType = 0,
    const std::vector<double> *ThirdPickPnt = nullptr,
    const char *TextContent = nullptr,
    int32_t ParamIndex = 0,
    const std::vector<double> *DimPosition = nullptr,
    int32_t Direction = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable = 0,
    int32_t DimStatus = 0,
    int32_t DiameterFlag = 0,
    int32_t DimTextPos = 0,
    int32_t IsReference = 0,
    int32_t ValPrecision = 0,
    int32_t TolPrecision = 0,
    int32_t TolType = 0,
    int32_t ArrowPos = 0,
    int32_t LeftArrowType = 0,
    int32_t RightArrowType = 0,
    int32_t DimLineType = 0,
    int32_t DimLineWidth = 0,
    int32_t DimColor = 0,
    const char *FontName = nullptr,
    double FontSize = 0.0,
    int32_t FontGap = 0,
    int32_t FontColor = 0,
    int32_t IsItalic = 0,
    int32_t IsBold = 0,
    int32_t IsUnderLine = 0,
    const char *Text = nullptr,
    int32_t PatternType = 0,
    int32_t PatternEleNum = 0,
    int32_t CopyNum1 = 0,
    int32_t CopyNum2 = 0,
    const char *SkipInstance = nullptr,
    const char *DeleteElement = nullptr,
    int32_t AngleFlag = 0,
    int32_t CopyNum = 0,
    int32_t CopyNumIndex = 0,
    int32_t PatternConstIndex = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *Geometries = nullptr,
    int32_t FirstArcFlag = 0,
    int32_t SecondArcFlag = 0,
    int32_t FirstSilhouetteIndex = 0,
    int32_t SecondSilhouetteIndex = 0,
    int32_t ThirdSilhouetteIndex = 0,
    int32_t RadiusOrDiameter = 0,
    const char *FirstInstanceIndex = nullptr,
    const char *SecondInstanceIndex = nullptr,
    const char *ThirdInstanceIndex = nullptr,
    const char *ImageDatabaseId = nullptr,
    const char *FileName = nullptr,
    double OriginXPos = 0.0,
    double OriginYPos = 0.0,
    double Angle = 0.0,
    double Width = 0.0,
    double Height = 0.0,
    int32_t ScaleTool = 0,
    const std::vector<double> *StartPnt = nullptr,
    const std::vector<double> *EndPnt = nullptr,
    int32_t StartStatus = 0,
    int32_t EndStatus = 0,
    int32_t ClockPro = 0,
    int32_t HorizonalFlg = 0,
    int32_t VerticalFlg = 0,
    int32_t LucencyMode = 0,
    const char *LucencyColor = nullptr,
    double MatchTol = 0.0,
    double LucencyLevel = 0.0,
    int32_t DimMode = 0,
    int32_t RelationType = 0,
    int32_t OriginId = 0,
    int32_t FirstGeomId = 0,
    const std::vector<double> *FirstGeomPnt = nullptr,
    int32_t IsAlignDimChain = 0,
    int32_t DimChainSideLineVis = 0,
    int32_t DimChainSideLineJog = 0,
    int32_t CrossCurveIndex = 0,
    int32_t OriginIndex = 0,
    int32_t ArcDimStyle = 0,
    int32_t ArcLeadStyle = 0,
    int32_t ReferenceAndInspection1 = 0,
    int32_t ReferenceAndInspection2 = 0,
    int32_t IsManual = 0,
    const char *ManualValue = nullptr,
    int32_t ArcLenBoundType = 0,
    int32_t ArcLenSymbolPos = 0,
    int32_t AutoAdjustBoundaryPnt = 0) {
  auto ConstraintType__ = ConstraintType ? _fbb.CreateString(ConstraintType) : 0;
  auto FirstSnapTopoId__ = FirstSnapTopoId ? _fbb.CreateString(FirstSnapTopoId) : 0;
  auto FirstPickPnt__ = FirstPickPnt ? _fbb.CreateVector<double>(*FirstPickPnt) : 0;
  auto SecondSnapTopoId__ = SecondSnapTopoId ? _fbb.CreateString(SecondSnapTopoId) : 0;
  auto SecondPickPnt__ = SecondPickPnt ? _fbb.CreateVector<double>(*SecondPickPnt) : 0;
  auto ThirdSnapTopoId__ = ThirdSnapTopoId ? _fbb.CreateString(ThirdSnapTopoId) : 0;
  auto ThirdPickPnt__ = ThirdPickPnt ? _fbb.CreateVector<double>(*ThirdPickPnt) : 0;
  auto TextContent__ = TextContent ? _fbb.CreateString(TextContent) : 0;
  auto DimPosition__ = DimPosition ? _fbb.CreateVector<double>(*DimPosition) : 0;
  auto FontName__ = FontName ? _fbb.CreateString(FontName) : 0;
  auto Text__ = Text ? _fbb.CreateString(Text) : 0;
  auto SkipInstance__ = SkipInstance ? _fbb.CreateString(SkipInstance) : 0;
  auto DeleteElement__ = DeleteElement ? _fbb.CreateString(DeleteElement) : 0;
  auto Geometries__ = Geometries ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>(*Geometries) : 0;
  auto FirstInstanceIndex__ = FirstInstanceIndex ? _fbb.CreateString(FirstInstanceIndex) : 0;
  auto SecondInstanceIndex__ = SecondInstanceIndex ? _fbb.CreateString(SecondInstanceIndex) : 0;
  auto ThirdInstanceIndex__ = ThirdInstanceIndex ? _fbb.CreateString(ThirdInstanceIndex) : 0;
  auto ImageDatabaseId__ = ImageDatabaseId ? _fbb.CreateString(ImageDatabaseId) : 0;
  auto FileName__ = FileName ? _fbb.CreateString(FileName) : 0;
  auto StartPnt__ = StartPnt ? _fbb.CreateVector<double>(*StartPnt) : 0;
  auto EndPnt__ = EndPnt ? _fbb.CreateVector<double>(*EndPnt) : 0;
  auto LucencyColor__ = LucencyColor ? _fbb.CreateString(LucencyColor) : 0;
  auto FirstGeomPnt__ = FirstGeomPnt ? _fbb.CreateVector<double>(*FirstGeomPnt) : 0;
  auto ManualValue__ = ManualValue ? _fbb.CreateString(ManualValue) : 0;
  return FlatBufferDocSpace::CreateConstraintsData(
      _fbb,
      ConstraintType__,
      Type,
      FirstSnapTopoId__,
      FirstSnapId,
      FirstSnapType,
      FirstPickPnt__,
      SecondSnapTopoId__,
      SecondSnapId,
      SecondSnapType,
      SecondPickPnt__,
      ThirdSnapTopoId__,
      ThirdSnapId,
      ThirdSnapType,
      ThirdPickPnt__,
      TextContent__,
      ParamIndex,
      DimPosition__,
      Direction,
      DimVariable,
      DimStatus,
      DiameterFlag,
      DimTextPos,
      IsReference,
      ValPrecision,
      TolPrecision,
      TolType,
      ArrowPos,
      LeftArrowType,
      RightArrowType,
      DimLineType,
      DimLineWidth,
      DimColor,
      FontName__,
      FontSize,
      FontGap,
      FontColor,
      IsItalic,
      IsBold,
      IsUnderLine,
      Text__,
      PatternType,
      PatternEleNum,
      CopyNum1,
      CopyNum2,
      SkipInstance__,
      DeleteElement__,
      AngleFlag,
      CopyNum,
      CopyNumIndex,
      PatternConstIndex,
      Geometries__,
      FirstArcFlag,
      SecondArcFlag,
      FirstSilhouetteIndex,
      SecondSilhouetteIndex,
      ThirdSilhouetteIndex,
      RadiusOrDiameter,
      FirstInstanceIndex__,
      SecondInstanceIndex__,
      ThirdInstanceIndex__,
      ImageDatabaseId__,
      FileName__,
      OriginXPos,
      OriginYPos,
      Angle,
      Width,
      Height,
      ScaleTool,
      StartPnt__,
      EndPnt__,
      StartStatus,
      EndStatus,
      ClockPro,
      HorizonalFlg,
      VerticalFlg,
      LucencyMode,
      LucencyColor__,
      MatchTol,
      LucencyLevel,
      DimMode,
      RelationType,
      OriginId,
      FirstGeomId,
      FirstGeomPnt__,
      IsAlignDimChain,
      DimChainSideLineVis,
      DimChainSideLineJog,
      CrossCurveIndex,
      OriginIndex,
      ArcDimStyle,
      ArcLeadStyle,
      ReferenceAndInspection1,
      ReferenceAndInspection2,
      IsManual,
      ManualValue__,
      ArcLenBoundType,
      ArcLenSymbolPos,
      AutoAdjustBoundaryPnt);
}

struct SketchTextsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SketchTextsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GT = 4,
    VT_GEOMETRIES = 6,
    VT_TEXTCONTENT = 8,
    VT_INDEX = 10
  };
  int32_t GT() const {
    return GetField<int32_t>(VT_GT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometryIdData>> *Geometries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometryIdData>> *>(VT_GEOMETRIES);
  }
  const flatbuffers::String *TextContent() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTCONTENT);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GT) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.VerifyVector(Geometries()) &&
           verifier.VerifyVectorOfTables(Geometries()) &&
           VerifyOffset(verifier, VT_TEXTCONTENT) &&
           verifier.VerifyString(TextContent()) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           verifier.EndTable();
  }
};

struct SketchTextsDataBuilder {
  typedef SketchTextsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GT(int32_t GT) {
    fbb_.AddElement<int32_t>(SketchTextsData::VT_GT, GT, 0);
  }
  void add_Geometries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometryIdData>>> Geometries) {
    fbb_.AddOffset(SketchTextsData::VT_GEOMETRIES, Geometries);
  }
  void add_TextContent(flatbuffers::Offset<flatbuffers::String> TextContent) {
    fbb_.AddOffset(SketchTextsData::VT_TEXTCONTENT, TextContent);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(SketchTextsData::VT_INDEX, Index, 0);
  }
  explicit SketchTextsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SketchTextsDataBuilder &operator=(const SketchTextsDataBuilder &);
  flatbuffers::Offset<SketchTextsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SketchTextsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SketchTextsData> CreateSketchTextsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t GT = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometryIdData>>> Geometries = 0,
    flatbuffers::Offset<flatbuffers::String> TextContent = 0,
    int32_t Index = 0) {
  SketchTextsDataBuilder builder_(_fbb);
  builder_.add_Index(Index);
  builder_.add_TextContent(TextContent);
  builder_.add_Geometries(Geometries);
  builder_.add_GT(GT);
  return builder_.Finish();
}

inline flatbuffers::Offset<SketchTextsData> CreateSketchTextsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t GT = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::GeometryIdData>> *Geometries = nullptr,
    const char *TextContent = nullptr,
    int32_t Index = 0) {
  auto Geometries__ = Geometries ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::GeometryIdData>>(*Geometries) : 0;
  auto TextContent__ = TextContent ? _fbb.CreateString(TextContent) : 0;
  return FlatBufferDocSpace::CreateSketchTextsData(
      _fbb,
      GT,
      Geometries__,
      TextContent__,
      Index);
}

struct SketchParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SketchParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WORKPLANE = 4,
    VT_GEOMETRIES_TYPE = 6,
    VT_GEOMETRIES = 8,
    VT_CONSTRAINTS = 10,
    VT_SKETCHTEXTS = 12
  };
  const FlatBufferDocSpace::WorkPlaneData *WorkPlane() const {
    return GetPointer<const FlatBufferDocSpace::WorkPlaneData *>(VT_WORKPLANE);
  }
  const flatbuffers::Vector<uint8_t> *Geometries_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_GEOMETRIES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *Geometries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_GEOMETRIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ConstraintsData>> *Constraints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ConstraintsData>> *>(VT_CONSTRAINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchTextsData>> *SketchTexts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchTextsData>> *>(VT_SKETCHTEXTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WORKPLANE) &&
           verifier.VerifyTable(WorkPlane()) &&
           VerifyOffset(verifier, VT_GEOMETRIES_TYPE) &&
           verifier.VerifyVector(Geometries_type()) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.VerifyVector(Geometries()) &&
           VerifyGeometryDataVector(verifier, Geometries(), Geometries_type()) &&
           VerifyOffset(verifier, VT_CONSTRAINTS) &&
           verifier.VerifyVector(Constraints()) &&
           verifier.VerifyVectorOfTables(Constraints()) &&
           VerifyOffset(verifier, VT_SKETCHTEXTS) &&
           verifier.VerifyVector(SketchTexts()) &&
           verifier.VerifyVectorOfTables(SketchTexts()) &&
           verifier.EndTable();
  }
};

struct SketchParamBuilder {
  typedef SketchParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_WorkPlane(flatbuffers::Offset<FlatBufferDocSpace::WorkPlaneData> WorkPlane) {
    fbb_.AddOffset(SketchParam::VT_WORKPLANE, WorkPlane);
  }
  void add_Geometries_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Geometries_type) {
    fbb_.AddOffset(SketchParam::VT_GEOMETRIES_TYPE, Geometries_type);
  }
  void add_Geometries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> Geometries) {
    fbb_.AddOffset(SketchParam::VT_GEOMETRIES, Geometries);
  }
  void add_Constraints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ConstraintsData>>> Constraints) {
    fbb_.AddOffset(SketchParam::VT_CONSTRAINTS, Constraints);
  }
  void add_SketchTexts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchTextsData>>> SketchTexts) {
    fbb_.AddOffset(SketchParam::VT_SKETCHTEXTS, SketchTexts);
  }
  explicit SketchParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SketchParamBuilder &operator=(const SketchParamBuilder &);
  flatbuffers::Offset<SketchParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SketchParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SketchParam> CreateSketchParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::WorkPlaneData> WorkPlane = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Geometries_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> Geometries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ConstraintsData>>> Constraints = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchTextsData>>> SketchTexts = 0) {
  SketchParamBuilder builder_(_fbb);
  builder_.add_SketchTexts(SketchTexts);
  builder_.add_Constraints(Constraints);
  builder_.add_Geometries(Geometries);
  builder_.add_Geometries_type(Geometries_type);
  builder_.add_WorkPlane(WorkPlane);
  return builder_.Finish();
}

inline flatbuffers::Offset<SketchParam> CreateSketchParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::WorkPlaneData> WorkPlane = 0,
    const std::vector<uint8_t> *Geometries_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *Geometries = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ConstraintsData>> *Constraints = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SketchTextsData>> *SketchTexts = nullptr) {
  auto Geometries_type__ = Geometries_type ? _fbb.CreateVector<uint8_t>(*Geometries_type) : 0;
  auto Geometries__ = Geometries ? _fbb.CreateVector<flatbuffers::Offset<void>>(*Geometries) : 0;
  auto Constraints__ = Constraints ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ConstraintsData>>(*Constraints) : 0;
  auto SketchTexts__ = SketchTexts ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SketchTextsData>>(*SketchTexts) : 0;
  return FlatBufferDocSpace::CreateSketchParam(
      _fbb,
      WorkPlane,
      Geometries_type__,
      Geometries__,
      Constraints__,
      SketchTexts__);
}

struct CurrentFeatureData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurrentFeatureDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_INDEX = 6,
    VT_TYPE = 8,
    VT_SUBTYPE = 10,
    VT_NAME = 12,
    VT_PARAMS = 14,
    VT_MID = 16,
    VT_PID = 18
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *Index() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX);
  }
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *SubType() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBTYPE);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const FlatBufferDocSpace::SketchParam *Params() const {
    return GetPointer<const FlatBufferDocSpace::SketchParam *>(VT_PARAMS);
  }
  int32_t MID() const {
    return GetField<int32_t>(VT_MID, 0);
  }
  const flatbuffers::String *PID() const {
    return GetPointer<const flatbuffers::String *>(VT_PID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(Index()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_SUBTYPE) &&
           verifier.VerifyString(SubType()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyTable(Params()) &&
           VerifyField<int32_t>(verifier, VT_MID) &&
           VerifyOffset(verifier, VT_PID) &&
           verifier.VerifyString(PID()) &&
           verifier.EndTable();
  }
};

struct CurrentFeatureDataBuilder {
  typedef CurrentFeatureData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(CurrentFeatureData::VT_ID, ID, 0);
  }
  void add_Index(flatbuffers::Offset<flatbuffers::String> Index) {
    fbb_.AddOffset(CurrentFeatureData::VT_INDEX, Index);
  }
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(CurrentFeatureData::VT_TYPE, Type);
  }
  void add_SubType(flatbuffers::Offset<flatbuffers::String> SubType) {
    fbb_.AddOffset(CurrentFeatureData::VT_SUBTYPE, SubType);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(CurrentFeatureData::VT_NAME, Name);
  }
  void add_Params(flatbuffers::Offset<FlatBufferDocSpace::SketchParam> Params) {
    fbb_.AddOffset(CurrentFeatureData::VT_PARAMS, Params);
  }
  void add_MID(int32_t MID) {
    fbb_.AddElement<int32_t>(CurrentFeatureData::VT_MID, MID, 0);
  }
  void add_PID(flatbuffers::Offset<flatbuffers::String> PID) {
    fbb_.AddOffset(CurrentFeatureData::VT_PID, PID);
  }
  explicit CurrentFeatureDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurrentFeatureDataBuilder &operator=(const CurrentFeatureDataBuilder &);
  flatbuffers::Offset<CurrentFeatureData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurrentFeatureData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurrentFeatureData> CreateCurrentFeatureData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    flatbuffers::Offset<flatbuffers::String> Index = 0,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::String> SubType = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SketchParam> Params = 0,
    int32_t MID = 0,
    flatbuffers::Offset<flatbuffers::String> PID = 0) {
  CurrentFeatureDataBuilder builder_(_fbb);
  builder_.add_PID(PID);
  builder_.add_MID(MID);
  builder_.add_Params(Params);
  builder_.add_Name(Name);
  builder_.add_SubType(SubType);
  builder_.add_Type(Type);
  builder_.add_Index(Index);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<CurrentFeatureData> CreateCurrentFeatureDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    const char *Index = nullptr,
    const char *Type = nullptr,
    const char *SubType = nullptr,
    const char *Name = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::SketchParam> Params = 0,
    int32_t MID = 0,
    const char *PID = nullptr) {
  auto Index__ = Index ? _fbb.CreateString(Index) : 0;
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto SubType__ = SubType ? _fbb.CreateString(SubType) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto PID__ = PID ? _fbb.CreateString(PID) : 0;
  return FlatBufferDocSpace::CreateCurrentFeatureData(
      _fbb,
      ID,
      Index__,
      Type__,
      SubType__,
      Name__,
      Params,
      MID,
      PID__);
}

struct BoxData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoxDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINCORNER = 4,
    VT_MAXCORNER = 6
  };
  const flatbuffers::Vector<double> *MinCorner() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MINCORNER);
  }
  const flatbuffers::Vector<double> *MaxCorner() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAXCORNER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MINCORNER) &&
           verifier.VerifyVector(MinCorner()) &&
           VerifyOffset(verifier, VT_MAXCORNER) &&
           verifier.VerifyVector(MaxCorner()) &&
           verifier.EndTable();
  }
};

struct BoxDataBuilder {
  typedef BoxData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MinCorner(flatbuffers::Offset<flatbuffers::Vector<double>> MinCorner) {
    fbb_.AddOffset(BoxData::VT_MINCORNER, MinCorner);
  }
  void add_MaxCorner(flatbuffers::Offset<flatbuffers::Vector<double>> MaxCorner) {
    fbb_.AddOffset(BoxData::VT_MAXCORNER, MaxCorner);
  }
  explicit BoxDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoxDataBuilder &operator=(const BoxDataBuilder &);
  flatbuffers::Offset<BoxData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoxData>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoxData> CreateBoxData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> MinCorner = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MaxCorner = 0) {
  BoxDataBuilder builder_(_fbb);
  builder_.add_MaxCorner(MaxCorner);
  builder_.add_MinCorner(MinCorner);
  return builder_.Finish();
}

inline flatbuffers::Offset<BoxData> CreateBoxDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *MinCorner = nullptr,
    const std::vector<double> *MaxCorner = nullptr) {
  auto MinCorner__ = MinCorner ? _fbb.CreateVector<double>(*MinCorner) : 0;
  auto MaxCorner__ = MaxCorner ? _fbb.CreateVector<double>(*MaxCorner) : 0;
  return FlatBufferDocSpace::CreateBoxData(
      _fbb,
      MinCorner__,
      MaxCorner__);
}

struct AttributeGeomData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeGeomDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AREA = 4,
    VT_BOX = 6
  };
  double Area() const {
    return GetField<double>(VT_AREA, 0.0);
  }
  const FlatBufferDocSpace::BoxData *Box() const {
    return GetPointer<const FlatBufferDocSpace::BoxData *>(VT_BOX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AREA) &&
           VerifyOffset(verifier, VT_BOX) &&
           verifier.VerifyTable(Box()) &&
           verifier.EndTable();
  }
};

struct AttributeGeomDataBuilder {
  typedef AttributeGeomData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Area(double Area) {
    fbb_.AddElement<double>(AttributeGeomData::VT_AREA, Area, 0.0);
  }
  void add_Box(flatbuffers::Offset<FlatBufferDocSpace::BoxData> Box) {
    fbb_.AddOffset(AttributeGeomData::VT_BOX, Box);
  }
  explicit AttributeGeomDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeGeomDataBuilder &operator=(const AttributeGeomDataBuilder &);
  flatbuffers::Offset<AttributeGeomData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeGeomData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeGeomData> CreateAttributeGeomData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double Area = 0.0,
    flatbuffers::Offset<FlatBufferDocSpace::BoxData> Box = 0) {
  AttributeGeomDataBuilder builder_(_fbb);
  builder_.add_Area(Area);
  builder_.add_Box(Box);
  return builder_.Finish();
}

struct PlaneSurfaceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlaneSurfaceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NORM = 4
  };
  const flatbuffers::Vector<double> *Norm() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_NORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NORM) &&
           verifier.VerifyVector(Norm()) &&
           verifier.EndTable();
  }
};

struct PlaneSurfaceDataBuilder {
  typedef PlaneSurfaceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Norm(flatbuffers::Offset<flatbuffers::Vector<double>> Norm) {
    fbb_.AddOffset(PlaneSurfaceData::VT_NORM, Norm);
  }
  explicit PlaneSurfaceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlaneSurfaceDataBuilder &operator=(const PlaneSurfaceDataBuilder &);
  flatbuffers::Offset<PlaneSurfaceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlaneSurfaceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlaneSurfaceData> CreatePlaneSurfaceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Norm = 0) {
  PlaneSurfaceDataBuilder builder_(_fbb);
  builder_.add_Norm(Norm);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlaneSurfaceData> CreatePlaneSurfaceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Norm = nullptr) {
  auto Norm__ = Norm ? _fbb.CreateVector<double>(*Norm) : 0;
  return FlatBufferDocSpace::CreatePlaneSurfaceData(
      _fbb,
      Norm__);
}

struct CylSurfaceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CylSurfaceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ORIGIN = 6,
    VT_RADIUS = 8,
    VT_STARTANGLE = 10,
    VT_ENDANGLE = 12
  };
  const flatbuffers::Vector<double> *Axis() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_AXIS);
  }
  const flatbuffers::Vector<double> *Origin() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ORIGIN);
  }
  double Radius() const {
    return GetField<double>(VT_RADIUS, 0.0);
  }
  double StartAngle() const {
    return GetField<double>(VT_STARTANGLE, 0.0);
  }
  double EndAngle() const {
    return GetField<double>(VT_ENDANGLE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(Axis()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyVector(Origin()) &&
           VerifyField<double>(verifier, VT_RADIUS) &&
           VerifyField<double>(verifier, VT_STARTANGLE) &&
           VerifyField<double>(verifier, VT_ENDANGLE) &&
           verifier.EndTable();
  }
};

struct CylSurfaceDataBuilder {
  typedef CylSurfaceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Axis(flatbuffers::Offset<flatbuffers::Vector<double>> Axis) {
    fbb_.AddOffset(CylSurfaceData::VT_AXIS, Axis);
  }
  void add_Origin(flatbuffers::Offset<flatbuffers::Vector<double>> Origin) {
    fbb_.AddOffset(CylSurfaceData::VT_ORIGIN, Origin);
  }
  void add_Radius(double Radius) {
    fbb_.AddElement<double>(CylSurfaceData::VT_RADIUS, Radius, 0.0);
  }
  void add_StartAngle(double StartAngle) {
    fbb_.AddElement<double>(CylSurfaceData::VT_STARTANGLE, StartAngle, 0.0);
  }
  void add_EndAngle(double EndAngle) {
    fbb_.AddElement<double>(CylSurfaceData::VT_ENDANGLE, EndAngle, 0.0);
  }
  explicit CylSurfaceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CylSurfaceDataBuilder &operator=(const CylSurfaceDataBuilder &);
  flatbuffers::Offset<CylSurfaceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CylSurfaceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CylSurfaceData> CreateCylSurfaceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Origin = 0,
    double Radius = 0.0,
    double StartAngle = 0.0,
    double EndAngle = 0.0) {
  CylSurfaceDataBuilder builder_(_fbb);
  builder_.add_EndAngle(EndAngle);
  builder_.add_StartAngle(StartAngle);
  builder_.add_Radius(Radius);
  builder_.add_Origin(Origin);
  builder_.add_Axis(Axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<CylSurfaceData> CreateCylSurfaceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Axis = nullptr,
    const std::vector<double> *Origin = nullptr,
    double Radius = 0.0,
    double StartAngle = 0.0,
    double EndAngle = 0.0) {
  auto Axis__ = Axis ? _fbb.CreateVector<double>(*Axis) : 0;
  auto Origin__ = Origin ? _fbb.CreateVector<double>(*Origin) : 0;
  return FlatBufferDocSpace::CreateCylSurfaceData(
      _fbb,
      Axis__,
      Origin__,
      Radius,
      StartAngle,
      EndAngle);
}

struct RevSrfAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RevSrfAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ORIGIN = 6,
    VT_STARTANGLE = 8,
    VT_ENDANGLE = 10
  };
  const flatbuffers::Vector<double> *Axis() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_AXIS);
  }
  const flatbuffers::Vector<double> *Origin() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ORIGIN);
  }
  double StartAngle() const {
    return GetField<double>(VT_STARTANGLE, 0.0);
  }
  double EndAngle() const {
    return GetField<double>(VT_ENDANGLE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(Axis()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyVector(Origin()) &&
           VerifyField<double>(verifier, VT_STARTANGLE) &&
           VerifyField<double>(verifier, VT_ENDANGLE) &&
           verifier.EndTable();
  }
};

struct RevSrfAttributeBuilder {
  typedef RevSrfAttribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Axis(flatbuffers::Offset<flatbuffers::Vector<double>> Axis) {
    fbb_.AddOffset(RevSrfAttribute::VT_AXIS, Axis);
  }
  void add_Origin(flatbuffers::Offset<flatbuffers::Vector<double>> Origin) {
    fbb_.AddOffset(RevSrfAttribute::VT_ORIGIN, Origin);
  }
  void add_StartAngle(double StartAngle) {
    fbb_.AddElement<double>(RevSrfAttribute::VT_STARTANGLE, StartAngle, 0.0);
  }
  void add_EndAngle(double EndAngle) {
    fbb_.AddElement<double>(RevSrfAttribute::VT_ENDANGLE, EndAngle, 0.0);
  }
  explicit RevSrfAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RevSrfAttributeBuilder &operator=(const RevSrfAttributeBuilder &);
  flatbuffers::Offset<RevSrfAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RevSrfAttribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<RevSrfAttribute> CreateRevSrfAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Origin = 0,
    double StartAngle = 0.0,
    double EndAngle = 0.0) {
  RevSrfAttributeBuilder builder_(_fbb);
  builder_.add_EndAngle(EndAngle);
  builder_.add_StartAngle(StartAngle);
  builder_.add_Origin(Origin);
  builder_.add_Axis(Axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<RevSrfAttribute> CreateRevSrfAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Axis = nullptr,
    const std::vector<double> *Origin = nullptr,
    double StartAngle = 0.0,
    double EndAngle = 0.0) {
  auto Axis__ = Axis ? _fbb.CreateVector<double>(*Axis) : 0;
  auto Origin__ = Origin ? _fbb.CreateVector<double>(*Origin) : 0;
  return FlatBufferDocSpace::CreateRevSrfAttribute(
      _fbb,
      Axis__,
      Origin__,
      StartAngle,
      EndAngle);
}

struct TabCylSrfAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TabCylSrfAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<double> *Axis() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(Axis()) &&
           verifier.EndTable();
  }
};

struct TabCylSrfAttributeBuilder {
  typedef TabCylSrfAttribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Axis(flatbuffers::Offset<flatbuffers::Vector<double>> Axis) {
    fbb_.AddOffset(TabCylSrfAttribute::VT_AXIS, Axis);
  }
  explicit TabCylSrfAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TabCylSrfAttributeBuilder &operator=(const TabCylSrfAttributeBuilder &);
  flatbuffers::Offset<TabCylSrfAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TabCylSrfAttribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<TabCylSrfAttribute> CreateTabCylSrfAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Axis = 0) {
  TabCylSrfAttributeBuilder builder_(_fbb);
  builder_.add_Axis(Axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<TabCylSrfAttribute> CreateTabCylSrfAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Axis = nullptr) {
  auto Axis__ = Axis ? _fbb.CreateVector<double>(*Axis) : 0;
  return FlatBufferDocSpace::CreateTabCylSrfAttribute(
      _fbb,
      Axis__);
}

struct BaseCurveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseCurveDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CPS = 4,
    VT_W = 6,
    VT_K = 8,
    VT_B0 = 10,
    VT_B1 = 12,
    VT_D = 14,
    VT_P = 16,
    VT_MAJORRAD = 18,
    VT_MINORRAD = 20,
    VT_CP = 22,
    VT_MAJORVEC = 24,
    VT_MINORVEC = 26,
    VT_SA = 28,
    VT_EA = 30
  };
  const flatbuffers::Vector<double> *CPS() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CPS);
  }
  const flatbuffers::Vector<double> *W() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_W);
  }
  const flatbuffers::Vector<double> *K() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_K);
  }
  double B0() const {
    return GetField<double>(VT_B0, 0.0);
  }
  double B1() const {
    return GetField<double>(VT_B1, 0.0);
  }
  int32_t D() const {
    return GetField<int32_t>(VT_D, 0);
  }
  bool P() const {
    return GetField<uint8_t>(VT_P, 0) != 0;
  }
  double MajorRad() const {
    return GetField<double>(VT_MAJORRAD, 0.0);
  }
  double MinorRad() const {
    return GetField<double>(VT_MINORRAD, 0.0);
  }
  const flatbuffers::Vector<double> *CP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CP);
  }
  const flatbuffers::Vector<double> *MajorVec() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAJORVEC);
  }
  const flatbuffers::Vector<double> *MinorVec() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MINORVEC);
  }
  double SA() const {
    return GetField<double>(VT_SA, 0.0);
  }
  double EA() const {
    return GetField<double>(VT_EA, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CPS) &&
           verifier.VerifyVector(CPS()) &&
           VerifyOffset(verifier, VT_W) &&
           verifier.VerifyVector(W()) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.VerifyVector(K()) &&
           VerifyField<double>(verifier, VT_B0) &&
           VerifyField<double>(verifier, VT_B1) &&
           VerifyField<int32_t>(verifier, VT_D) &&
           VerifyField<uint8_t>(verifier, VT_P) &&
           VerifyField<double>(verifier, VT_MAJORRAD) &&
           VerifyField<double>(verifier, VT_MINORRAD) &&
           VerifyOffset(verifier, VT_CP) &&
           verifier.VerifyVector(CP()) &&
           VerifyOffset(verifier, VT_MAJORVEC) &&
           verifier.VerifyVector(MajorVec()) &&
           VerifyOffset(verifier, VT_MINORVEC) &&
           verifier.VerifyVector(MinorVec()) &&
           VerifyField<double>(verifier, VT_SA) &&
           VerifyField<double>(verifier, VT_EA) &&
           verifier.EndTable();
  }
};

struct BaseCurveDataBuilder {
  typedef BaseCurveData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CPS(flatbuffers::Offset<flatbuffers::Vector<double>> CPS) {
    fbb_.AddOffset(BaseCurveData::VT_CPS, CPS);
  }
  void add_W(flatbuffers::Offset<flatbuffers::Vector<double>> W) {
    fbb_.AddOffset(BaseCurveData::VT_W, W);
  }
  void add_K(flatbuffers::Offset<flatbuffers::Vector<double>> K) {
    fbb_.AddOffset(BaseCurveData::VT_K, K);
  }
  void add_B0(double B0) {
    fbb_.AddElement<double>(BaseCurveData::VT_B0, B0, 0.0);
  }
  void add_B1(double B1) {
    fbb_.AddElement<double>(BaseCurveData::VT_B1, B1, 0.0);
  }
  void add_D(int32_t D) {
    fbb_.AddElement<int32_t>(BaseCurveData::VT_D, D, 0);
  }
  void add_P(bool P) {
    fbb_.AddElement<uint8_t>(BaseCurveData::VT_P, static_cast<uint8_t>(P), 0);
  }
  void add_MajorRad(double MajorRad) {
    fbb_.AddElement<double>(BaseCurveData::VT_MAJORRAD, MajorRad, 0.0);
  }
  void add_MinorRad(double MinorRad) {
    fbb_.AddElement<double>(BaseCurveData::VT_MINORRAD, MinorRad, 0.0);
  }
  void add_CP(flatbuffers::Offset<flatbuffers::Vector<double>> CP) {
    fbb_.AddOffset(BaseCurveData::VT_CP, CP);
  }
  void add_MajorVec(flatbuffers::Offset<flatbuffers::Vector<double>> MajorVec) {
    fbb_.AddOffset(BaseCurveData::VT_MAJORVEC, MajorVec);
  }
  void add_MinorVec(flatbuffers::Offset<flatbuffers::Vector<double>> MinorVec) {
    fbb_.AddOffset(BaseCurveData::VT_MINORVEC, MinorVec);
  }
  void add_SA(double SA) {
    fbb_.AddElement<double>(BaseCurveData::VT_SA, SA, 0.0);
  }
  void add_EA(double EA) {
    fbb_.AddElement<double>(BaseCurveData::VT_EA, EA, 0.0);
  }
  explicit BaseCurveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaseCurveDataBuilder &operator=(const BaseCurveDataBuilder &);
  flatbuffers::Offset<BaseCurveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaseCurveData>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaseCurveData> CreateBaseCurveData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> CPS = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> W = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> K = 0,
    double B0 = 0.0,
    double B1 = 0.0,
    int32_t D = 0,
    bool P = false,
    double MajorRad = 0.0,
    double MinorRad = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CP = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MajorVec = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MinorVec = 0,
    double SA = 0.0,
    double EA = 0.0) {
  BaseCurveDataBuilder builder_(_fbb);
  builder_.add_EA(EA);
  builder_.add_SA(SA);
  builder_.add_MinorRad(MinorRad);
  builder_.add_MajorRad(MajorRad);
  builder_.add_B1(B1);
  builder_.add_B0(B0);
  builder_.add_MinorVec(MinorVec);
  builder_.add_MajorVec(MajorVec);
  builder_.add_CP(CP);
  builder_.add_D(D);
  builder_.add_K(K);
  builder_.add_W(W);
  builder_.add_CPS(CPS);
  builder_.add_P(P);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaseCurveData> CreateBaseCurveDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *CPS = nullptr,
    const std::vector<double> *W = nullptr,
    const std::vector<double> *K = nullptr,
    double B0 = 0.0,
    double B1 = 0.0,
    int32_t D = 0,
    bool P = false,
    double MajorRad = 0.0,
    double MinorRad = 0.0,
    const std::vector<double> *CP = nullptr,
    const std::vector<double> *MajorVec = nullptr,
    const std::vector<double> *MinorVec = nullptr,
    double SA = 0.0,
    double EA = 0.0) {
  auto CPS__ = CPS ? _fbb.CreateVector<double>(*CPS) : 0;
  auto W__ = W ? _fbb.CreateVector<double>(*W) : 0;
  auto K__ = K ? _fbb.CreateVector<double>(*K) : 0;
  auto CP__ = CP ? _fbb.CreateVector<double>(*CP) : 0;
  auto MajorVec__ = MajorVec ? _fbb.CreateVector<double>(*MajorVec) : 0;
  auto MinorVec__ = MinorVec ? _fbb.CreateVector<double>(*MinorVec) : 0;
  return FlatBufferDocSpace::CreateBaseCurveData(
      _fbb,
      CPS__,
      W__,
      K__,
      B0,
      B1,
      D,
      P,
      MajorRad,
      MinorRad,
      CP__,
      MajorVec__,
      MinorVec__,
      SA,
      EA);
}

struct NurbsHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NurbsHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SL = 4,
    VT_EL = 6,
    VT_ST = 8,
    VT_ET = 10
  };
  double SL() const {
    return GetField<double>(VT_SL, 0.0);
  }
  double EL() const {
    return GetField<double>(VT_EL, 0.0);
  }
  const flatbuffers::Vector<double> *ST() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ST);
  }
  const flatbuffers::Vector<double> *ET() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SL) &&
           VerifyField<double>(verifier, VT_EL) &&
           VerifyOffset(verifier, VT_ST) &&
           verifier.VerifyVector(ST()) &&
           VerifyOffset(verifier, VT_ET) &&
           verifier.VerifyVector(ET()) &&
           verifier.EndTable();
  }
};

struct NurbsHandleDataBuilder {
  typedef NurbsHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SL(double SL) {
    fbb_.AddElement<double>(NurbsHandleData::VT_SL, SL, 0.0);
  }
  void add_EL(double EL) {
    fbb_.AddElement<double>(NurbsHandleData::VT_EL, EL, 0.0);
  }
  void add_ST(flatbuffers::Offset<flatbuffers::Vector<double>> ST) {
    fbb_.AddOffset(NurbsHandleData::VT_ST, ST);
  }
  void add_ET(flatbuffers::Offset<flatbuffers::Vector<double>> ET) {
    fbb_.AddOffset(NurbsHandleData::VT_ET, ET);
  }
  explicit NurbsHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NurbsHandleDataBuilder &operator=(const NurbsHandleDataBuilder &);
  flatbuffers::Offset<NurbsHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NurbsHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<NurbsHandleData> CreateNurbsHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double SL = 0.0,
    double EL = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ST = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ET = 0) {
  NurbsHandleDataBuilder builder_(_fbb);
  builder_.add_EL(EL);
  builder_.add_SL(SL);
  builder_.add_ET(ET);
  builder_.add_ST(ST);
  return builder_.Finish();
}

inline flatbuffers::Offset<NurbsHandleData> CreateNurbsHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double SL = 0.0,
    double EL = 0.0,
    const std::vector<double> *ST = nullptr,
    const std::vector<double> *ET = nullptr) {
  auto ST__ = ST ? _fbb.CreateVector<double>(*ST) : 0;
  auto ET__ = ET ? _fbb.CreateVector<double>(*ET) : 0;
  return FlatBufferDocSpace::CreateNurbsHandleData(
      _fbb,
      SL,
      EL,
      ST__,
      ET__);
}

struct AttributeLineData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeLineDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4
  };
  double A() const {
    return GetField<double>(VT_A, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_A) &&
           verifier.EndTable();
  }
};

struct AttributeLineDataBuilder {
  typedef AttributeLineData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_A(double A) {
    fbb_.AddElement<double>(AttributeLineData::VT_A, A, 0.0);
  }
  explicit AttributeLineDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeLineDataBuilder &operator=(const AttributeLineDataBuilder &);
  flatbuffers::Offset<AttributeLineData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeLineData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeLineData> CreateAttributeLineData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double A = 0.0) {
  AttributeLineDataBuilder builder_(_fbb);
  builder_.add_A(A);
  return builder_.Finish();
}

struct AttributeArcData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeArcDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SA = 4,
    VT_EA = 6,
    VT_R = 8,
    VT_CP = 10
  };
  double SA() const {
    return GetField<double>(VT_SA, 0.0);
  }
  double EA() const {
    return GetField<double>(VT_EA, 0.0);
  }
  double R() const {
    return GetField<double>(VT_R, 0.0);
  }
  const flatbuffers::Vector<double> *CP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SA) &&
           VerifyField<double>(verifier, VT_EA) &&
           VerifyField<double>(verifier, VT_R) &&
           VerifyOffset(verifier, VT_CP) &&
           verifier.VerifyVector(CP()) &&
           verifier.EndTable();
  }
};

struct AttributeArcDataBuilder {
  typedef AttributeArcData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SA(double SA) {
    fbb_.AddElement<double>(AttributeArcData::VT_SA, SA, 0.0);
  }
  void add_EA(double EA) {
    fbb_.AddElement<double>(AttributeArcData::VT_EA, EA, 0.0);
  }
  void add_R(double R) {
    fbb_.AddElement<double>(AttributeArcData::VT_R, R, 0.0);
  }
  void add_CP(flatbuffers::Offset<flatbuffers::Vector<double>> CP) {
    fbb_.AddOffset(AttributeArcData::VT_CP, CP);
  }
  explicit AttributeArcDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeArcDataBuilder &operator=(const AttributeArcDataBuilder &);
  flatbuffers::Offset<AttributeArcData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeArcData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeArcData> CreateAttributeArcData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double SA = 0.0,
    double EA = 0.0,
    double R = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CP = 0) {
  AttributeArcDataBuilder builder_(_fbb);
  builder_.add_R(R);
  builder_.add_EA(EA);
  builder_.add_SA(SA);
  builder_.add_CP(CP);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeArcData> CreateAttributeArcDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double SA = 0.0,
    double EA = 0.0,
    double R = 0.0,
    const std::vector<double> *CP = nullptr) {
  auto CP__ = CP ? _fbb.CreateVector<double>(*CP) : 0;
  return FlatBufferDocSpace::CreateAttributeArcData(
      _fbb,
      SA,
      EA,
      R,
      CP__);
}

struct AttributeEllipseData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeEllipseDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SA = 4,
    VT_EA = 6,
    VT_MINORRAD = 8,
    VT_MAJORRAD = 10,
    VT_CP = 12,
    VT_SPLITPNTS = 14,
    VT_MINORVEC = 16,
    VT_MAJORVEC = 18
  };
  double SA() const {
    return GetField<double>(VT_SA, 0.0);
  }
  double EA() const {
    return GetField<double>(VT_EA, 0.0);
  }
  double MinorRad() const {
    return GetField<double>(VT_MINORRAD, 0.0);
  }
  double MajorRad() const {
    return GetField<double>(VT_MAJORRAD, 0.0);
  }
  const flatbuffers::Vector<double> *CP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CP);
  }
  const flatbuffers::Vector<double> *SplitPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_SPLITPNTS);
  }
  const flatbuffers::Vector<double> *MinorVec() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MINORVEC);
  }
  const flatbuffers::Vector<double> *MajorVec() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAJORVEC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SA) &&
           VerifyField<double>(verifier, VT_EA) &&
           VerifyField<double>(verifier, VT_MINORRAD) &&
           VerifyField<double>(verifier, VT_MAJORRAD) &&
           VerifyOffset(verifier, VT_CP) &&
           verifier.VerifyVector(CP()) &&
           VerifyOffset(verifier, VT_SPLITPNTS) &&
           verifier.VerifyVector(SplitPnts()) &&
           VerifyOffset(verifier, VT_MINORVEC) &&
           verifier.VerifyVector(MinorVec()) &&
           VerifyOffset(verifier, VT_MAJORVEC) &&
           verifier.VerifyVector(MajorVec()) &&
           verifier.EndTable();
  }
};

struct AttributeEllipseDataBuilder {
  typedef AttributeEllipseData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SA(double SA) {
    fbb_.AddElement<double>(AttributeEllipseData::VT_SA, SA, 0.0);
  }
  void add_EA(double EA) {
    fbb_.AddElement<double>(AttributeEllipseData::VT_EA, EA, 0.0);
  }
  void add_MinorRad(double MinorRad) {
    fbb_.AddElement<double>(AttributeEllipseData::VT_MINORRAD, MinorRad, 0.0);
  }
  void add_MajorRad(double MajorRad) {
    fbb_.AddElement<double>(AttributeEllipseData::VT_MAJORRAD, MajorRad, 0.0);
  }
  void add_CP(flatbuffers::Offset<flatbuffers::Vector<double>> CP) {
    fbb_.AddOffset(AttributeEllipseData::VT_CP, CP);
  }
  void add_SplitPnts(flatbuffers::Offset<flatbuffers::Vector<double>> SplitPnts) {
    fbb_.AddOffset(AttributeEllipseData::VT_SPLITPNTS, SplitPnts);
  }
  void add_MinorVec(flatbuffers::Offset<flatbuffers::Vector<double>> MinorVec) {
    fbb_.AddOffset(AttributeEllipseData::VT_MINORVEC, MinorVec);
  }
  void add_MajorVec(flatbuffers::Offset<flatbuffers::Vector<double>> MajorVec) {
    fbb_.AddOffset(AttributeEllipseData::VT_MAJORVEC, MajorVec);
  }
  explicit AttributeEllipseDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeEllipseDataBuilder &operator=(const AttributeEllipseDataBuilder &);
  flatbuffers::Offset<AttributeEllipseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeEllipseData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeEllipseData> CreateAttributeEllipseData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double SA = 0.0,
    double EA = 0.0,
    double MinorRad = 0.0,
    double MajorRad = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CP = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> SplitPnts = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MinorVec = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MajorVec = 0) {
  AttributeEllipseDataBuilder builder_(_fbb);
  builder_.add_MajorRad(MajorRad);
  builder_.add_MinorRad(MinorRad);
  builder_.add_EA(EA);
  builder_.add_SA(SA);
  builder_.add_MajorVec(MajorVec);
  builder_.add_MinorVec(MinorVec);
  builder_.add_SplitPnts(SplitPnts);
  builder_.add_CP(CP);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeEllipseData> CreateAttributeEllipseDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double SA = 0.0,
    double EA = 0.0,
    double MinorRad = 0.0,
    double MajorRad = 0.0,
    const std::vector<double> *CP = nullptr,
    const std::vector<double> *SplitPnts = nullptr,
    const std::vector<double> *MinorVec = nullptr,
    const std::vector<double> *MajorVec = nullptr) {
  auto CP__ = CP ? _fbb.CreateVector<double>(*CP) : 0;
  auto SplitPnts__ = SplitPnts ? _fbb.CreateVector<double>(*SplitPnts) : 0;
  auto MinorVec__ = MinorVec ? _fbb.CreateVector<double>(*MinorVec) : 0;
  auto MajorVec__ = MajorVec ? _fbb.CreateVector<double>(*MajorVec) : 0;
  return FlatBufferDocSpace::CreateAttributeEllipseData(
      _fbb,
      SA,
      EA,
      MinorRad,
      MajorRad,
      CP__,
      SplitPnts__,
      MinorVec__,
      MajorVec__);
}

struct AttributeNurbsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeNurbsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HD = 4,
    VT_INTPPNTS = 6,
    VT_ISCLOSED = 8,
    VT_CPS = 10,
    VT_W = 12,
    VT_K = 14,
    VT_B0 = 16,
    VT_B1 = 18,
    VT_D = 20,
    VT_P = 22,
    VT_SCL = 24
  };
  const FlatBufferDocSpace::NurbsHandleData *HD() const {
    return GetPointer<const FlatBufferDocSpace::NurbsHandleData *>(VT_HD);
  }
  const flatbuffers::Vector<double> *IntpPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_INTPPNTS);
  }
  bool IsClosed() const {
    return GetField<uint8_t>(VT_ISCLOSED, 0) != 0;
  }
  const flatbuffers::Vector<double> *CPS() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CPS);
  }
  const flatbuffers::Vector<double> *W() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_W);
  }
  const flatbuffers::Vector<double> *K() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_K);
  }
  double B0() const {
    return GetField<double>(VT_B0, 0.0);
  }
  double B1() const {
    return GetField<double>(VT_B1, 0.0);
  }
  int32_t D() const {
    return GetField<int32_t>(VT_D, 0);
  }
  bool P() const {
    return GetField<uint8_t>(VT_P, 0) != 0;
  }
  bool SCL() const {
    return GetField<uint8_t>(VT_SCL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HD) &&
           verifier.VerifyTable(HD()) &&
           VerifyOffset(verifier, VT_INTPPNTS) &&
           verifier.VerifyVector(IntpPnts()) &&
           VerifyField<uint8_t>(verifier, VT_ISCLOSED) &&
           VerifyOffset(verifier, VT_CPS) &&
           verifier.VerifyVector(CPS()) &&
           VerifyOffset(verifier, VT_W) &&
           verifier.VerifyVector(W()) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.VerifyVector(K()) &&
           VerifyField<double>(verifier, VT_B0) &&
           VerifyField<double>(verifier, VT_B1) &&
           VerifyField<int32_t>(verifier, VT_D) &&
           VerifyField<uint8_t>(verifier, VT_P) &&
           VerifyField<uint8_t>(verifier, VT_SCL) &&
           verifier.EndTable();
  }
};

struct AttributeNurbsDataBuilder {
  typedef AttributeNurbsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HD(flatbuffers::Offset<FlatBufferDocSpace::NurbsHandleData> HD) {
    fbb_.AddOffset(AttributeNurbsData::VT_HD, HD);
  }
  void add_IntpPnts(flatbuffers::Offset<flatbuffers::Vector<double>> IntpPnts) {
    fbb_.AddOffset(AttributeNurbsData::VT_INTPPNTS, IntpPnts);
  }
  void add_IsClosed(bool IsClosed) {
    fbb_.AddElement<uint8_t>(AttributeNurbsData::VT_ISCLOSED, static_cast<uint8_t>(IsClosed), 0);
  }
  void add_CPS(flatbuffers::Offset<flatbuffers::Vector<double>> CPS) {
    fbb_.AddOffset(AttributeNurbsData::VT_CPS, CPS);
  }
  void add_W(flatbuffers::Offset<flatbuffers::Vector<double>> W) {
    fbb_.AddOffset(AttributeNurbsData::VT_W, W);
  }
  void add_K(flatbuffers::Offset<flatbuffers::Vector<double>> K) {
    fbb_.AddOffset(AttributeNurbsData::VT_K, K);
  }
  void add_B0(double B0) {
    fbb_.AddElement<double>(AttributeNurbsData::VT_B0, B0, 0.0);
  }
  void add_B1(double B1) {
    fbb_.AddElement<double>(AttributeNurbsData::VT_B1, B1, 0.0);
  }
  void add_D(int32_t D) {
    fbb_.AddElement<int32_t>(AttributeNurbsData::VT_D, D, 0);
  }
  void add_P(bool P) {
    fbb_.AddElement<uint8_t>(AttributeNurbsData::VT_P, static_cast<uint8_t>(P), 0);
  }
  void add_SCL(bool SCL) {
    fbb_.AddElement<uint8_t>(AttributeNurbsData::VT_SCL, static_cast<uint8_t>(SCL), 0);
  }
  explicit AttributeNurbsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeNurbsDataBuilder &operator=(const AttributeNurbsDataBuilder &);
  flatbuffers::Offset<AttributeNurbsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeNurbsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeNurbsData> CreateAttributeNurbsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::NurbsHandleData> HD = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> IntpPnts = 0,
    bool IsClosed = false,
    flatbuffers::Offset<flatbuffers::Vector<double>> CPS = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> W = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> K = 0,
    double B0 = 0.0,
    double B1 = 0.0,
    int32_t D = 0,
    bool P = false,
    bool SCL = false) {
  AttributeNurbsDataBuilder builder_(_fbb);
  builder_.add_B1(B1);
  builder_.add_B0(B0);
  builder_.add_D(D);
  builder_.add_K(K);
  builder_.add_W(W);
  builder_.add_CPS(CPS);
  builder_.add_IntpPnts(IntpPnts);
  builder_.add_HD(HD);
  builder_.add_SCL(SCL);
  builder_.add_P(P);
  builder_.add_IsClosed(IsClosed);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeNurbsData> CreateAttributeNurbsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::NurbsHandleData> HD = 0,
    const std::vector<double> *IntpPnts = nullptr,
    bool IsClosed = false,
    const std::vector<double> *CPS = nullptr,
    const std::vector<double> *W = nullptr,
    const std::vector<double> *K = nullptr,
    double B0 = 0.0,
    double B1 = 0.0,
    int32_t D = 0,
    bool P = false,
    bool SCL = false) {
  auto IntpPnts__ = IntpPnts ? _fbb.CreateVector<double>(*IntpPnts) : 0;
  auto CPS__ = CPS ? _fbb.CreateVector<double>(*CPS) : 0;
  auto W__ = W ? _fbb.CreateVector<double>(*W) : 0;
  auto K__ = K ? _fbb.CreateVector<double>(*K) : 0;
  return FlatBufferDocSpace::CreateAttributeNurbsData(
      _fbb,
      HD,
      IntpPnts__,
      IsClosed,
      CPS__,
      W__,
      K__,
      B0,
      B1,
      D,
      P,
      SCL);
}

struct AttributeCrvOnSrfData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeCrvOnSrfDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFSRFID = 4
  };
  int32_t RefSrfId() const {
    return GetField<int32_t>(VT_REFSRFID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REFSRFID) &&
           verifier.EndTable();
  }
};

struct AttributeCrvOnSrfDataBuilder {
  typedef AttributeCrvOnSrfData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RefSrfId(int32_t RefSrfId) {
    fbb_.AddElement<int32_t>(AttributeCrvOnSrfData::VT_REFSRFID, RefSrfId, 0);
  }
  explicit AttributeCrvOnSrfDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeCrvOnSrfDataBuilder &operator=(const AttributeCrvOnSrfDataBuilder &);
  flatbuffers::Offset<AttributeCrvOnSrfData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeCrvOnSrfData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeCrvOnSrfData> CreateAttributeCrvOnSrfData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t RefSrfId = 0) {
  AttributeCrvOnSrfDataBuilder builder_(_fbb);
  builder_.add_RefSrfId(RefSrfId);
  return builder_.Finish();
}

struct AttributeOffsetData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeOffsetDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSETDIS = 4,
    VT_SWAP = 6,
    VT_B0 = 8,
    VT_B1 = 10,
    VT_NORMALDIR = 12,
    VT_BASECURVETYPE = 14,
    VT_BASECURVE = 16,
    VT_ISCLOSED = 18
  };
  double OffsetDis() const {
    return GetField<double>(VT_OFFSETDIS, 0.0);
  }
  int32_t Swap() const {
    return GetField<int32_t>(VT_SWAP, 0);
  }
  double B0() const {
    return GetField<double>(VT_B0, 0.0);
  }
  double B1() const {
    return GetField<double>(VT_B1, 0.0);
  }
  const flatbuffers::Vector<double> *NormalDir() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_NORMALDIR);
  }
  int32_t BaseCurveType() const {
    return GetField<int32_t>(VT_BASECURVETYPE, 0);
  }
  const FlatBufferDocSpace::BaseCurveData *BaseCurve() const {
    return GetPointer<const FlatBufferDocSpace::BaseCurveData *>(VT_BASECURVE);
  }
  bool IsClosed() const {
    return GetField<uint8_t>(VT_ISCLOSED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_OFFSETDIS) &&
           VerifyField<int32_t>(verifier, VT_SWAP) &&
           VerifyField<double>(verifier, VT_B0) &&
           VerifyField<double>(verifier, VT_B1) &&
           VerifyOffset(verifier, VT_NORMALDIR) &&
           verifier.VerifyVector(NormalDir()) &&
           VerifyField<int32_t>(verifier, VT_BASECURVETYPE) &&
           VerifyOffset(verifier, VT_BASECURVE) &&
           verifier.VerifyTable(BaseCurve()) &&
           VerifyField<uint8_t>(verifier, VT_ISCLOSED) &&
           verifier.EndTable();
  }
};

struct AttributeOffsetDataBuilder {
  typedef AttributeOffsetData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_OffsetDis(double OffsetDis) {
    fbb_.AddElement<double>(AttributeOffsetData::VT_OFFSETDIS, OffsetDis, 0.0);
  }
  void add_Swap(int32_t Swap) {
    fbb_.AddElement<int32_t>(AttributeOffsetData::VT_SWAP, Swap, 0);
  }
  void add_B0(double B0) {
    fbb_.AddElement<double>(AttributeOffsetData::VT_B0, B0, 0.0);
  }
  void add_B1(double B1) {
    fbb_.AddElement<double>(AttributeOffsetData::VT_B1, B1, 0.0);
  }
  void add_NormalDir(flatbuffers::Offset<flatbuffers::Vector<double>> NormalDir) {
    fbb_.AddOffset(AttributeOffsetData::VT_NORMALDIR, NormalDir);
  }
  void add_BaseCurveType(int32_t BaseCurveType) {
    fbb_.AddElement<int32_t>(AttributeOffsetData::VT_BASECURVETYPE, BaseCurveType, 0);
  }
  void add_BaseCurve(flatbuffers::Offset<FlatBufferDocSpace::BaseCurveData> BaseCurve) {
    fbb_.AddOffset(AttributeOffsetData::VT_BASECURVE, BaseCurve);
  }
  void add_IsClosed(bool IsClosed) {
    fbb_.AddElement<uint8_t>(AttributeOffsetData::VT_ISCLOSED, static_cast<uint8_t>(IsClosed), 0);
  }
  explicit AttributeOffsetDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeOffsetDataBuilder &operator=(const AttributeOffsetDataBuilder &);
  flatbuffers::Offset<AttributeOffsetData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeOffsetData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeOffsetData> CreateAttributeOffsetData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double OffsetDis = 0.0,
    int32_t Swap = 0,
    double B0 = 0.0,
    double B1 = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> NormalDir = 0,
    int32_t BaseCurveType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::BaseCurveData> BaseCurve = 0,
    bool IsClosed = false) {
  AttributeOffsetDataBuilder builder_(_fbb);
  builder_.add_B1(B1);
  builder_.add_B0(B0);
  builder_.add_OffsetDis(OffsetDis);
  builder_.add_BaseCurve(BaseCurve);
  builder_.add_BaseCurveType(BaseCurveType);
  builder_.add_NormalDir(NormalDir);
  builder_.add_Swap(Swap);
  builder_.add_IsClosed(IsClosed);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeOffsetData> CreateAttributeOffsetDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double OffsetDis = 0.0,
    int32_t Swap = 0,
    double B0 = 0.0,
    double B1 = 0.0,
    const std::vector<double> *NormalDir = nullptr,
    int32_t BaseCurveType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::BaseCurveData> BaseCurve = 0,
    bool IsClosed = false) {
  auto NormalDir__ = NormalDir ? _fbb.CreateVector<double>(*NormalDir) : 0;
  return FlatBufferDocSpace::CreateAttributeOffsetData(
      _fbb,
      OffsetDis,
      Swap,
      B0,
      B1,
      NormalDir__,
      BaseCurveType,
      BaseCurve,
      IsClosed);
}

struct AttributeEquationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeEquationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ISCLOSED = 4,
    VT_TYPE = 6,
    VT_ET1 = 8,
    VT_ET2 = 10,
    VT_SV = 12,
    VT_EV = 14,
    VT_COOTYPE = 16,
    VT_SISD = 18,
    VT_EISD = 20
  };
  bool IsClosed() const {
    return GetField<uint8_t>(VT_ISCLOSED, 0) != 0;
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *ET1() const {
    return GetPointer<const flatbuffers::String *>(VT_ET1);
  }
  const flatbuffers::String *ET2() const {
    return GetPointer<const flatbuffers::String *>(VT_ET2);
  }
  double SV() const {
    return GetField<double>(VT_SV, 0.0);
  }
  double EV() const {
    return GetField<double>(VT_EV, 0.0);
  }
  int32_t CooType() const {
    return GetField<int32_t>(VT_COOTYPE, 0);
  }
  int32_t SIsD() const {
    return GetField<int32_t>(VT_SISD, 0);
  }
  int32_t EIsD() const {
    return GetField<int32_t>(VT_EISD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ISCLOSED) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ET1) &&
           verifier.VerifyString(ET1()) &&
           VerifyOffset(verifier, VT_ET2) &&
           verifier.VerifyString(ET2()) &&
           VerifyField<double>(verifier, VT_SV) &&
           VerifyField<double>(verifier, VT_EV) &&
           VerifyField<int32_t>(verifier, VT_COOTYPE) &&
           VerifyField<int32_t>(verifier, VT_SISD) &&
           VerifyField<int32_t>(verifier, VT_EISD) &&
           verifier.EndTable();
  }
};

struct AttributeEquationDataBuilder {
  typedef AttributeEquationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_IsClosed(bool IsClosed) {
    fbb_.AddElement<uint8_t>(AttributeEquationData::VT_ISCLOSED, static_cast<uint8_t>(IsClosed), 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(AttributeEquationData::VT_TYPE, Type, 0);
  }
  void add_ET1(flatbuffers::Offset<flatbuffers::String> ET1) {
    fbb_.AddOffset(AttributeEquationData::VT_ET1, ET1);
  }
  void add_ET2(flatbuffers::Offset<flatbuffers::String> ET2) {
    fbb_.AddOffset(AttributeEquationData::VT_ET2, ET2);
  }
  void add_SV(double SV) {
    fbb_.AddElement<double>(AttributeEquationData::VT_SV, SV, 0.0);
  }
  void add_EV(double EV) {
    fbb_.AddElement<double>(AttributeEquationData::VT_EV, EV, 0.0);
  }
  void add_CooType(int32_t CooType) {
    fbb_.AddElement<int32_t>(AttributeEquationData::VT_COOTYPE, CooType, 0);
  }
  void add_SIsD(int32_t SIsD) {
    fbb_.AddElement<int32_t>(AttributeEquationData::VT_SISD, SIsD, 0);
  }
  void add_EIsD(int32_t EIsD) {
    fbb_.AddElement<int32_t>(AttributeEquationData::VT_EISD, EIsD, 0);
  }
  explicit AttributeEquationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeEquationDataBuilder &operator=(const AttributeEquationDataBuilder &);
  flatbuffers::Offset<AttributeEquationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeEquationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeEquationData> CreateAttributeEquationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool IsClosed = false,
    int32_t Type = 0,
    flatbuffers::Offset<flatbuffers::String> ET1 = 0,
    flatbuffers::Offset<flatbuffers::String> ET2 = 0,
    double SV = 0.0,
    double EV = 0.0,
    int32_t CooType = 0,
    int32_t SIsD = 0,
    int32_t EIsD = 0) {
  AttributeEquationDataBuilder builder_(_fbb);
  builder_.add_EV(EV);
  builder_.add_SV(SV);
  builder_.add_EIsD(EIsD);
  builder_.add_SIsD(SIsD);
  builder_.add_CooType(CooType);
  builder_.add_ET2(ET2);
  builder_.add_ET1(ET1);
  builder_.add_Type(Type);
  builder_.add_IsClosed(IsClosed);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeEquationData> CreateAttributeEquationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool IsClosed = false,
    int32_t Type = 0,
    const char *ET1 = nullptr,
    const char *ET2 = nullptr,
    double SV = 0.0,
    double EV = 0.0,
    int32_t CooType = 0,
    int32_t SIsD = 0,
    int32_t EIsD = 0) {
  auto ET1__ = ET1 ? _fbb.CreateString(ET1) : 0;
  auto ET2__ = ET2 ? _fbb.CreateString(ET2) : 0;
  return FlatBufferDocSpace::CreateAttributeEquationData(
      _fbb,
      IsClosed,
      Type,
      ET1__,
      ET2__,
      SV,
      EV,
      CooType,
      SIsD,
      EIsD);
}

struct AttributeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4,
    VT_GEOM = 6,
    VT_CURVE_TYPE = 8,
    VT_CURVE = 10,
    VT_SURFACE_TYPE = 12,
    VT_SURFACE = 14,
    VT_GEOMETRY = 16,
    VT_COLOR = 18,
    VT_OPACITY = 20,
    VT_V = 22,
    VT_A = 24,
    VT_BOX = 26,
    VT_INDEX = 28,
    VT_POINT = 30,
    VT_MATERIAL = 32,
    VT_MATERIALINDEX = 34,
    VT_AI = 36,
    VT_ISCOSTHD = 38,
    VT_TI = 40
  };
  const FlatBufferDocSpace::MessageData *Message() const {
    return GetPointer<const FlatBufferDocSpace::MessageData *>(VT_MESSAGE);
  }
  const FlatBufferDocSpace::GeomData *Geom() const {
    return GetPointer<const FlatBufferDocSpace::GeomData *>(VT_GEOM);
  }
  FlatBufferDocSpace::AttributeCurveData Curve_type() const {
    return static_cast<FlatBufferDocSpace::AttributeCurveData>(GetField<uint8_t>(VT_CURVE_TYPE, 0));
  }
  const void *Curve() const {
    return GetPointer<const void *>(VT_CURVE);
  }
  template<typename T> const T *Curve_as() const;
  const FlatBufferDocSpace::AttributeLineData *Curve_as_AttributeLineData() const {
    return Curve_type() == FlatBufferDocSpace::AttributeCurveData_AttributeLineData ? static_cast<const FlatBufferDocSpace::AttributeLineData *>(Curve()) : nullptr;
  }
  const FlatBufferDocSpace::AttributeArcData *Curve_as_AttributeArcData() const {
    return Curve_type() == FlatBufferDocSpace::AttributeCurveData_AttributeArcData ? static_cast<const FlatBufferDocSpace::AttributeArcData *>(Curve()) : nullptr;
  }
  const FlatBufferDocSpace::AttributeEllipseData *Curve_as_AttributeEllipseData() const {
    return Curve_type() == FlatBufferDocSpace::AttributeCurveData_AttributeEllipseData ? static_cast<const FlatBufferDocSpace::AttributeEllipseData *>(Curve()) : nullptr;
  }
  const FlatBufferDocSpace::AttributeNurbsData *Curve_as_AttributeNurbsData() const {
    return Curve_type() == FlatBufferDocSpace::AttributeCurveData_AttributeNurbsData ? static_cast<const FlatBufferDocSpace::AttributeNurbsData *>(Curve()) : nullptr;
  }
  const FlatBufferDocSpace::AttributeCrvOnSrfData *Curve_as_AttributeCrvOnSrfData() const {
    return Curve_type() == FlatBufferDocSpace::AttributeCurveData_AttributeCrvOnSrfData ? static_cast<const FlatBufferDocSpace::AttributeCrvOnSrfData *>(Curve()) : nullptr;
  }
  const FlatBufferDocSpace::AttributeOffsetData *Curve_as_AttributeOffsetData() const {
    return Curve_type() == FlatBufferDocSpace::AttributeCurveData_AttributeOffsetData ? static_cast<const FlatBufferDocSpace::AttributeOffsetData *>(Curve()) : nullptr;
  }
  const FlatBufferDocSpace::AttributeEquationData *Curve_as_AttributeEquationData() const {
    return Curve_type() == FlatBufferDocSpace::AttributeCurveData_AttributeEquationData ? static_cast<const FlatBufferDocSpace::AttributeEquationData *>(Curve()) : nullptr;
  }
  FlatBufferDocSpace::AttributeSurfaceData Surface_type() const {
    return static_cast<FlatBufferDocSpace::AttributeSurfaceData>(GetField<uint8_t>(VT_SURFACE_TYPE, 0));
  }
  const void *Surface() const {
    return GetPointer<const void *>(VT_SURFACE);
  }
  template<typename T> const T *Surface_as() const;
  const FlatBufferDocSpace::PlaneSurfaceData *Surface_as_PlaneSurfaceData() const {
    return Surface_type() == FlatBufferDocSpace::AttributeSurfaceData_PlaneSurfaceData ? static_cast<const FlatBufferDocSpace::PlaneSurfaceData *>(Surface()) : nullptr;
  }
  const FlatBufferDocSpace::CylSurfaceData *Surface_as_CylSurfaceData() const {
    return Surface_type() == FlatBufferDocSpace::AttributeSurfaceData_CylSurfaceData ? static_cast<const FlatBufferDocSpace::CylSurfaceData *>(Surface()) : nullptr;
  }
  const FlatBufferDocSpace::RevSrfAttribute *Surface_as_RevSrfAttribute() const {
    return Surface_type() == FlatBufferDocSpace::AttributeSurfaceData_RevSrfAttribute ? static_cast<const FlatBufferDocSpace::RevSrfAttribute *>(Surface()) : nullptr;
  }
  const FlatBufferDocSpace::TabCylSrfAttribute *Surface_as_TabCylSrfAttribute() const {
    return Surface_type() == FlatBufferDocSpace::AttributeSurfaceData_TabCylSrfAttribute ? static_cast<const FlatBufferDocSpace::TabCylSrfAttribute *>(Surface()) : nullptr;
  }
  const FlatBufferDocSpace::AttributeGeomData *Geometry() const {
    return GetPointer<const FlatBufferDocSpace::AttributeGeomData *>(VT_GEOMETRY);
  }
  const flatbuffers::String *Color() const {
    return GetPointer<const flatbuffers::String *>(VT_COLOR);
  }
  const flatbuffers::String *Opacity() const {
    return GetPointer<const flatbuffers::String *>(VT_OPACITY);
  }
  double V() const {
    return GetField<double>(VT_V, 0.0);
  }
  double A() const {
    return GetField<double>(VT_A, 0.0);
  }
  const FlatBufferDocSpace::BoxData *Box() const {
    return GetPointer<const FlatBufferDocSpace::BoxData *>(VT_BOX);
  }
  const flatbuffers::String *Index() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX);
  }
  const flatbuffers::Vector<double> *Point() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINT);
  }
  const flatbuffers::String *Material() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIAL);
  }
  const flatbuffers::String *MaterialIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIALINDEX);
  }
  const flatbuffers::String *AI() const {
    return GetPointer<const flatbuffers::String *>(VT_AI);
  }
  bool IsCosThd() const {
    return GetField<uint8_t>(VT_ISCOSTHD, 0) != 0;
  }
  const flatbuffers::String *TI() const {
    return GetPointer<const flatbuffers::String *>(VT_TI);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyTable(Message()) &&
           VerifyOffset(verifier, VT_GEOM) &&
           verifier.VerifyTable(Geom()) &&
           VerifyField<uint8_t>(verifier, VT_CURVE_TYPE) &&
           VerifyOffset(verifier, VT_CURVE) &&
           VerifyAttributeCurveData(verifier, Curve(), Curve_type()) &&
           VerifyField<uint8_t>(verifier, VT_SURFACE_TYPE) &&
           VerifyOffset(verifier, VT_SURFACE) &&
           VerifyAttributeSurfaceData(verifier, Surface(), Surface_type()) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyTable(Geometry()) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(Color()) &&
           VerifyOffset(verifier, VT_OPACITY) &&
           verifier.VerifyString(Opacity()) &&
           VerifyField<double>(verifier, VT_V) &&
           VerifyField<double>(verifier, VT_A) &&
           VerifyOffset(verifier, VT_BOX) &&
           verifier.VerifyTable(Box()) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(Index()) &&
           VerifyOffset(verifier, VT_POINT) &&
           verifier.VerifyVector(Point()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyString(Material()) &&
           VerifyOffset(verifier, VT_MATERIALINDEX) &&
           verifier.VerifyString(MaterialIndex()) &&
           VerifyOffset(verifier, VT_AI) &&
           verifier.VerifyString(AI()) &&
           VerifyField<uint8_t>(verifier, VT_ISCOSTHD) &&
           VerifyOffset(verifier, VT_TI) &&
           verifier.VerifyString(TI()) &&
           verifier.EndTable();
  }
};

template<> inline const FlatBufferDocSpace::AttributeLineData *AttributeData::Curve_as<FlatBufferDocSpace::AttributeLineData>() const {
  return Curve_as_AttributeLineData();
}

template<> inline const FlatBufferDocSpace::AttributeArcData *AttributeData::Curve_as<FlatBufferDocSpace::AttributeArcData>() const {
  return Curve_as_AttributeArcData();
}

template<> inline const FlatBufferDocSpace::AttributeEllipseData *AttributeData::Curve_as<FlatBufferDocSpace::AttributeEllipseData>() const {
  return Curve_as_AttributeEllipseData();
}

template<> inline const FlatBufferDocSpace::AttributeNurbsData *AttributeData::Curve_as<FlatBufferDocSpace::AttributeNurbsData>() const {
  return Curve_as_AttributeNurbsData();
}

template<> inline const FlatBufferDocSpace::AttributeCrvOnSrfData *AttributeData::Curve_as<FlatBufferDocSpace::AttributeCrvOnSrfData>() const {
  return Curve_as_AttributeCrvOnSrfData();
}

template<> inline const FlatBufferDocSpace::AttributeOffsetData *AttributeData::Curve_as<FlatBufferDocSpace::AttributeOffsetData>() const {
  return Curve_as_AttributeOffsetData();
}

template<> inline const FlatBufferDocSpace::AttributeEquationData *AttributeData::Curve_as<FlatBufferDocSpace::AttributeEquationData>() const {
  return Curve_as_AttributeEquationData();
}

template<> inline const FlatBufferDocSpace::PlaneSurfaceData *AttributeData::Surface_as<FlatBufferDocSpace::PlaneSurfaceData>() const {
  return Surface_as_PlaneSurfaceData();
}

template<> inline const FlatBufferDocSpace::CylSurfaceData *AttributeData::Surface_as<FlatBufferDocSpace::CylSurfaceData>() const {
  return Surface_as_CylSurfaceData();
}

template<> inline const FlatBufferDocSpace::RevSrfAttribute *AttributeData::Surface_as<FlatBufferDocSpace::RevSrfAttribute>() const {
  return Surface_as_RevSrfAttribute();
}

template<> inline const FlatBufferDocSpace::TabCylSrfAttribute *AttributeData::Surface_as<FlatBufferDocSpace::TabCylSrfAttribute>() const {
  return Surface_as_TabCylSrfAttribute();
}

struct AttributeDataBuilder {
  typedef AttributeData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Message(flatbuffers::Offset<FlatBufferDocSpace::MessageData> Message) {
    fbb_.AddOffset(AttributeData::VT_MESSAGE, Message);
  }
  void add_Geom(flatbuffers::Offset<FlatBufferDocSpace::GeomData> Geom) {
    fbb_.AddOffset(AttributeData::VT_GEOM, Geom);
  }
  void add_Curve_type(FlatBufferDocSpace::AttributeCurveData Curve_type) {
    fbb_.AddElement<uint8_t>(AttributeData::VT_CURVE_TYPE, static_cast<uint8_t>(Curve_type), 0);
  }
  void add_Curve(flatbuffers::Offset<void> Curve) {
    fbb_.AddOffset(AttributeData::VT_CURVE, Curve);
  }
  void add_Surface_type(FlatBufferDocSpace::AttributeSurfaceData Surface_type) {
    fbb_.AddElement<uint8_t>(AttributeData::VT_SURFACE_TYPE, static_cast<uint8_t>(Surface_type), 0);
  }
  void add_Surface(flatbuffers::Offset<void> Surface) {
    fbb_.AddOffset(AttributeData::VT_SURFACE, Surface);
  }
  void add_Geometry(flatbuffers::Offset<FlatBufferDocSpace::AttributeGeomData> Geometry) {
    fbb_.AddOffset(AttributeData::VT_GEOMETRY, Geometry);
  }
  void add_Color(flatbuffers::Offset<flatbuffers::String> Color) {
    fbb_.AddOffset(AttributeData::VT_COLOR, Color);
  }
  void add_Opacity(flatbuffers::Offset<flatbuffers::String> Opacity) {
    fbb_.AddOffset(AttributeData::VT_OPACITY, Opacity);
  }
  void add_V(double V) {
    fbb_.AddElement<double>(AttributeData::VT_V, V, 0.0);
  }
  void add_A(double A) {
    fbb_.AddElement<double>(AttributeData::VT_A, A, 0.0);
  }
  void add_Box(flatbuffers::Offset<FlatBufferDocSpace::BoxData> Box) {
    fbb_.AddOffset(AttributeData::VT_BOX, Box);
  }
  void add_Index(flatbuffers::Offset<flatbuffers::String> Index) {
    fbb_.AddOffset(AttributeData::VT_INDEX, Index);
  }
  void add_Point(flatbuffers::Offset<flatbuffers::Vector<double>> Point) {
    fbb_.AddOffset(AttributeData::VT_POINT, Point);
  }
  void add_Material(flatbuffers::Offset<flatbuffers::String> Material) {
    fbb_.AddOffset(AttributeData::VT_MATERIAL, Material);
  }
  void add_MaterialIndex(flatbuffers::Offset<flatbuffers::String> MaterialIndex) {
    fbb_.AddOffset(AttributeData::VT_MATERIALINDEX, MaterialIndex);
  }
  void add_AI(flatbuffers::Offset<flatbuffers::String> AI) {
    fbb_.AddOffset(AttributeData::VT_AI, AI);
  }
  void add_IsCosThd(bool IsCosThd) {
    fbb_.AddElement<uint8_t>(AttributeData::VT_ISCOSTHD, static_cast<uint8_t>(IsCosThd), 0);
  }
  void add_TI(flatbuffers::Offset<flatbuffers::String> TI) {
    fbb_.AddOffset(AttributeData::VT_TI, TI);
  }
  explicit AttributeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeDataBuilder &operator=(const AttributeDataBuilder &);
  flatbuffers::Offset<AttributeData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeData> CreateAttributeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::MessageData> Message = 0,
    flatbuffers::Offset<FlatBufferDocSpace::GeomData> Geom = 0,
    FlatBufferDocSpace::AttributeCurveData Curve_type = FlatBufferDocSpace::AttributeCurveData_NONE,
    flatbuffers::Offset<void> Curve = 0,
    FlatBufferDocSpace::AttributeSurfaceData Surface_type = FlatBufferDocSpace::AttributeSurfaceData_NONE,
    flatbuffers::Offset<void> Surface = 0,
    flatbuffers::Offset<FlatBufferDocSpace::AttributeGeomData> Geometry = 0,
    flatbuffers::Offset<flatbuffers::String> Color = 0,
    flatbuffers::Offset<flatbuffers::String> Opacity = 0,
    double V = 0.0,
    double A = 0.0,
    flatbuffers::Offset<FlatBufferDocSpace::BoxData> Box = 0,
    flatbuffers::Offset<flatbuffers::String> Index = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Point = 0,
    flatbuffers::Offset<flatbuffers::String> Material = 0,
    flatbuffers::Offset<flatbuffers::String> MaterialIndex = 0,
    flatbuffers::Offset<flatbuffers::String> AI = 0,
    bool IsCosThd = false,
    flatbuffers::Offset<flatbuffers::String> TI = 0) {
  AttributeDataBuilder builder_(_fbb);
  builder_.add_A(A);
  builder_.add_V(V);
  builder_.add_TI(TI);
  builder_.add_AI(AI);
  builder_.add_MaterialIndex(MaterialIndex);
  builder_.add_Material(Material);
  builder_.add_Point(Point);
  builder_.add_Index(Index);
  builder_.add_Box(Box);
  builder_.add_Opacity(Opacity);
  builder_.add_Color(Color);
  builder_.add_Geometry(Geometry);
  builder_.add_Surface(Surface);
  builder_.add_Curve(Curve);
  builder_.add_Geom(Geom);
  builder_.add_Message(Message);
  builder_.add_IsCosThd(IsCosThd);
  builder_.add_Surface_type(Surface_type);
  builder_.add_Curve_type(Curve_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeData> CreateAttributeDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::MessageData> Message = 0,
    flatbuffers::Offset<FlatBufferDocSpace::GeomData> Geom = 0,
    FlatBufferDocSpace::AttributeCurveData Curve_type = FlatBufferDocSpace::AttributeCurveData_NONE,
    flatbuffers::Offset<void> Curve = 0,
    FlatBufferDocSpace::AttributeSurfaceData Surface_type = FlatBufferDocSpace::AttributeSurfaceData_NONE,
    flatbuffers::Offset<void> Surface = 0,
    flatbuffers::Offset<FlatBufferDocSpace::AttributeGeomData> Geometry = 0,
    const char *Color = nullptr,
    const char *Opacity = nullptr,
    double V = 0.0,
    double A = 0.0,
    flatbuffers::Offset<FlatBufferDocSpace::BoxData> Box = 0,
    const char *Index = nullptr,
    const std::vector<double> *Point = nullptr,
    const char *Material = nullptr,
    const char *MaterialIndex = nullptr,
    const char *AI = nullptr,
    bool IsCosThd = false,
    const char *TI = nullptr) {
  auto Color__ = Color ? _fbb.CreateString(Color) : 0;
  auto Opacity__ = Opacity ? _fbb.CreateString(Opacity) : 0;
  auto Index__ = Index ? _fbb.CreateString(Index) : 0;
  auto Point__ = Point ? _fbb.CreateVector<double>(*Point) : 0;
  auto Material__ = Material ? _fbb.CreateString(Material) : 0;
  auto MaterialIndex__ = MaterialIndex ? _fbb.CreateString(MaterialIndex) : 0;
  auto AI__ = AI ? _fbb.CreateString(AI) : 0;
  auto TI__ = TI ? _fbb.CreateString(TI) : 0;
  return FlatBufferDocSpace::CreateAttributeData(
      _fbb,
      Message,
      Geom,
      Curve_type,
      Curve,
      Surface_type,
      Surface,
      Geometry,
      Color__,
      Opacity__,
      V,
      A,
      Box,
      Index__,
      Point__,
      Material__,
      MaterialIndex__,
      AI__,
      IsCosThd,
      TI__);
}

struct ElementData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ElementDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_T = 6,
    VT_FID = 8,
    VT_VISIBLE = 10,
    VT_G = 12,
    VT_A = 14,
    VT_GEOMETRIES = 16,
    VT_STATUS = 18,
    VT_TEXTCONTENT = 20,
    VT_D = 22,
    VT_CONSTRAINTDATA = 24,
    VT_DIMENSIONDATA = 26,
    VT_TID = 28,
    VT_INDEX = 30,
    VT_BEADTEXTURE = 32,
    VT_GROUPNAME = 34,
    VT_GROUPID = 36,
    VT_IDS = 38,
    VT_VIEWINDEX = 40,
    VT_AUTOINSERTHOLE = 42,
    VT_AUTOINSERTFILLET = 44,
    VT_AUTOINSERTRELIEF = 46,
    VT_HOLECNTSYBLINETYPE = 48,
    VT_RELIEFCNTSYBLINETYPE = 50,
    VT_LINETYPE = 52,
    VT_LINEWIDTH = 54,
    VT_LINECOLOR = 56,
    VT_ARCID = 58,
    VT_CENTERPNT = 60,
    VT_SECTIONDATA = 62,
    VT_CENTERMARKSIZE = 64,
    VT_DRAFTSYMBOLDATA = 66,
    VT_ISUSEDOCDEFAULT = 68,
    VT_DINDEX = 70,
    VT_STACKEDINDEX = 72,
    VT_CENTERMARKLINETYPE = 74,
    VT_CENTERMARKDATA = 76,
    VT_BALLOONLIST = 78,
    VT_SPACINGTYPE = 80,
    VT_ANGLE = 82,
    VT_LAYER = 84
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t T() const {
    return GetField<int32_t>(VT_T, 0);
  }
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  int32_t G() const {
    return GetField<int32_t>(VT_G, 0);
  }
  const FlatBufferDocSpace::AttributeData *A() const {
    return GetPointer<const FlatBufferDocSpace::AttributeData *>(VT_A);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *Geometries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *>(VT_GEOMETRIES);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  const flatbuffers::String *TextContent() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTCONTENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>> *D() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>> *>(VT_D);
  }
  const FlatBufferDocSpace::ConstraintDataMessage *ConstraintData() const {
    return GetPointer<const FlatBufferDocSpace::ConstraintDataMessage *>(VT_CONSTRAINTDATA);
  }
  const FlatBufferDocSpace::DimensionDataMessage *DimensionData() const {
    return GetPointer<const FlatBufferDocSpace::DimensionDataMessage *>(VT_DIMENSIONDATA);
  }
  const flatbuffers::String *TID() const {
    return GetPointer<const flatbuffers::String *>(VT_TID);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const FlatBufferDocSpace::BeadTextureData *BeadTexture() const {
    return GetPointer<const FlatBufferDocSpace::BeadTextureData *>(VT_BEADTEXTURE);
  }
  const flatbuffers::String *GroupName() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUPNAME);
  }
  const flatbuffers::String *GroupID() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUPID);
  }
  const flatbuffers::Vector<int32_t> *Ids() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_IDS);
  }
  const flatbuffers::String *ViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWINDEX);
  }
  int32_t autoInsertHole() const {
    return GetField<int32_t>(VT_AUTOINSERTHOLE, 0);
  }
  int32_t autoInsertFillet() const {
    return GetField<int32_t>(VT_AUTOINSERTFILLET, 0);
  }
  int32_t autoInsertRelief() const {
    return GetField<int32_t>(VT_AUTOINSERTRELIEF, 0);
  }
  int32_t holeCntSybLineType() const {
    return GetField<int32_t>(VT_HOLECNTSYBLINETYPE, 0);
  }
  int32_t reliefCntSybLineType() const {
    return GetField<int32_t>(VT_RELIEFCNTSYBLINETYPE, 0);
  }
  int32_t LineType() const {
    return GetField<int32_t>(VT_LINETYPE, 0);
  }
  int32_t LineWidth() const {
    return GetField<int32_t>(VT_LINEWIDTH, 0);
  }
  int32_t LineColor() const {
    return GetField<int32_t>(VT_LINECOLOR, 0);
  }
  int32_t ArcId() const {
    return GetField<int32_t>(VT_ARCID, 0);
  }
  const flatbuffers::Vector<float> *CenterPnt() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CENTERPNT);
  }
  const FlatBufferDocSpace::SectionElement *SectionData() const {
    return GetPointer<const FlatBufferDocSpace::SectionElement *>(VT_SECTIONDATA);
  }
  float CenterMarkSize() const {
    return GetField<float>(VT_CENTERMARKSIZE, 0.0f);
  }
  const FlatBufferDocSpace::DraftSymbolEelement *DraftSymbolData() const {
    return GetPointer<const FlatBufferDocSpace::DraftSymbolEelement *>(VT_DRAFTSYMBOLDATA);
  }
  int32_t IsUseDocDefault() const {
    return GetField<int32_t>(VT_ISUSEDOCDEFAULT, 0);
  }
  const flatbuffers::String *DIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_DINDEX);
  }
  const flatbuffers::String *StackedIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_STACKEDINDEX);
  }
  int32_t CenterMarkLineType() const {
    return GetField<int32_t>(VT_CENTERMARKLINETYPE, 0);
  }
  const FlatBufferDocSpace::CenterMarkElement *CenterMarkData() const {
    return GetPointer<const FlatBufferDocSpace::CenterMarkElement *>(VT_CENTERMARKDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *BalloonList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_BALLOONLIST);
  }
  int32_t SpacingType() const {
    return GetField<int32_t>(VT_SPACINGTYPE, 0);
  }
  int32_t Angle() const {
    return GetField<int32_t>(VT_ANGLE, 0);
  }
  int32_t Layer() const {
    return GetField<int32_t>(VT_LAYER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<int32_t>(verifier, VT_G) &&
           VerifyOffset(verifier, VT_A) &&
           verifier.VerifyTable(A()) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.VerifyVector(Geometries()) &&
           verifier.VerifyVectorOfTables(Geometries()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_TEXTCONTENT) &&
           verifier.VerifyString(TextContent()) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyVector(D()) &&
           verifier.VerifyVectorOfTables(D()) &&
           VerifyOffset(verifier, VT_CONSTRAINTDATA) &&
           verifier.VerifyTable(ConstraintData()) &&
           VerifyOffset(verifier, VT_DIMENSIONDATA) &&
           verifier.VerifyTable(DimensionData()) &&
           VerifyOffset(verifier, VT_TID) &&
           verifier.VerifyString(TID()) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_BEADTEXTURE) &&
           verifier.VerifyTable(BeadTexture()) &&
           VerifyOffset(verifier, VT_GROUPNAME) &&
           verifier.VerifyString(GroupName()) &&
           VerifyOffset(verifier, VT_GROUPID) &&
           verifier.VerifyString(GroupID()) &&
           VerifyOffset(verifier, VT_IDS) &&
           verifier.VerifyVector(Ids()) &&
           VerifyOffset(verifier, VT_VIEWINDEX) &&
           verifier.VerifyString(ViewIndex()) &&
           VerifyField<int32_t>(verifier, VT_AUTOINSERTHOLE) &&
           VerifyField<int32_t>(verifier, VT_AUTOINSERTFILLET) &&
           VerifyField<int32_t>(verifier, VT_AUTOINSERTRELIEF) &&
           VerifyField<int32_t>(verifier, VT_HOLECNTSYBLINETYPE) &&
           VerifyField<int32_t>(verifier, VT_RELIEFCNTSYBLINETYPE) &&
           VerifyField<int32_t>(verifier, VT_LINETYPE) &&
           VerifyField<int32_t>(verifier, VT_LINEWIDTH) &&
           VerifyField<int32_t>(verifier, VT_LINECOLOR) &&
           VerifyField<int32_t>(verifier, VT_ARCID) &&
           VerifyOffset(verifier, VT_CENTERPNT) &&
           verifier.VerifyVector(CenterPnt()) &&
           VerifyOffset(verifier, VT_SECTIONDATA) &&
           verifier.VerifyTable(SectionData()) &&
           VerifyField<float>(verifier, VT_CENTERMARKSIZE) &&
           VerifyOffset(verifier, VT_DRAFTSYMBOLDATA) &&
           verifier.VerifyTable(DraftSymbolData()) &&
           VerifyField<int32_t>(verifier, VT_ISUSEDOCDEFAULT) &&
           VerifyOffset(verifier, VT_DINDEX) &&
           verifier.VerifyString(DIndex()) &&
           VerifyOffset(verifier, VT_STACKEDINDEX) &&
           verifier.VerifyString(StackedIndex()) &&
           VerifyField<int32_t>(verifier, VT_CENTERMARKLINETYPE) &&
           VerifyOffset(verifier, VT_CENTERMARKDATA) &&
           verifier.VerifyTable(CenterMarkData()) &&
           VerifyOffset(verifier, VT_BALLOONLIST) &&
           verifier.VerifyVector(BalloonList()) &&
           verifier.VerifyVectorOfStrings(BalloonList()) &&
           VerifyField<int32_t>(verifier, VT_SPACINGTYPE) &&
           VerifyField<int32_t>(verifier, VT_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_LAYER) &&
           verifier.EndTable();
  }
};

struct ElementDataBuilder {
  typedef ElementData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(ElementData::VT_ID, ID, 0);
  }
  void add_T(int32_t T) {
    fbb_.AddElement<int32_t>(ElementData::VT_T, T, 0);
  }
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(ElementData::VT_FID, FID, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(ElementData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_G(int32_t G) {
    fbb_.AddElement<int32_t>(ElementData::VT_G, G, 0);
  }
  void add_A(flatbuffers::Offset<FlatBufferDocSpace::AttributeData> A) {
    fbb_.AddOffset(ElementData::VT_A, A);
  }
  void add_Geometries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>> Geometries) {
    fbb_.AddOffset(ElementData::VT_GEOMETRIES, Geometries);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(ElementData::VT_STATUS, Status, 0);
  }
  void add_TextContent(flatbuffers::Offset<flatbuffers::String> TextContent) {
    fbb_.AddOffset(ElementData::VT_TEXTCONTENT, TextContent);
  }
  void add_D(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>>> D) {
    fbb_.AddOffset(ElementData::VT_D, D);
  }
  void add_ConstraintData(flatbuffers::Offset<FlatBufferDocSpace::ConstraintDataMessage> ConstraintData) {
    fbb_.AddOffset(ElementData::VT_CONSTRAINTDATA, ConstraintData);
  }
  void add_DimensionData(flatbuffers::Offset<FlatBufferDocSpace::DimensionDataMessage> DimensionData) {
    fbb_.AddOffset(ElementData::VT_DIMENSIONDATA, DimensionData);
  }
  void add_TID(flatbuffers::Offset<flatbuffers::String> TID) {
    fbb_.AddOffset(ElementData::VT_TID, TID);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(ElementData::VT_INDEX, Index, 0);
  }
  void add_BeadTexture(flatbuffers::Offset<FlatBufferDocSpace::BeadTextureData> BeadTexture) {
    fbb_.AddOffset(ElementData::VT_BEADTEXTURE, BeadTexture);
  }
  void add_GroupName(flatbuffers::Offset<flatbuffers::String> GroupName) {
    fbb_.AddOffset(ElementData::VT_GROUPNAME, GroupName);
  }
  void add_GroupID(flatbuffers::Offset<flatbuffers::String> GroupID) {
    fbb_.AddOffset(ElementData::VT_GROUPID, GroupID);
  }
  void add_Ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Ids) {
    fbb_.AddOffset(ElementData::VT_IDS, Ids);
  }
  void add_ViewIndex(flatbuffers::Offset<flatbuffers::String> ViewIndex) {
    fbb_.AddOffset(ElementData::VT_VIEWINDEX, ViewIndex);
  }
  void add_autoInsertHole(int32_t autoInsertHole) {
    fbb_.AddElement<int32_t>(ElementData::VT_AUTOINSERTHOLE, autoInsertHole, 0);
  }
  void add_autoInsertFillet(int32_t autoInsertFillet) {
    fbb_.AddElement<int32_t>(ElementData::VT_AUTOINSERTFILLET, autoInsertFillet, 0);
  }
  void add_autoInsertRelief(int32_t autoInsertRelief) {
    fbb_.AddElement<int32_t>(ElementData::VT_AUTOINSERTRELIEF, autoInsertRelief, 0);
  }
  void add_holeCntSybLineType(int32_t holeCntSybLineType) {
    fbb_.AddElement<int32_t>(ElementData::VT_HOLECNTSYBLINETYPE, holeCntSybLineType, 0);
  }
  void add_reliefCntSybLineType(int32_t reliefCntSybLineType) {
    fbb_.AddElement<int32_t>(ElementData::VT_RELIEFCNTSYBLINETYPE, reliefCntSybLineType, 0);
  }
  void add_LineType(int32_t LineType) {
    fbb_.AddElement<int32_t>(ElementData::VT_LINETYPE, LineType, 0);
  }
  void add_LineWidth(int32_t LineWidth) {
    fbb_.AddElement<int32_t>(ElementData::VT_LINEWIDTH, LineWidth, 0);
  }
  void add_LineColor(int32_t LineColor) {
    fbb_.AddElement<int32_t>(ElementData::VT_LINECOLOR, LineColor, 0);
  }
  void add_ArcId(int32_t ArcId) {
    fbb_.AddElement<int32_t>(ElementData::VT_ARCID, ArcId, 0);
  }
  void add_CenterPnt(flatbuffers::Offset<flatbuffers::Vector<float>> CenterPnt) {
    fbb_.AddOffset(ElementData::VT_CENTERPNT, CenterPnt);
  }
  void add_SectionData(flatbuffers::Offset<FlatBufferDocSpace::SectionElement> SectionData) {
    fbb_.AddOffset(ElementData::VT_SECTIONDATA, SectionData);
  }
  void add_CenterMarkSize(float CenterMarkSize) {
    fbb_.AddElement<float>(ElementData::VT_CENTERMARKSIZE, CenterMarkSize, 0.0f);
  }
  void add_DraftSymbolData(flatbuffers::Offset<FlatBufferDocSpace::DraftSymbolEelement> DraftSymbolData) {
    fbb_.AddOffset(ElementData::VT_DRAFTSYMBOLDATA, DraftSymbolData);
  }
  void add_IsUseDocDefault(int32_t IsUseDocDefault) {
    fbb_.AddElement<int32_t>(ElementData::VT_ISUSEDOCDEFAULT, IsUseDocDefault, 0);
  }
  void add_DIndex(flatbuffers::Offset<flatbuffers::String> DIndex) {
    fbb_.AddOffset(ElementData::VT_DINDEX, DIndex);
  }
  void add_StackedIndex(flatbuffers::Offset<flatbuffers::String> StackedIndex) {
    fbb_.AddOffset(ElementData::VT_STACKEDINDEX, StackedIndex);
  }
  void add_CenterMarkLineType(int32_t CenterMarkLineType) {
    fbb_.AddElement<int32_t>(ElementData::VT_CENTERMARKLINETYPE, CenterMarkLineType, 0);
  }
  void add_CenterMarkData(flatbuffers::Offset<FlatBufferDocSpace::CenterMarkElement> CenterMarkData) {
    fbb_.AddOffset(ElementData::VT_CENTERMARKDATA, CenterMarkData);
  }
  void add_BalloonList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> BalloonList) {
    fbb_.AddOffset(ElementData::VT_BALLOONLIST, BalloonList);
  }
  void add_SpacingType(int32_t SpacingType) {
    fbb_.AddElement<int32_t>(ElementData::VT_SPACINGTYPE, SpacingType, 0);
  }
  void add_Angle(int32_t Angle) {
    fbb_.AddElement<int32_t>(ElementData::VT_ANGLE, Angle, 0);
  }
  void add_Layer(int32_t Layer) {
    fbb_.AddElement<int32_t>(ElementData::VT_LAYER, Layer, 0);
  }
  explicit ElementDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ElementDataBuilder &operator=(const ElementDataBuilder &);
  flatbuffers::Offset<ElementData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ElementData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ElementData> CreateElementData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t T = 0,
    int32_t FID = 0,
    bool Visible = false,
    int32_t G = 0,
    flatbuffers::Offset<FlatBufferDocSpace::AttributeData> A = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>> Geometries = 0,
    int32_t Status = 0,
    flatbuffers::Offset<flatbuffers::String> TextContent = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>>> D = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ConstraintDataMessage> ConstraintData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::DimensionDataMessage> DimensionData = 0,
    flatbuffers::Offset<flatbuffers::String> TID = 0,
    int32_t Index = 0,
    flatbuffers::Offset<FlatBufferDocSpace::BeadTextureData> BeadTexture = 0,
    flatbuffers::Offset<flatbuffers::String> GroupName = 0,
    flatbuffers::Offset<flatbuffers::String> GroupID = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Ids = 0,
    flatbuffers::Offset<flatbuffers::String> ViewIndex = 0,
    int32_t autoInsertHole = 0,
    int32_t autoInsertFillet = 0,
    int32_t autoInsertRelief = 0,
    int32_t holeCntSybLineType = 0,
    int32_t reliefCntSybLineType = 0,
    int32_t LineType = 0,
    int32_t LineWidth = 0,
    int32_t LineColor = 0,
    int32_t ArcId = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> CenterPnt = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SectionElement> SectionData = 0,
    float CenterMarkSize = 0.0f,
    flatbuffers::Offset<FlatBufferDocSpace::DraftSymbolEelement> DraftSymbolData = 0,
    int32_t IsUseDocDefault = 0,
    flatbuffers::Offset<flatbuffers::String> DIndex = 0,
    flatbuffers::Offset<flatbuffers::String> StackedIndex = 0,
    int32_t CenterMarkLineType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::CenterMarkElement> CenterMarkData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> BalloonList = 0,
    int32_t SpacingType = 0,
    int32_t Angle = 0,
    int32_t Layer = 0) {
  ElementDataBuilder builder_(_fbb);
  builder_.add_Layer(Layer);
  builder_.add_Angle(Angle);
  builder_.add_SpacingType(SpacingType);
  builder_.add_BalloonList(BalloonList);
  builder_.add_CenterMarkData(CenterMarkData);
  builder_.add_CenterMarkLineType(CenterMarkLineType);
  builder_.add_StackedIndex(StackedIndex);
  builder_.add_DIndex(DIndex);
  builder_.add_IsUseDocDefault(IsUseDocDefault);
  builder_.add_DraftSymbolData(DraftSymbolData);
  builder_.add_CenterMarkSize(CenterMarkSize);
  builder_.add_SectionData(SectionData);
  builder_.add_CenterPnt(CenterPnt);
  builder_.add_ArcId(ArcId);
  builder_.add_LineColor(LineColor);
  builder_.add_LineWidth(LineWidth);
  builder_.add_LineType(LineType);
  builder_.add_reliefCntSybLineType(reliefCntSybLineType);
  builder_.add_holeCntSybLineType(holeCntSybLineType);
  builder_.add_autoInsertRelief(autoInsertRelief);
  builder_.add_autoInsertFillet(autoInsertFillet);
  builder_.add_autoInsertHole(autoInsertHole);
  builder_.add_ViewIndex(ViewIndex);
  builder_.add_Ids(Ids);
  builder_.add_GroupID(GroupID);
  builder_.add_GroupName(GroupName);
  builder_.add_BeadTexture(BeadTexture);
  builder_.add_Index(Index);
  builder_.add_TID(TID);
  builder_.add_DimensionData(DimensionData);
  builder_.add_ConstraintData(ConstraintData);
  builder_.add_D(D);
  builder_.add_TextContent(TextContent);
  builder_.add_Status(Status);
  builder_.add_Geometries(Geometries);
  builder_.add_A(A);
  builder_.add_G(G);
  builder_.add_FID(FID);
  builder_.add_T(T);
  builder_.add_ID(ID);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<ElementData> CreateElementDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t T = 0,
    int32_t FID = 0,
    bool Visible = false,
    int32_t G = 0,
    flatbuffers::Offset<FlatBufferDocSpace::AttributeData> A = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *Geometries = nullptr,
    int32_t Status = 0,
    const char *TextContent = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>> *D = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::ConstraintDataMessage> ConstraintData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::DimensionDataMessage> DimensionData = 0,
    const char *TID = nullptr,
    int32_t Index = 0,
    flatbuffers::Offset<FlatBufferDocSpace::BeadTextureData> BeadTexture = 0,
    const char *GroupName = nullptr,
    const char *GroupID = nullptr,
    const std::vector<int32_t> *Ids = nullptr,
    const char *ViewIndex = nullptr,
    int32_t autoInsertHole = 0,
    int32_t autoInsertFillet = 0,
    int32_t autoInsertRelief = 0,
    int32_t holeCntSybLineType = 0,
    int32_t reliefCntSybLineType = 0,
    int32_t LineType = 0,
    int32_t LineWidth = 0,
    int32_t LineColor = 0,
    int32_t ArcId = 0,
    const std::vector<float> *CenterPnt = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::SectionElement> SectionData = 0,
    float CenterMarkSize = 0.0f,
    flatbuffers::Offset<FlatBufferDocSpace::DraftSymbolEelement> DraftSymbolData = 0,
    int32_t IsUseDocDefault = 0,
    const char *DIndex = nullptr,
    const char *StackedIndex = nullptr,
    int32_t CenterMarkLineType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::CenterMarkElement> CenterMarkData = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *BalloonList = nullptr,
    int32_t SpacingType = 0,
    int32_t Angle = 0,
    int32_t Layer = 0) {
  auto Geometries__ = Geometries ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>(*Geometries) : 0;
  auto TextContent__ = TextContent ? _fbb.CreateString(TextContent) : 0;
  auto D__ = D ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>>(*D) : 0;
  auto TID__ = TID ? _fbb.CreateString(TID) : 0;
  auto GroupName__ = GroupName ? _fbb.CreateString(GroupName) : 0;
  auto GroupID__ = GroupID ? _fbb.CreateString(GroupID) : 0;
  auto Ids__ = Ids ? _fbb.CreateVector<int32_t>(*Ids) : 0;
  auto ViewIndex__ = ViewIndex ? _fbb.CreateString(ViewIndex) : 0;
  auto CenterPnt__ = CenterPnt ? _fbb.CreateVector<float>(*CenterPnt) : 0;
  auto DIndex__ = DIndex ? _fbb.CreateString(DIndex) : 0;
  auto StackedIndex__ = StackedIndex ? _fbb.CreateString(StackedIndex) : 0;
  auto BalloonList__ = BalloonList ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*BalloonList) : 0;
  return FlatBufferDocSpace::CreateElementData(
      _fbb,
      ID,
      T,
      FID,
      Visible,
      G,
      A,
      Geometries__,
      Status,
      TextContent__,
      D__,
      ConstraintData,
      DimensionData,
      TID__,
      Index,
      BeadTexture,
      GroupName__,
      GroupID__,
      Ids__,
      ViewIndex__,
      autoInsertHole,
      autoInsertFillet,
      autoInsertRelief,
      holeCntSybLineType,
      reliefCntSybLineType,
      LineType,
      LineWidth,
      LineColor,
      ArcId,
      CenterPnt__,
      SectionData,
      CenterMarkSize,
      DraftSymbolData,
      IsUseDocDefault,
      DIndex__,
      StackedIndex__,
      CenterMarkLineType,
      CenterMarkData,
      BalloonList__,
      SpacingType,
      Angle,
      Layer);
}

struct LoopData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoopDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_COEDGES = 6
  };
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<int32_t> *Coedges() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_COEDGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_COEDGES) &&
           verifier.VerifyVector(Coedges()) &&
           verifier.EndTable();
  }
};

struct LoopDataBuilder {
  typedef LoopData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(LoopData::VT_TYPE, Type);
  }
  void add_Coedges(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Coedges) {
    fbb_.AddOffset(LoopData::VT_COEDGES, Coedges);
  }
  explicit LoopDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoopDataBuilder &operator=(const LoopDataBuilder &);
  flatbuffers::Offset<LoopData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoopData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoopData> CreateLoopData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Coedges = 0) {
  LoopDataBuilder builder_(_fbb);
  builder_.add_Coedges(Coedges);
  builder_.add_Type(Type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoopData> CreateLoopDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Type = nullptr,
    const std::vector<int32_t> *Coedges = nullptr) {
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto Coedges__ = Coedges ? _fbb.CreateVector<int32_t>(*Coedges) : 0;
  return FlatBufferDocSpace::CreateLoopData(
      _fbb,
      Type__,
      Coedges__);
}

struct FaceTopoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FaceTopoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LOOPS = 6
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LoopData>> *Loops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LoopData>> *>(VT_LOOPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_LOOPS) &&
           verifier.VerifyVector(Loops()) &&
           verifier.VerifyVectorOfTables(Loops()) &&
           verifier.EndTable();
  }
};

struct FaceTopoDataBuilder {
  typedef FaceTopoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(FaceTopoData::VT_ID, ID, 0);
  }
  void add_Loops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LoopData>>> Loops) {
    fbb_.AddOffset(FaceTopoData::VT_LOOPS, Loops);
  }
  explicit FaceTopoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FaceTopoDataBuilder &operator=(const FaceTopoDataBuilder &);
  flatbuffers::Offset<FaceTopoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FaceTopoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FaceTopoData> CreateFaceTopoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LoopData>>> Loops = 0) {
  FaceTopoDataBuilder builder_(_fbb);
  builder_.add_Loops(Loops);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<FaceTopoData> CreateFaceTopoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::LoopData>> *Loops = nullptr) {
  auto Loops__ = Loops ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::LoopData>>(*Loops) : 0;
  return FlatBufferDocSpace::CreateFaceTopoData(
      _fbb,
      ID,
      Loops__);
}

struct EdgeTopoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EdgeTopoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VERTICES = 6
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<int32_t> *Vertices() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VERTICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyVector(Vertices()) &&
           verifier.EndTable();
  }
};

struct EdgeTopoDataBuilder {
  typedef EdgeTopoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(EdgeTopoData::VT_ID, ID, 0);
  }
  void add_Vertices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Vertices) {
    fbb_.AddOffset(EdgeTopoData::VT_VERTICES, Vertices);
  }
  explicit EdgeTopoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EdgeTopoDataBuilder &operator=(const EdgeTopoDataBuilder &);
  flatbuffers::Offset<EdgeTopoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EdgeTopoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<EdgeTopoData> CreateEdgeTopoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Vertices = 0) {
  EdgeTopoDataBuilder builder_(_fbb);
  builder_.add_Vertices(Vertices);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<EdgeTopoData> CreateEdgeTopoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    const std::vector<int32_t> *Vertices = nullptr) {
  auto Vertices__ = Vertices ? _fbb.CreateVector<int32_t>(*Vertices) : 0;
  return FlatBufferDocSpace::CreateEdgeTopoData(
      _fbb,
      ID,
      Vertices__);
}

struct VerticeTopoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VerticeTopoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct VerticeTopoDataBuilder {
  typedef VerticeTopoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(VerticeTopoData::VT_ID, ID, 0);
  }
  explicit VerticeTopoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VerticeTopoDataBuilder &operator=(const VerticeTopoDataBuilder &);
  flatbuffers::Offset<VerticeTopoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VerticeTopoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<VerticeTopoData> CreateVerticeTopoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0) {
  VerticeTopoDataBuilder builder_(_fbb);
  builder_.add_ID(ID);
  return builder_.Finish();
}

struct TopoIdData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopoIdDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct TopoIdDataBuilder {
  typedef TopoIdData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(TopoIdData::VT_ID, ID, 0);
  }
  explicit TopoIdDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopoIdDataBuilder &operator=(const TopoIdDataBuilder &);
  flatbuffers::Offset<TopoIdData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopoIdData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopoIdData> CreateTopoIdData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0) {
  TopoIdDataBuilder builder_(_fbb);
  builder_.add_ID(ID);
  return builder_.Finish();
}

struct SketchLoopData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SketchLoopDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int32_t> *Value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(Value()) &&
           verifier.EndTable();
  }
};

struct SketchLoopDataBuilder {
  typedef SketchLoopData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Value) {
    fbb_.AddOffset(SketchLoopData::VT_VALUE, Value);
  }
  explicit SketchLoopDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SketchLoopDataBuilder &operator=(const SketchLoopDataBuilder &);
  flatbuffers::Offset<SketchLoopData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SketchLoopData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SketchLoopData> CreateSketchLoopData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Value = 0) {
  SketchLoopDataBuilder builder_(_fbb);
  builder_.add_Value(Value);
  return builder_.Finish();
}

inline flatbuffers::Offset<SketchLoopData> CreateSketchLoopDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *Value = nullptr) {
  auto Value__ = Value ? _fbb.CreateVector<int32_t>(*Value) : 0;
  return FlatBufferDocSpace::CreateSketchLoopData(
      _fbb,
      Value__);
}

struct SolidSketchTopoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SolidSketchTopoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FACES = 4,
    VT_EDGES = 6,
    VT_VERTICES = 8,
    VT_DIMENSIONS = 10,
    VT_CONSTRAINTS = 12,
    VT_CURVES = 14,
    VT_POINTS = 16,
    VT_SKETCHTEXTS = 18,
    VT_LOOPS = 20,
    VT_SKETCHREGION = 22,
    VT_ELEMENTS = 24,
    VT_SKETCHPICTURES = 26
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FaceTopoData>> *Faces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FaceTopoData>> *>(VT_FACES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EdgeTopoData>> *Edges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EdgeTopoData>> *>(VT_EDGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VerticeTopoData>> *Vertices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VerticeTopoData>> *>(VT_VERTICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Dimensions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *>(VT_DIMENSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Constraints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *>(VT_CONSTRAINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Curves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *>(VT_CURVES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *>(VT_POINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *SketchTexts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *>(VT_SKETCHTEXTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchLoopData>> *Loops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchLoopData>> *>(VT_LOOPS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *SketchRegion() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *>(VT_SKETCHREGION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Elements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *>(VT_ELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *SketchPictures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *>(VT_SKETCHPICTURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FACES) &&
           verifier.VerifyVector(Faces()) &&
           verifier.VerifyVectorOfTables(Faces()) &&
           VerifyOffset(verifier, VT_EDGES) &&
           verifier.VerifyVector(Edges()) &&
           verifier.VerifyVectorOfTables(Edges()) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyVector(Vertices()) &&
           verifier.VerifyVectorOfTables(Vertices()) &&
           VerifyOffset(verifier, VT_DIMENSIONS) &&
           verifier.VerifyVector(Dimensions()) &&
           verifier.VerifyVectorOfTables(Dimensions()) &&
           VerifyOffset(verifier, VT_CONSTRAINTS) &&
           verifier.VerifyVector(Constraints()) &&
           verifier.VerifyVectorOfTables(Constraints()) &&
           VerifyOffset(verifier, VT_CURVES) &&
           verifier.VerifyVector(Curves()) &&
           verifier.VerifyVectorOfTables(Curves()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(Points()) &&
           verifier.VerifyVectorOfTables(Points()) &&
           VerifyOffset(verifier, VT_SKETCHTEXTS) &&
           verifier.VerifyVector(SketchTexts()) &&
           verifier.VerifyVectorOfTables(SketchTexts()) &&
           VerifyOffset(verifier, VT_LOOPS) &&
           verifier.VerifyVector(Loops()) &&
           verifier.VerifyVectorOfTables(Loops()) &&
           VerifyOffset(verifier, VT_SKETCHREGION) &&
           verifier.VerifyVector(SketchRegion()) &&
           verifier.VerifyVectorOfTables(SketchRegion()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(Elements()) &&
           verifier.VerifyVectorOfTables(Elements()) &&
           VerifyOffset(verifier, VT_SKETCHPICTURES) &&
           verifier.VerifyVector(SketchPictures()) &&
           verifier.VerifyVectorOfTables(SketchPictures()) &&
           verifier.EndTable();
  }
};

struct SolidSketchTopoDataBuilder {
  typedef SolidSketchTopoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Faces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FaceTopoData>>> Faces) {
    fbb_.AddOffset(SolidSketchTopoData::VT_FACES, Faces);
  }
  void add_Edges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EdgeTopoData>>> Edges) {
    fbb_.AddOffset(SolidSketchTopoData::VT_EDGES, Edges);
  }
  void add_Vertices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VerticeTopoData>>> Vertices) {
    fbb_.AddOffset(SolidSketchTopoData::VT_VERTICES, Vertices);
  }
  void add_Dimensions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Dimensions) {
    fbb_.AddOffset(SolidSketchTopoData::VT_DIMENSIONS, Dimensions);
  }
  void add_Constraints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Constraints) {
    fbb_.AddOffset(SolidSketchTopoData::VT_CONSTRAINTS, Constraints);
  }
  void add_Curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Curves) {
    fbb_.AddOffset(SolidSketchTopoData::VT_CURVES, Curves);
  }
  void add_Points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Points) {
    fbb_.AddOffset(SolidSketchTopoData::VT_POINTS, Points);
  }
  void add_SketchTexts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> SketchTexts) {
    fbb_.AddOffset(SolidSketchTopoData::VT_SKETCHTEXTS, SketchTexts);
  }
  void add_Loops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchLoopData>>> Loops) {
    fbb_.AddOffset(SolidSketchTopoData::VT_LOOPS, Loops);
  }
  void add_SketchRegion(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> SketchRegion) {
    fbb_.AddOffset(SolidSketchTopoData::VT_SKETCHREGION, SketchRegion);
  }
  void add_Elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Elements) {
    fbb_.AddOffset(SolidSketchTopoData::VT_ELEMENTS, Elements);
  }
  void add_SketchPictures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> SketchPictures) {
    fbb_.AddOffset(SolidSketchTopoData::VT_SKETCHPICTURES, SketchPictures);
  }
  explicit SolidSketchTopoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SolidSketchTopoDataBuilder &operator=(const SolidSketchTopoDataBuilder &);
  flatbuffers::Offset<SolidSketchTopoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SolidSketchTopoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SolidSketchTopoData> CreateSolidSketchTopoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FaceTopoData>>> Faces = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EdgeTopoData>>> Edges = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VerticeTopoData>>> Vertices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Dimensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Constraints = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Curves = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Points = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> SketchTexts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchLoopData>>> Loops = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> SketchRegion = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> Elements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>> SketchPictures = 0) {
  SolidSketchTopoDataBuilder builder_(_fbb);
  builder_.add_SketchPictures(SketchPictures);
  builder_.add_Elements(Elements);
  builder_.add_SketchRegion(SketchRegion);
  builder_.add_Loops(Loops);
  builder_.add_SketchTexts(SketchTexts);
  builder_.add_Points(Points);
  builder_.add_Curves(Curves);
  builder_.add_Constraints(Constraints);
  builder_.add_Dimensions(Dimensions);
  builder_.add_Vertices(Vertices);
  builder_.add_Edges(Edges);
  builder_.add_Faces(Faces);
  return builder_.Finish();
}

inline flatbuffers::Offset<SolidSketchTopoData> CreateSolidSketchTopoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FaceTopoData>> *Faces = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EdgeTopoData>> *Edges = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VerticeTopoData>> *Vertices = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Dimensions = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Constraints = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Curves = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Points = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *SketchTexts = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SketchLoopData>> *Loops = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *SketchRegion = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *Elements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>> *SketchPictures = nullptr) {
  auto Faces__ = Faces ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FaceTopoData>>(*Faces) : 0;
  auto Edges__ = Edges ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EdgeTopoData>>(*Edges) : 0;
  auto Vertices__ = Vertices ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VerticeTopoData>>(*Vertices) : 0;
  auto Dimensions__ = Dimensions ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>(*Dimensions) : 0;
  auto Constraints__ = Constraints ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>(*Constraints) : 0;
  auto Curves__ = Curves ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>(*Curves) : 0;
  auto Points__ = Points ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>(*Points) : 0;
  auto SketchTexts__ = SketchTexts ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>(*SketchTexts) : 0;
  auto Loops__ = Loops ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SketchLoopData>>(*Loops) : 0;
  auto SketchRegion__ = SketchRegion ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>(*SketchRegion) : 0;
  auto Elements__ = Elements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>(*Elements) : 0;
  auto SketchPictures__ = SketchPictures ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoIdData>>(*SketchPictures) : 0;
  return FlatBufferDocSpace::CreateSolidSketchTopoData(
      _fbb,
      Faces__,
      Edges__,
      Vertices__,
      Dimensions__,
      Constraints__,
      Curves__,
      Points__,
      SketchTexts__,
      Loops__,
      SketchRegion__,
      Elements__,
      SketchPictures__);
}

struct BorderData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BorderDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURVES = 4,
    VT_LABELS = 6
  };
  const flatbuffers::Vector<int32_t> *Curves() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURVES);
  }
  const flatbuffers::Vector<int32_t> *Labels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LABELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURVES) &&
           verifier.VerifyVector(Curves()) &&
           VerifyOffset(verifier, VT_LABELS) &&
           verifier.VerifyVector(Labels()) &&
           verifier.EndTable();
  }
};

struct BorderDataBuilder {
  typedef BorderData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Curves(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Curves) {
    fbb_.AddOffset(BorderData::VT_CURVES, Curves);
  }
  void add_Labels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Labels) {
    fbb_.AddOffset(BorderData::VT_LABELS, Labels);
  }
  explicit BorderDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BorderDataBuilder &operator=(const BorderDataBuilder &);
  flatbuffers::Offset<BorderData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BorderData>(end);
    return o;
  }
};

inline flatbuffers::Offset<BorderData> CreateBorderData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Curves = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Labels = 0) {
  BorderDataBuilder builder_(_fbb);
  builder_.add_Labels(Labels);
  builder_.add_Curves(Curves);
  return builder_.Finish();
}

inline flatbuffers::Offset<BorderData> CreateBorderDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *Curves = nullptr,
    const std::vector<int32_t> *Labels = nullptr) {
  auto Curves__ = Curves ? _fbb.CreateVector<int32_t>(*Curves) : 0;
  auto Labels__ = Labels ? _fbb.CreateVector<int32_t>(*Labels) : 0;
  return FlatBufferDocSpace::CreateBorderData(
      _fbb,
      Curves__,
      Labels__);
}

struct EntityData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_FID = 8,
    VT_VISIBLE = 10,
    VT_ATTR = 12,
    VT_TID = 14,
    VT_NAME = 16,
    VT_OFID = 18,
    VT_TOPODATA = 20,
    VT_VO = 22,
    VT_VN = 24,
    VT_MATRIX = 26,
    VT_STATUS = 28,
    VT_ACTIVE = 30,
    VT_DEFDATA = 32,
    VT_ARSDATA = 34,
    VT_D = 36,
    VT_EVD = 38,
    VT_FOLDERCHILDREN = 40,
    VT_FOCUSVIEWBOX = 42,
    VT_DS = 44,
    VT_GROUPID = 46,
    VT_T = 48,
    VT_GROUPNAME = 50,
    VT_CHILDREN = 52,
    VT_TABLEINFO = 54,
    VT_BORDER = 56,
    VT_FOLDERID = 58,
    VT_AREAHATCHDATA = 60
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  const FlatBufferDocSpace::AttributeData *Attr() const {
    return GetPointer<const FlatBufferDocSpace::AttributeData *>(VT_ATTR);
  }
  const flatbuffers::String *TID() const {
    return GetPointer<const flatbuffers::String *>(VT_TID);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t OFID() const {
    return GetField<int32_t>(VT_OFID, 0);
  }
  const FlatBufferDocSpace::SolidSketchTopoData *TopoData() const {
    return GetPointer<const FlatBufferDocSpace::SolidSketchTopoData *>(VT_TOPODATA);
  }
  int32_t VO() const {
    return GetField<int32_t>(VT_VO, 0);
  }
  int32_t VN() const {
    return GetField<int32_t>(VT_VN, 0);
  }
  const flatbuffers::Vector<double> *Matrix() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MATRIX);
  }
  bool Status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool Active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  const FlatBufferDocSpace::DefDataMessage *DefData() const {
    return GetPointer<const FlatBufferDocSpace::DefDataMessage *>(VT_DEFDATA);
  }
  const FlatBufferDocSpace::ArsDataMessage *ArsData() const {
    return GetPointer<const FlatBufferDocSpace::ArsDataMessage *>(VT_ARSDATA);
  }
  const FlatBufferDocSpace::DiscreteInforData *D() const {
    return GetPointer<const FlatBufferDocSpace::DiscreteInforData *>(VT_D);
  }
  const flatbuffers::Vector<float> *EVD() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_EVD);
  }
  const flatbuffers::Vector<int32_t> *FolderChildren() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FOLDERCHILDREN);
  }
  const flatbuffers::Vector<float> *FocusViewBox() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FOCUSVIEWBOX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteGroupData>> *Ds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteGroupData>> *>(VT_DS);
  }
  const flatbuffers::String *GroupID() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUPID);
  }
  int32_t T() const {
    return GetField<int32_t>(VT_T, 0);
  }
  const flatbuffers::String *GroupName() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUPNAME);
  }
  const flatbuffers::Vector<int32_t> *Children() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CHILDREN);
  }
  const FlatBufferDocSpace::TableInfoData *TableInfo() const {
    return GetPointer<const FlatBufferDocSpace::TableInfoData *>(VT_TABLEINFO);
  }
  const FlatBufferDocSpace::BorderData *Border() const {
    return GetPointer<const FlatBufferDocSpace::BorderData *>(VT_BORDER);
  }
  int32_t FolderID() const {
    return GetField<int32_t>(VT_FOLDERID, 0);
  }
  const FlatBufferDocSpace::HatchRegionElements *AreaHatchData() const {
    return GetPointer<const FlatBufferDocSpace::HatchRegionElements *>(VT_AREAHATCHDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyTable(Attr()) &&
           VerifyOffset(verifier, VT_TID) &&
           verifier.VerifyString(TID()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_OFID) &&
           VerifyOffset(verifier, VT_TOPODATA) &&
           verifier.VerifyTable(TopoData()) &&
           VerifyField<int32_t>(verifier, VT_VO) &&
           VerifyField<int32_t>(verifier, VT_VN) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyVector(Matrix()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyOffset(verifier, VT_DEFDATA) &&
           verifier.VerifyTable(DefData()) &&
           VerifyOffset(verifier, VT_ARSDATA) &&
           verifier.VerifyTable(ArsData()) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyTable(D()) &&
           VerifyOffset(verifier, VT_EVD) &&
           verifier.VerifyVector(EVD()) &&
           VerifyOffset(verifier, VT_FOLDERCHILDREN) &&
           verifier.VerifyVector(FolderChildren()) &&
           VerifyOffset(verifier, VT_FOCUSVIEWBOX) &&
           verifier.VerifyVector(FocusViewBox()) &&
           VerifyOffset(verifier, VT_DS) &&
           verifier.VerifyVector(Ds()) &&
           verifier.VerifyVectorOfTables(Ds()) &&
           VerifyOffset(verifier, VT_GROUPID) &&
           verifier.VerifyString(GroupID()) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyOffset(verifier, VT_GROUPNAME) &&
           verifier.VerifyString(GroupName()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(Children()) &&
           VerifyOffset(verifier, VT_TABLEINFO) &&
           verifier.VerifyTable(TableInfo()) &&
           VerifyOffset(verifier, VT_BORDER) &&
           verifier.VerifyTable(Border()) &&
           VerifyField<int32_t>(verifier, VT_FOLDERID) &&
           VerifyOffset(verifier, VT_AREAHATCHDATA) &&
           verifier.VerifyTable(AreaHatchData()) &&
           verifier.EndTable();
  }
};

struct EntityDataBuilder {
  typedef EntityData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(EntityData::VT_ID, ID, 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(EntityData::VT_TYPE, Type, 0);
  }
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(EntityData::VT_FID, FID, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(EntityData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_Attr(flatbuffers::Offset<FlatBufferDocSpace::AttributeData> Attr) {
    fbb_.AddOffset(EntityData::VT_ATTR, Attr);
  }
  void add_TID(flatbuffers::Offset<flatbuffers::String> TID) {
    fbb_.AddOffset(EntityData::VT_TID, TID);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(EntityData::VT_NAME, Name);
  }
  void add_OFID(int32_t OFID) {
    fbb_.AddElement<int32_t>(EntityData::VT_OFID, OFID, 0);
  }
  void add_TopoData(flatbuffers::Offset<FlatBufferDocSpace::SolidSketchTopoData> TopoData) {
    fbb_.AddOffset(EntityData::VT_TOPODATA, TopoData);
  }
  void add_VO(int32_t VO) {
    fbb_.AddElement<int32_t>(EntityData::VT_VO, VO, 0);
  }
  void add_VN(int32_t VN) {
    fbb_.AddElement<int32_t>(EntityData::VT_VN, VN, 0);
  }
  void add_Matrix(flatbuffers::Offset<flatbuffers::Vector<double>> Matrix) {
    fbb_.AddOffset(EntityData::VT_MATRIX, Matrix);
  }
  void add_Status(bool Status) {
    fbb_.AddElement<uint8_t>(EntityData::VT_STATUS, static_cast<uint8_t>(Status), 0);
  }
  void add_Active(bool Active) {
    fbb_.AddElement<uint8_t>(EntityData::VT_ACTIVE, static_cast<uint8_t>(Active), 0);
  }
  void add_DefData(flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage> DefData) {
    fbb_.AddOffset(EntityData::VT_DEFDATA, DefData);
  }
  void add_ArsData(flatbuffers::Offset<FlatBufferDocSpace::ArsDataMessage> ArsData) {
    fbb_.AddOffset(EntityData::VT_ARSDATA, ArsData);
  }
  void add_D(flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> D) {
    fbb_.AddOffset(EntityData::VT_D, D);
  }
  void add_EVD(flatbuffers::Offset<flatbuffers::Vector<float>> EVD) {
    fbb_.AddOffset(EntityData::VT_EVD, EVD);
  }
  void add_FolderChildren(flatbuffers::Offset<flatbuffers::Vector<int32_t>> FolderChildren) {
    fbb_.AddOffset(EntityData::VT_FOLDERCHILDREN, FolderChildren);
  }
  void add_FocusViewBox(flatbuffers::Offset<flatbuffers::Vector<float>> FocusViewBox) {
    fbb_.AddOffset(EntityData::VT_FOCUSVIEWBOX, FocusViewBox);
  }
  void add_Ds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteGroupData>>> Ds) {
    fbb_.AddOffset(EntityData::VT_DS, Ds);
  }
  void add_GroupID(flatbuffers::Offset<flatbuffers::String> GroupID) {
    fbb_.AddOffset(EntityData::VT_GROUPID, GroupID);
  }
  void add_T(int32_t T) {
    fbb_.AddElement<int32_t>(EntityData::VT_T, T, 0);
  }
  void add_GroupName(flatbuffers::Offset<flatbuffers::String> GroupName) {
    fbb_.AddOffset(EntityData::VT_GROUPNAME, GroupName);
  }
  void add_Children(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Children) {
    fbb_.AddOffset(EntityData::VT_CHILDREN, Children);
  }
  void add_TableInfo(flatbuffers::Offset<FlatBufferDocSpace::TableInfoData> TableInfo) {
    fbb_.AddOffset(EntityData::VT_TABLEINFO, TableInfo);
  }
  void add_Border(flatbuffers::Offset<FlatBufferDocSpace::BorderData> Border) {
    fbb_.AddOffset(EntityData::VT_BORDER, Border);
  }
  void add_FolderID(int32_t FolderID) {
    fbb_.AddElement<int32_t>(EntityData::VT_FOLDERID, FolderID, 0);
  }
  void add_AreaHatchData(flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements> AreaHatchData) {
    fbb_.AddOffset(EntityData::VT_AREAHATCHDATA, AreaHatchData);
  }
  explicit EntityDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityDataBuilder &operator=(const EntityDataBuilder &);
  flatbuffers::Offset<EntityData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntityData>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityData> CreateEntityData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    flatbuffers::Offset<FlatBufferDocSpace::AttributeData> Attr = 0,
    flatbuffers::Offset<flatbuffers::String> TID = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t OFID = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SolidSketchTopoData> TopoData = 0,
    int32_t VO = 0,
    int32_t VN = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Matrix = 0,
    bool Status = false,
    bool Active = false,
    flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage> DefData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ArsDataMessage> ArsData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> D = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> EVD = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> FolderChildren = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> FocusViewBox = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteGroupData>>> Ds = 0,
    flatbuffers::Offset<flatbuffers::String> GroupID = 0,
    int32_t T = 0,
    flatbuffers::Offset<flatbuffers::String> GroupName = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Children = 0,
    flatbuffers::Offset<FlatBufferDocSpace::TableInfoData> TableInfo = 0,
    flatbuffers::Offset<FlatBufferDocSpace::BorderData> Border = 0,
    int32_t FolderID = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements> AreaHatchData = 0) {
  EntityDataBuilder builder_(_fbb);
  builder_.add_AreaHatchData(AreaHatchData);
  builder_.add_FolderID(FolderID);
  builder_.add_Border(Border);
  builder_.add_TableInfo(TableInfo);
  builder_.add_Children(Children);
  builder_.add_GroupName(GroupName);
  builder_.add_T(T);
  builder_.add_GroupID(GroupID);
  builder_.add_Ds(Ds);
  builder_.add_FocusViewBox(FocusViewBox);
  builder_.add_FolderChildren(FolderChildren);
  builder_.add_EVD(EVD);
  builder_.add_D(D);
  builder_.add_ArsData(ArsData);
  builder_.add_DefData(DefData);
  builder_.add_Matrix(Matrix);
  builder_.add_VN(VN);
  builder_.add_VO(VO);
  builder_.add_TopoData(TopoData);
  builder_.add_OFID(OFID);
  builder_.add_Name(Name);
  builder_.add_TID(TID);
  builder_.add_Attr(Attr);
  builder_.add_FID(FID);
  builder_.add_Type(Type);
  builder_.add_ID(ID);
  builder_.add_Active(Active);
  builder_.add_Status(Status);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<EntityData> CreateEntityDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    flatbuffers::Offset<FlatBufferDocSpace::AttributeData> Attr = 0,
    const char *TID = nullptr,
    const char *Name = nullptr,
    int32_t OFID = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SolidSketchTopoData> TopoData = 0,
    int32_t VO = 0,
    int32_t VN = 0,
    const std::vector<double> *Matrix = nullptr,
    bool Status = false,
    bool Active = false,
    flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage> DefData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ArsDataMessage> ArsData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> D = 0,
    const std::vector<float> *EVD = nullptr,
    const std::vector<int32_t> *FolderChildren = nullptr,
    const std::vector<float> *FocusViewBox = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteGroupData>> *Ds = nullptr,
    const char *GroupID = nullptr,
    int32_t T = 0,
    const char *GroupName = nullptr,
    const std::vector<int32_t> *Children = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::TableInfoData> TableInfo = 0,
    flatbuffers::Offset<FlatBufferDocSpace::BorderData> Border = 0,
    int32_t FolderID = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements> AreaHatchData = 0) {
  auto TID__ = TID ? _fbb.CreateString(TID) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Matrix__ = Matrix ? _fbb.CreateVector<double>(*Matrix) : 0;
  auto EVD__ = EVD ? _fbb.CreateVector<float>(*EVD) : 0;
  auto FolderChildren__ = FolderChildren ? _fbb.CreateVector<int32_t>(*FolderChildren) : 0;
  auto FocusViewBox__ = FocusViewBox ? _fbb.CreateVector<float>(*FocusViewBox) : 0;
  auto Ds__ = Ds ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteGroupData>>(*Ds) : 0;
  auto GroupID__ = GroupID ? _fbb.CreateString(GroupID) : 0;
  auto GroupName__ = GroupName ? _fbb.CreateString(GroupName) : 0;
  auto Children__ = Children ? _fbb.CreateVector<int32_t>(*Children) : 0;
  return FlatBufferDocSpace::CreateEntityData(
      _fbb,
      ID,
      Type,
      FID,
      Visible,
      Attr,
      TID__,
      Name__,
      OFID,
      TopoData,
      VO,
      VN,
      Matrix__,
      Status,
      Active,
      DefData,
      ArsData,
      D,
      EVD__,
      FolderChildren__,
      FocusViewBox__,
      Ds__,
      GroupID__,
      T,
      GroupName__,
      Children__,
      TableInfo,
      Border,
      FolderID,
      AreaHatchData);
}

struct SimulationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimulationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  FlatBufferDocSpace::SimulationEntityData Value_type() const {
    return static_cast<FlatBufferDocSpace::SimulationEntityData>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *Value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *Value_as() const;
  const FlatBufferDocSpace::StudyData *Value_as_StudyData() const {
    return Value_type() == FlatBufferDocSpace::SimulationEntityData_StudyData ? static_cast<const FlatBufferDocSpace::StudyData *>(Value()) : nullptr;
  }
  const FlatBufferDocSpace::ExternalLoadsData *Value_as_ExternalLoadsData() const {
    return Value_type() == FlatBufferDocSpace::SimulationEntityData_ExternalLoadsData ? static_cast<const FlatBufferDocSpace::ExternalLoadsData *>(Value()) : nullptr;
  }
  const FlatBufferDocSpace::FixturesData *Value_as_FixturesData() const {
    return Value_type() == FlatBufferDocSpace::SimulationEntityData_FixturesData ? static_cast<const FlatBufferDocSpace::FixturesData *>(Value()) : nullptr;
  }
  const FlatBufferDocSpace::SimulationMaterialData *Value_as_SimulationMaterialData() const {
    return Value_type() == FlatBufferDocSpace::SimulationEntityData_SimulationMaterialData ? static_cast<const FlatBufferDocSpace::SimulationMaterialData *>(Value()) : nullptr;
  }
  const FlatBufferDocSpace::SimulationGridData *Value_as_SimulationGridData() const {
    return Value_type() == FlatBufferDocSpace::SimulationEntityData_SimulationGridData ? static_cast<const FlatBufferDocSpace::SimulationGridData *>(Value()) : nullptr;
  }
  const FlatBufferDocSpace::ConnectionData *Value_as_ConnectionData() const {
    return Value_type() == FlatBufferDocSpace::SimulationEntityData_ConnectionData ? static_cast<const FlatBufferDocSpace::ConnectionData *>(Value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifySimulationEntityData(verifier, Value(), Value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FlatBufferDocSpace::StudyData *SimulationData::Value_as<FlatBufferDocSpace::StudyData>() const {
  return Value_as_StudyData();
}

template<> inline const FlatBufferDocSpace::ExternalLoadsData *SimulationData::Value_as<FlatBufferDocSpace::ExternalLoadsData>() const {
  return Value_as_ExternalLoadsData();
}

template<> inline const FlatBufferDocSpace::FixturesData *SimulationData::Value_as<FlatBufferDocSpace::FixturesData>() const {
  return Value_as_FixturesData();
}

template<> inline const FlatBufferDocSpace::SimulationMaterialData *SimulationData::Value_as<FlatBufferDocSpace::SimulationMaterialData>() const {
  return Value_as_SimulationMaterialData();
}

template<> inline const FlatBufferDocSpace::SimulationGridData *SimulationData::Value_as<FlatBufferDocSpace::SimulationGridData>() const {
  return Value_as_SimulationGridData();
}

template<> inline const FlatBufferDocSpace::ConnectionData *SimulationData::Value_as<FlatBufferDocSpace::ConnectionData>() const {
  return Value_as_ConnectionData();
}

struct SimulationDataBuilder {
  typedef SimulationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value_type(FlatBufferDocSpace::SimulationEntityData Value_type) {
    fbb_.AddElement<uint8_t>(SimulationData::VT_VALUE_TYPE, static_cast<uint8_t>(Value_type), 0);
  }
  void add_Value(flatbuffers::Offset<void> Value) {
    fbb_.AddOffset(SimulationData::VT_VALUE, Value);
  }
  explicit SimulationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimulationDataBuilder &operator=(const SimulationDataBuilder &);
  flatbuffers::Offset<SimulationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimulationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimulationData> CreateSimulationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::SimulationEntityData Value_type = FlatBufferDocSpace::SimulationEntityData_NONE,
    flatbuffers::Offset<void> Value = 0) {
  SimulationDataBuilder builder_(_fbb);
  builder_.add_Value(Value);
  builder_.add_Value_type(Value_type);
  return builder_.Finish();
}

struct PreviewSimulationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PreviewSimulationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIMULATIONGRID = 4
  };
  const FlatBufferDocSpace::SimulationGridData *SimulationGrid() const {
    return GetPointer<const FlatBufferDocSpace::SimulationGridData *>(VT_SIMULATIONGRID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SIMULATIONGRID) &&
           verifier.VerifyTable(SimulationGrid()) &&
           verifier.EndTable();
  }
};

struct PreviewSimulationDataBuilder {
  typedef PreviewSimulationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SimulationGrid(flatbuffers::Offset<FlatBufferDocSpace::SimulationGridData> SimulationGrid) {
    fbb_.AddOffset(PreviewSimulationData::VT_SIMULATIONGRID, SimulationGrid);
  }
  explicit PreviewSimulationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PreviewSimulationDataBuilder &operator=(const PreviewSimulationDataBuilder &);
  flatbuffers::Offset<PreviewSimulationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PreviewSimulationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PreviewSimulationData> CreatePreviewSimulationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::SimulationGridData> SimulationGrid = 0) {
  PreviewSimulationDataBuilder builder_(_fbb);
  builder_.add_SimulationGrid(SimulationGrid);
  return builder_.Finish();
}

struct StudyData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StudyDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_FID = 8,
    VT_VISIBLE = 10,
    VT_STATUS = 12,
    VT_NAME = 14,
    VT_ACTIVATE = 16,
    VT_EXPIRE = 18,
    VT_SOLVEENTITYIDS = 20,
    VT_SIMULATIONGRIDIDS = 22,
    VT_EXTERNALLOADIDS = 24,
    VT_FIXTUREIDS = 26,
    VT_SIMULATIONMATERIALIDS = 28,
    VT_CONNECTIONIDS = 30,
    VT_LARGEDISPLACEMENT = 32,
    VT_INERTIALRELIEF = 34,
    VT_GLOBALGRIDPRECISION = 36,
    VT_LOCALGRIDPRECISION = 38,
    VT_LOCALELEMENTIDS = 40,
    VT_LOCALGRIDNAMES = 42
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool Status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Activate() const {
    return GetField<uint8_t>(VT_ACTIVATE, 0) != 0;
  }
  int32_t Expire() const {
    return GetField<int32_t>(VT_EXPIRE, 0);
  }
  const flatbuffers::Vector<int32_t> *SolveEntityIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SOLVEENTITYIDS);
  }
  const flatbuffers::Vector<int32_t> *SimulationGridIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIMULATIONGRIDIDS);
  }
  const flatbuffers::Vector<int32_t> *ExternalLoadIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EXTERNALLOADIDS);
  }
  const flatbuffers::Vector<int32_t> *FixtureIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FIXTUREIDS);
  }
  const flatbuffers::Vector<int32_t> *SimulationMaterialIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIMULATIONMATERIALIDS);
  }
  const flatbuffers::Vector<int32_t> *ConnectionIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CONNECTIONIDS);
  }
  int32_t LargeDisplacement() const {
    return GetField<int32_t>(VT_LARGEDISPLACEMENT, 0);
  }
  int32_t InertialRelief() const {
    return GetField<int32_t>(VT_INERTIALRELIEF, 0);
  }
  const flatbuffers::Vector<double> *GlobalGridPrecision() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_GLOBALGRIDPRECISION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridPrecision>> *LocalGridPrecision() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridPrecision>> *>(VT_LOCALGRIDPRECISION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridElementIds>> *LocalElementIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridElementIds>> *>(VT_LOCALELEMENTIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *LocalGridNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LOCALGRIDNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVATE) &&
           VerifyField<int32_t>(verifier, VT_EXPIRE) &&
           VerifyOffset(verifier, VT_SOLVEENTITYIDS) &&
           verifier.VerifyVector(SolveEntityIds()) &&
           VerifyOffset(verifier, VT_SIMULATIONGRIDIDS) &&
           verifier.VerifyVector(SimulationGridIds()) &&
           VerifyOffset(verifier, VT_EXTERNALLOADIDS) &&
           verifier.VerifyVector(ExternalLoadIds()) &&
           VerifyOffset(verifier, VT_FIXTUREIDS) &&
           verifier.VerifyVector(FixtureIds()) &&
           VerifyOffset(verifier, VT_SIMULATIONMATERIALIDS) &&
           verifier.VerifyVector(SimulationMaterialIds()) &&
           VerifyOffset(verifier, VT_CONNECTIONIDS) &&
           verifier.VerifyVector(ConnectionIds()) &&
           VerifyField<int32_t>(verifier, VT_LARGEDISPLACEMENT) &&
           VerifyField<int32_t>(verifier, VT_INERTIALRELIEF) &&
           VerifyOffset(verifier, VT_GLOBALGRIDPRECISION) &&
           verifier.VerifyVector(GlobalGridPrecision()) &&
           VerifyOffset(verifier, VT_LOCALGRIDPRECISION) &&
           verifier.VerifyVector(LocalGridPrecision()) &&
           verifier.VerifyVectorOfTables(LocalGridPrecision()) &&
           VerifyOffset(verifier, VT_LOCALELEMENTIDS) &&
           verifier.VerifyVector(LocalElementIds()) &&
           verifier.VerifyVectorOfTables(LocalElementIds()) &&
           VerifyOffset(verifier, VT_LOCALGRIDNAMES) &&
           verifier.VerifyVector(LocalGridNames()) &&
           verifier.VerifyVectorOfStrings(LocalGridNames()) &&
           verifier.EndTable();
  }
};

struct StudyDataBuilder {
  typedef StudyData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(StudyData::VT_ID, ID, 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(StudyData::VT_TYPE, Type, 0);
  }
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(StudyData::VT_FID, FID, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(StudyData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_Status(bool Status) {
    fbb_.AddElement<uint8_t>(StudyData::VT_STATUS, static_cast<uint8_t>(Status), 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(StudyData::VT_NAME, Name);
  }
  void add_Activate(bool Activate) {
    fbb_.AddElement<uint8_t>(StudyData::VT_ACTIVATE, static_cast<uint8_t>(Activate), 0);
  }
  void add_Expire(int32_t Expire) {
    fbb_.AddElement<int32_t>(StudyData::VT_EXPIRE, Expire, 0);
  }
  void add_SolveEntityIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> SolveEntityIds) {
    fbb_.AddOffset(StudyData::VT_SOLVEENTITYIDS, SolveEntityIds);
  }
  void add_SimulationGridIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> SimulationGridIds) {
    fbb_.AddOffset(StudyData::VT_SIMULATIONGRIDIDS, SimulationGridIds);
  }
  void add_ExternalLoadIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ExternalLoadIds) {
    fbb_.AddOffset(StudyData::VT_EXTERNALLOADIDS, ExternalLoadIds);
  }
  void add_FixtureIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> FixtureIds) {
    fbb_.AddOffset(StudyData::VT_FIXTUREIDS, FixtureIds);
  }
  void add_SimulationMaterialIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> SimulationMaterialIds) {
    fbb_.AddOffset(StudyData::VT_SIMULATIONMATERIALIDS, SimulationMaterialIds);
  }
  void add_ConnectionIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ConnectionIds) {
    fbb_.AddOffset(StudyData::VT_CONNECTIONIDS, ConnectionIds);
  }
  void add_LargeDisplacement(int32_t LargeDisplacement) {
    fbb_.AddElement<int32_t>(StudyData::VT_LARGEDISPLACEMENT, LargeDisplacement, 0);
  }
  void add_InertialRelief(int32_t InertialRelief) {
    fbb_.AddElement<int32_t>(StudyData::VT_INERTIALRELIEF, InertialRelief, 0);
  }
  void add_GlobalGridPrecision(flatbuffers::Offset<flatbuffers::Vector<double>> GlobalGridPrecision) {
    fbb_.AddOffset(StudyData::VT_GLOBALGRIDPRECISION, GlobalGridPrecision);
  }
  void add_LocalGridPrecision(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridPrecision>>> LocalGridPrecision) {
    fbb_.AddOffset(StudyData::VT_LOCALGRIDPRECISION, LocalGridPrecision);
  }
  void add_LocalElementIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridElementIds>>> LocalElementIds) {
    fbb_.AddOffset(StudyData::VT_LOCALELEMENTIDS, LocalElementIds);
  }
  void add_LocalGridNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> LocalGridNames) {
    fbb_.AddOffset(StudyData::VT_LOCALGRIDNAMES, LocalGridNames);
  }
  explicit StudyDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StudyDataBuilder &operator=(const StudyDataBuilder &);
  flatbuffers::Offset<StudyData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StudyData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StudyData> CreateStudyData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    bool Activate = false,
    int32_t Expire = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> SolveEntityIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> SimulationGridIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ExternalLoadIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> FixtureIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> SimulationMaterialIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ConnectionIds = 0,
    int32_t LargeDisplacement = 0,
    int32_t InertialRelief = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> GlobalGridPrecision = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridPrecision>>> LocalGridPrecision = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridElementIds>>> LocalElementIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> LocalGridNames = 0) {
  StudyDataBuilder builder_(_fbb);
  builder_.add_LocalGridNames(LocalGridNames);
  builder_.add_LocalElementIds(LocalElementIds);
  builder_.add_LocalGridPrecision(LocalGridPrecision);
  builder_.add_GlobalGridPrecision(GlobalGridPrecision);
  builder_.add_InertialRelief(InertialRelief);
  builder_.add_LargeDisplacement(LargeDisplacement);
  builder_.add_ConnectionIds(ConnectionIds);
  builder_.add_SimulationMaterialIds(SimulationMaterialIds);
  builder_.add_FixtureIds(FixtureIds);
  builder_.add_ExternalLoadIds(ExternalLoadIds);
  builder_.add_SimulationGridIds(SimulationGridIds);
  builder_.add_SolveEntityIds(SolveEntityIds);
  builder_.add_Expire(Expire);
  builder_.add_Name(Name);
  builder_.add_FID(FID);
  builder_.add_Type(Type);
  builder_.add_ID(ID);
  builder_.add_Activate(Activate);
  builder_.add_Status(Status);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<StudyData> CreateStudyDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    const char *Name = nullptr,
    bool Activate = false,
    int32_t Expire = 0,
    const std::vector<int32_t> *SolveEntityIds = nullptr,
    const std::vector<int32_t> *SimulationGridIds = nullptr,
    const std::vector<int32_t> *ExternalLoadIds = nullptr,
    const std::vector<int32_t> *FixtureIds = nullptr,
    const std::vector<int32_t> *SimulationMaterialIds = nullptr,
    const std::vector<int32_t> *ConnectionIds = nullptr,
    int32_t LargeDisplacement = 0,
    int32_t InertialRelief = 0,
    const std::vector<double> *GlobalGridPrecision = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridPrecision>> *LocalGridPrecision = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridElementIds>> *LocalElementIds = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *LocalGridNames = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto SolveEntityIds__ = SolveEntityIds ? _fbb.CreateVector<int32_t>(*SolveEntityIds) : 0;
  auto SimulationGridIds__ = SimulationGridIds ? _fbb.CreateVector<int32_t>(*SimulationGridIds) : 0;
  auto ExternalLoadIds__ = ExternalLoadIds ? _fbb.CreateVector<int32_t>(*ExternalLoadIds) : 0;
  auto FixtureIds__ = FixtureIds ? _fbb.CreateVector<int32_t>(*FixtureIds) : 0;
  auto SimulationMaterialIds__ = SimulationMaterialIds ? _fbb.CreateVector<int32_t>(*SimulationMaterialIds) : 0;
  auto ConnectionIds__ = ConnectionIds ? _fbb.CreateVector<int32_t>(*ConnectionIds) : 0;
  auto GlobalGridPrecision__ = GlobalGridPrecision ? _fbb.CreateVector<double>(*GlobalGridPrecision) : 0;
  auto LocalGridPrecision__ = LocalGridPrecision ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridPrecision>>(*LocalGridPrecision) : 0;
  auto LocalElementIds__ = LocalElementIds ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EveryLocalGridElementIds>>(*LocalElementIds) : 0;
  auto LocalGridNames__ = LocalGridNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*LocalGridNames) : 0;
  return FlatBufferDocSpace::CreateStudyData(
      _fbb,
      ID,
      Type,
      FID,
      Visible,
      Status,
      Name__,
      Activate,
      Expire,
      SolveEntityIds__,
      SimulationGridIds__,
      ExternalLoadIds__,
      FixtureIds__,
      SimulationMaterialIds__,
      ConnectionIds__,
      LargeDisplacement,
      InertialRelief,
      GlobalGridPrecision__,
      LocalGridPrecision__,
      LocalElementIds__,
      LocalGridNames__);
}

struct EveryLocalGridPrecision FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EveryLocalGridPrecisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRIDPRECISION = 4
  };
  const flatbuffers::Vector<double> *GridPrecision() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_GRIDPRECISION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRIDPRECISION) &&
           verifier.VerifyVector(GridPrecision()) &&
           verifier.EndTable();
  }
};

struct EveryLocalGridPrecisionBuilder {
  typedef EveryLocalGridPrecision Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GridPrecision(flatbuffers::Offset<flatbuffers::Vector<double>> GridPrecision) {
    fbb_.AddOffset(EveryLocalGridPrecision::VT_GRIDPRECISION, GridPrecision);
  }
  explicit EveryLocalGridPrecisionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EveryLocalGridPrecisionBuilder &operator=(const EveryLocalGridPrecisionBuilder &);
  flatbuffers::Offset<EveryLocalGridPrecision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EveryLocalGridPrecision>(end);
    return o;
  }
};

inline flatbuffers::Offset<EveryLocalGridPrecision> CreateEveryLocalGridPrecision(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> GridPrecision = 0) {
  EveryLocalGridPrecisionBuilder builder_(_fbb);
  builder_.add_GridPrecision(GridPrecision);
  return builder_.Finish();
}

inline flatbuffers::Offset<EveryLocalGridPrecision> CreateEveryLocalGridPrecisionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *GridPrecision = nullptr) {
  auto GridPrecision__ = GridPrecision ? _fbb.CreateVector<double>(*GridPrecision) : 0;
  return FlatBufferDocSpace::CreateEveryLocalGridPrecision(
      _fbb,
      GridPrecision__);
}

struct EveryLocalGridElementIds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EveryLocalGridElementIdsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRIDELEMENTIDS = 4
  };
  const flatbuffers::Vector<int32_t> *GridElementIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_GRIDELEMENTIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRIDELEMENTIDS) &&
           verifier.VerifyVector(GridElementIds()) &&
           verifier.EndTable();
  }
};

struct EveryLocalGridElementIdsBuilder {
  typedef EveryLocalGridElementIds Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GridElementIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> GridElementIds) {
    fbb_.AddOffset(EveryLocalGridElementIds::VT_GRIDELEMENTIDS, GridElementIds);
  }
  explicit EveryLocalGridElementIdsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EveryLocalGridElementIdsBuilder &operator=(const EveryLocalGridElementIdsBuilder &);
  flatbuffers::Offset<EveryLocalGridElementIds> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EveryLocalGridElementIds>(end);
    return o;
  }
};

inline flatbuffers::Offset<EveryLocalGridElementIds> CreateEveryLocalGridElementIds(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> GridElementIds = 0) {
  EveryLocalGridElementIdsBuilder builder_(_fbb);
  builder_.add_GridElementIds(GridElementIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<EveryLocalGridElementIds> CreateEveryLocalGridElementIdsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *GridElementIds = nullptr) {
  auto GridElementIds__ = GridElementIds ? _fbb.CreateVector<int32_t>(*GridElementIds) : 0;
  return FlatBufferDocSpace::CreateEveryLocalGridElementIds(
      _fbb,
      GridElementIds__);
}

struct ExternalLoadsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExternalLoadsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_FID = 8,
    VT_VISIBLE = 10,
    VT_STATUS = 12,
    VT_NAME = 14,
    VT_EXPIRE = 16,
    VT_EXTERNALLOADSTYPE = 18,
    VT_ACTELEMENTIDS = 20,
    VT_FORCE = 22,
    VT_DIRTYPE = 24,
    VT_DIR = 26,
    VT_REVERSEDIR = 28,
    VT_SUPPRESS = 30,
    VT_TORQUEAXIS = 32,
    VT_ISCHECK = 34,
    VT_DIRDATA = 36,
    VT_REMOTEPOSITIONS = 38,
    VT_COORDINATETYPE = 40,
    VT_CONNECTIONTYPE = 42,
    VT_WEIGHTFACTOR = 44
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool Status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t Expire() const {
    return GetField<int32_t>(VT_EXPIRE, 0);
  }
  int32_t ExternalLoadsType() const {
    return GetField<int32_t>(VT_EXTERNALLOADSTYPE, 0);
  }
  const flatbuffers::Vector<int32_t> *ActElementIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ACTELEMENTIDS);
  }
  double Force() const {
    return GetField<double>(VT_FORCE, 0.0);
  }
  int32_t DirType() const {
    return GetField<int32_t>(VT_DIRTYPE, 0);
  }
  const flatbuffers::Vector<double> *Dir() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIR);
  }
  bool ReverseDir() const {
    return GetField<uint8_t>(VT_REVERSEDIR, 0) != 0;
  }
  int32_t Suppress() const {
    return GetField<int32_t>(VT_SUPPRESS, 0);
  }
  const FlatBufferDocSpace::TorqueAxisData *TorqueAxis() const {
    return GetPointer<const FlatBufferDocSpace::TorqueAxisData *>(VT_TORQUEAXIS);
  }
  int32_t IsCheck() const {
    return GetField<int32_t>(VT_ISCHECK, 0);
  }
  const flatbuffers::Vector<int32_t> *DirData() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIRDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *RemotePositions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_REMOTEPOSITIONS);
  }
  int32_t CoordinateType() const {
    return GetField<int32_t>(VT_COORDINATETYPE, 0);
  }
  int32_t ConnectionType() const {
    return GetField<int32_t>(VT_CONNECTIONTYPE, 0);
  }
  int32_t WeightFactor() const {
    return GetField<int32_t>(VT_WEIGHTFACTOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_EXPIRE) &&
           VerifyField<int32_t>(verifier, VT_EXTERNALLOADSTYPE) &&
           VerifyOffset(verifier, VT_ACTELEMENTIDS) &&
           verifier.VerifyVector(ActElementIds()) &&
           VerifyField<double>(verifier, VT_FORCE) &&
           VerifyField<int32_t>(verifier, VT_DIRTYPE) &&
           VerifyOffset(verifier, VT_DIR) &&
           verifier.VerifyVector(Dir()) &&
           VerifyField<uint8_t>(verifier, VT_REVERSEDIR) &&
           VerifyField<int32_t>(verifier, VT_SUPPRESS) &&
           VerifyOffset(verifier, VT_TORQUEAXIS) &&
           verifier.VerifyTable(TorqueAxis()) &&
           VerifyField<int32_t>(verifier, VT_ISCHECK) &&
           VerifyOffset(verifier, VT_DIRDATA) &&
           verifier.VerifyVector(DirData()) &&
           VerifyOffset(verifier, VT_REMOTEPOSITIONS) &&
           verifier.VerifyVector(RemotePositions()) &&
           verifier.VerifyVectorOfStrings(RemotePositions()) &&
           VerifyField<int32_t>(verifier, VT_COORDINATETYPE) &&
           VerifyField<int32_t>(verifier, VT_CONNECTIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTFACTOR) &&
           verifier.EndTable();
  }
};

struct ExternalLoadsDataBuilder {
  typedef ExternalLoadsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_ID, ID, 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_TYPE, Type, 0);
  }
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_FID, FID, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(ExternalLoadsData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_Status(bool Status) {
    fbb_.AddElement<uint8_t>(ExternalLoadsData::VT_STATUS, static_cast<uint8_t>(Status), 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(ExternalLoadsData::VT_NAME, Name);
  }
  void add_Expire(int32_t Expire) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_EXPIRE, Expire, 0);
  }
  void add_ExternalLoadsType(int32_t ExternalLoadsType) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_EXTERNALLOADSTYPE, ExternalLoadsType, 0);
  }
  void add_ActElementIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ActElementIds) {
    fbb_.AddOffset(ExternalLoadsData::VT_ACTELEMENTIDS, ActElementIds);
  }
  void add_Force(double Force) {
    fbb_.AddElement<double>(ExternalLoadsData::VT_FORCE, Force, 0.0);
  }
  void add_DirType(int32_t DirType) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_DIRTYPE, DirType, 0);
  }
  void add_Dir(flatbuffers::Offset<flatbuffers::Vector<double>> Dir) {
    fbb_.AddOffset(ExternalLoadsData::VT_DIR, Dir);
  }
  void add_ReverseDir(bool ReverseDir) {
    fbb_.AddElement<uint8_t>(ExternalLoadsData::VT_REVERSEDIR, static_cast<uint8_t>(ReverseDir), 0);
  }
  void add_Suppress(int32_t Suppress) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_SUPPRESS, Suppress, 0);
  }
  void add_TorqueAxis(flatbuffers::Offset<FlatBufferDocSpace::TorqueAxisData> TorqueAxis) {
    fbb_.AddOffset(ExternalLoadsData::VT_TORQUEAXIS, TorqueAxis);
  }
  void add_IsCheck(int32_t IsCheck) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_ISCHECK, IsCheck, 0);
  }
  void add_DirData(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DirData) {
    fbb_.AddOffset(ExternalLoadsData::VT_DIRDATA, DirData);
  }
  void add_RemotePositions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RemotePositions) {
    fbb_.AddOffset(ExternalLoadsData::VT_REMOTEPOSITIONS, RemotePositions);
  }
  void add_CoordinateType(int32_t CoordinateType) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_COORDINATETYPE, CoordinateType, 0);
  }
  void add_ConnectionType(int32_t ConnectionType) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_CONNECTIONTYPE, ConnectionType, 0);
  }
  void add_WeightFactor(int32_t WeightFactor) {
    fbb_.AddElement<int32_t>(ExternalLoadsData::VT_WEIGHTFACTOR, WeightFactor, 0);
  }
  explicit ExternalLoadsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExternalLoadsDataBuilder &operator=(const ExternalLoadsDataBuilder &);
  flatbuffers::Offset<ExternalLoadsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExternalLoadsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExternalLoadsData> CreateExternalLoadsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t Expire = 0,
    int32_t ExternalLoadsType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ActElementIds = 0,
    double Force = 0.0,
    int32_t DirType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Dir = 0,
    bool ReverseDir = false,
    int32_t Suppress = 0,
    flatbuffers::Offset<FlatBufferDocSpace::TorqueAxisData> TorqueAxis = 0,
    int32_t IsCheck = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DirData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RemotePositions = 0,
    int32_t CoordinateType = 0,
    int32_t ConnectionType = 0,
    int32_t WeightFactor = 0) {
  ExternalLoadsDataBuilder builder_(_fbb);
  builder_.add_Force(Force);
  builder_.add_WeightFactor(WeightFactor);
  builder_.add_ConnectionType(ConnectionType);
  builder_.add_CoordinateType(CoordinateType);
  builder_.add_RemotePositions(RemotePositions);
  builder_.add_DirData(DirData);
  builder_.add_IsCheck(IsCheck);
  builder_.add_TorqueAxis(TorqueAxis);
  builder_.add_Suppress(Suppress);
  builder_.add_Dir(Dir);
  builder_.add_DirType(DirType);
  builder_.add_ActElementIds(ActElementIds);
  builder_.add_ExternalLoadsType(ExternalLoadsType);
  builder_.add_Expire(Expire);
  builder_.add_Name(Name);
  builder_.add_FID(FID);
  builder_.add_Type(Type);
  builder_.add_ID(ID);
  builder_.add_ReverseDir(ReverseDir);
  builder_.add_Status(Status);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExternalLoadsData> CreateExternalLoadsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    const char *Name = nullptr,
    int32_t Expire = 0,
    int32_t ExternalLoadsType = 0,
    const std::vector<int32_t> *ActElementIds = nullptr,
    double Force = 0.0,
    int32_t DirType = 0,
    const std::vector<double> *Dir = nullptr,
    bool ReverseDir = false,
    int32_t Suppress = 0,
    flatbuffers::Offset<FlatBufferDocSpace::TorqueAxisData> TorqueAxis = 0,
    int32_t IsCheck = 0,
    const std::vector<int32_t> *DirData = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *RemotePositions = nullptr,
    int32_t CoordinateType = 0,
    int32_t ConnectionType = 0,
    int32_t WeightFactor = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto ActElementIds__ = ActElementIds ? _fbb.CreateVector<int32_t>(*ActElementIds) : 0;
  auto Dir__ = Dir ? _fbb.CreateVector<double>(*Dir) : 0;
  auto DirData__ = DirData ? _fbb.CreateVector<int32_t>(*DirData) : 0;
  auto RemotePositions__ = RemotePositions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*RemotePositions) : 0;
  return FlatBufferDocSpace::CreateExternalLoadsData(
      _fbb,
      ID,
      Type,
      FID,
      Visible,
      Status,
      Name__,
      Expire,
      ExternalLoadsType,
      ActElementIds__,
      Force,
      DirType,
      Dir__,
      ReverseDir,
      Suppress,
      TorqueAxis,
      IsCheck,
      DirData__,
      RemotePositions__,
      CoordinateType,
      ConnectionType,
      WeightFactor);
}

struct TorqueAxisData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TorqueAxisDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STARTPNT = 4,
    VT_ENDPNT = 6,
    VT_ELEMENTIDS = 8
  };
  const flatbuffers::Vector<double> *StartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTPNT);
  }
  const flatbuffers::Vector<double> *EndPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDPNT);
  }
  const flatbuffers::Vector<int32_t> *ElementIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEMENTIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STARTPNT) &&
           verifier.VerifyVector(StartPnt()) &&
           VerifyOffset(verifier, VT_ENDPNT) &&
           verifier.VerifyVector(EndPnt()) &&
           VerifyOffset(verifier, VT_ELEMENTIDS) &&
           verifier.VerifyVector(ElementIds()) &&
           verifier.EndTable();
  }
};

struct TorqueAxisDataBuilder {
  typedef TorqueAxisData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_StartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt) {
    fbb_.AddOffset(TorqueAxisData::VT_STARTPNT, StartPnt);
  }
  void add_EndPnt(flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt) {
    fbb_.AddOffset(TorqueAxisData::VT_ENDPNT, EndPnt);
  }
  void add_ElementIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ElementIds) {
    fbb_.AddOffset(TorqueAxisData::VT_ELEMENTIDS, ElementIds);
  }
  explicit TorqueAxisDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TorqueAxisDataBuilder &operator=(const TorqueAxisDataBuilder &);
  flatbuffers::Offset<TorqueAxisData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TorqueAxisData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TorqueAxisData> CreateTorqueAxisData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ElementIds = 0) {
  TorqueAxisDataBuilder builder_(_fbb);
  builder_.add_ElementIds(ElementIds);
  builder_.add_EndPnt(EndPnt);
  builder_.add_StartPnt(StartPnt);
  return builder_.Finish();
}

inline flatbuffers::Offset<TorqueAxisData> CreateTorqueAxisDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *StartPnt = nullptr,
    const std::vector<double> *EndPnt = nullptr,
    const std::vector<int32_t> *ElementIds = nullptr) {
  auto StartPnt__ = StartPnt ? _fbb.CreateVector<double>(*StartPnt) : 0;
  auto EndPnt__ = EndPnt ? _fbb.CreateVector<double>(*EndPnt) : 0;
  auto ElementIds__ = ElementIds ? _fbb.CreateVector<int32_t>(*ElementIds) : 0;
  return FlatBufferDocSpace::CreateTorqueAxisData(
      _fbb,
      StartPnt__,
      EndPnt__,
      ElementIds__);
}

struct FixturesData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FixturesDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_FID = 8,
    VT_VISIBLE = 10,
    VT_STATUS = 12,
    VT_NAME = 14,
    VT_EXPIRE = 16,
    VT_FIXELEMENTTYPE = 18,
    VT_ACTELEMENTIDS = 20,
    VT_ACTFREEDOMPARAMS = 22,
    VT_SUPPRESS = 24
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool Status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t Expire() const {
    return GetField<int32_t>(VT_EXPIRE, 0);
  }
  int32_t FixElementType() const {
    return GetField<int32_t>(VT_FIXELEMENTTYPE, 0);
  }
  const flatbuffers::Vector<int32_t> *ActElementIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ACTELEMENTIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *ActFreedomParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ACTFREEDOMPARAMS);
  }
  int32_t Suppress() const {
    return GetField<int32_t>(VT_SUPPRESS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_EXPIRE) &&
           VerifyField<int32_t>(verifier, VT_FIXELEMENTTYPE) &&
           VerifyOffset(verifier, VT_ACTELEMENTIDS) &&
           verifier.VerifyVector(ActElementIds()) &&
           VerifyOffset(verifier, VT_ACTFREEDOMPARAMS) &&
           verifier.VerifyVector(ActFreedomParams()) &&
           verifier.VerifyVectorOfStrings(ActFreedomParams()) &&
           VerifyField<int32_t>(verifier, VT_SUPPRESS) &&
           verifier.EndTable();
  }
};

struct FixturesDataBuilder {
  typedef FixturesData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(FixturesData::VT_ID, ID, 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(FixturesData::VT_TYPE, Type, 0);
  }
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(FixturesData::VT_FID, FID, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(FixturesData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_Status(bool Status) {
    fbb_.AddElement<uint8_t>(FixturesData::VT_STATUS, static_cast<uint8_t>(Status), 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(FixturesData::VT_NAME, Name);
  }
  void add_Expire(int32_t Expire) {
    fbb_.AddElement<int32_t>(FixturesData::VT_EXPIRE, Expire, 0);
  }
  void add_FixElementType(int32_t FixElementType) {
    fbb_.AddElement<int32_t>(FixturesData::VT_FIXELEMENTTYPE, FixElementType, 0);
  }
  void add_ActElementIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ActElementIds) {
    fbb_.AddOffset(FixturesData::VT_ACTELEMENTIDS, ActElementIds);
  }
  void add_ActFreedomParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ActFreedomParams) {
    fbb_.AddOffset(FixturesData::VT_ACTFREEDOMPARAMS, ActFreedomParams);
  }
  void add_Suppress(int32_t Suppress) {
    fbb_.AddElement<int32_t>(FixturesData::VT_SUPPRESS, Suppress, 0);
  }
  explicit FixturesDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FixturesDataBuilder &operator=(const FixturesDataBuilder &);
  flatbuffers::Offset<FixturesData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FixturesData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FixturesData> CreateFixturesData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t Expire = 0,
    int32_t FixElementType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ActElementIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ActFreedomParams = 0,
    int32_t Suppress = 0) {
  FixturesDataBuilder builder_(_fbb);
  builder_.add_Suppress(Suppress);
  builder_.add_ActFreedomParams(ActFreedomParams);
  builder_.add_ActElementIds(ActElementIds);
  builder_.add_FixElementType(FixElementType);
  builder_.add_Expire(Expire);
  builder_.add_Name(Name);
  builder_.add_FID(FID);
  builder_.add_Type(Type);
  builder_.add_ID(ID);
  builder_.add_Status(Status);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<FixturesData> CreateFixturesDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    const char *Name = nullptr,
    int32_t Expire = 0,
    int32_t FixElementType = 0,
    const std::vector<int32_t> *ActElementIds = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *ActFreedomParams = nullptr,
    int32_t Suppress = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto ActElementIds__ = ActElementIds ? _fbb.CreateVector<int32_t>(*ActElementIds) : 0;
  auto ActFreedomParams__ = ActFreedomParams ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*ActFreedomParams) : 0;
  return FlatBufferDocSpace::CreateFixturesData(
      _fbb,
      ID,
      Type,
      FID,
      Visible,
      Status,
      Name__,
      Expire,
      FixElementType,
      ActElementIds__,
      ActFreedomParams__,
      Suppress);
}

struct SimulationMaterialData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimulationMaterialDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_FID = 8,
    VT_VISIBLE = 10,
    VT_STATUS = 12,
    VT_NAME = 14,
    VT_ENTITYIDS = 16,
    VT_MATERIALIDS = 18
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool Status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<int32_t> *EntityIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENTITYIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *MaterialIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_ENTITYIDS) &&
           verifier.VerifyVector(EntityIds()) &&
           VerifyOffset(verifier, VT_MATERIALIDS) &&
           verifier.VerifyVector(MaterialIds()) &&
           verifier.VerifyVectorOfStrings(MaterialIds()) &&
           verifier.EndTable();
  }
};

struct SimulationMaterialDataBuilder {
  typedef SimulationMaterialData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(SimulationMaterialData::VT_ID, ID, 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(SimulationMaterialData::VT_TYPE, Type, 0);
  }
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(SimulationMaterialData::VT_FID, FID, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(SimulationMaterialData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_Status(bool Status) {
    fbb_.AddElement<uint8_t>(SimulationMaterialData::VT_STATUS, static_cast<uint8_t>(Status), 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(SimulationMaterialData::VT_NAME, Name);
  }
  void add_EntityIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> EntityIds) {
    fbb_.AddOffset(SimulationMaterialData::VT_ENTITYIDS, EntityIds);
  }
  void add_MaterialIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> MaterialIds) {
    fbb_.AddOffset(SimulationMaterialData::VT_MATERIALIDS, MaterialIds);
  }
  explicit SimulationMaterialDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimulationMaterialDataBuilder &operator=(const SimulationMaterialDataBuilder &);
  flatbuffers::Offset<SimulationMaterialData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimulationMaterialData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimulationMaterialData> CreateSimulationMaterialData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> EntityIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> MaterialIds = 0) {
  SimulationMaterialDataBuilder builder_(_fbb);
  builder_.add_MaterialIds(MaterialIds);
  builder_.add_EntityIds(EntityIds);
  builder_.add_Name(Name);
  builder_.add_FID(FID);
  builder_.add_Type(Type);
  builder_.add_ID(ID);
  builder_.add_Status(Status);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<SimulationMaterialData> CreateSimulationMaterialDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    const char *Name = nullptr,
    const std::vector<int32_t> *EntityIds = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *MaterialIds = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto EntityIds__ = EntityIds ? _fbb.CreateVector<int32_t>(*EntityIds) : 0;
  auto MaterialIds__ = MaterialIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*MaterialIds) : 0;
  return FlatBufferDocSpace::CreateSimulationMaterialData(
      _fbb,
      ID,
      Type,
      FID,
      Visible,
      Status,
      Name__,
      EntityIds__,
      MaterialIds__);
}

struct SimulationGridData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimulationGridDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_FID = 8,
    VT_VISIBLE = 10,
    VT_STATUS = 12,
    VT_NAME = 14,
    VT_ENTITYID = 16,
    VT_PRECISION = 18,
    VT_D = 20
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool Status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t EntityId() const {
    return GetField<int32_t>(VT_ENTITYID, 0);
  }
  double Precision() const {
    return GetField<double>(VT_PRECISION, 0.0);
  }
  const FlatBufferDocSpace::DiscreteInforData *D() const {
    return GetPointer<const FlatBufferDocSpace::DiscreteInforData *>(VT_D);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_ENTITYID) &&
           VerifyField<double>(verifier, VT_PRECISION) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyTable(D()) &&
           verifier.EndTable();
  }
};

struct SimulationGridDataBuilder {
  typedef SimulationGridData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(SimulationGridData::VT_ID, ID, 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(SimulationGridData::VT_TYPE, Type, 0);
  }
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(SimulationGridData::VT_FID, FID, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(SimulationGridData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_Status(bool Status) {
    fbb_.AddElement<uint8_t>(SimulationGridData::VT_STATUS, static_cast<uint8_t>(Status), 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(SimulationGridData::VT_NAME, Name);
  }
  void add_EntityId(int32_t EntityId) {
    fbb_.AddElement<int32_t>(SimulationGridData::VT_ENTITYID, EntityId, 0);
  }
  void add_Precision(double Precision) {
    fbb_.AddElement<double>(SimulationGridData::VT_PRECISION, Precision, 0.0);
  }
  void add_D(flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> D) {
    fbb_.AddOffset(SimulationGridData::VT_D, D);
  }
  explicit SimulationGridDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimulationGridDataBuilder &operator=(const SimulationGridDataBuilder &);
  flatbuffers::Offset<SimulationGridData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimulationGridData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimulationGridData> CreateSimulationGridData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t EntityId = 0,
    double Precision = 0.0,
    flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> D = 0) {
  SimulationGridDataBuilder builder_(_fbb);
  builder_.add_Precision(Precision);
  builder_.add_D(D);
  builder_.add_EntityId(EntityId);
  builder_.add_Name(Name);
  builder_.add_FID(FID);
  builder_.add_Type(Type);
  builder_.add_ID(ID);
  builder_.add_Status(Status);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<SimulationGridData> CreateSimulationGridDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    const char *Name = nullptr,
    int32_t EntityId = 0,
    double Precision = 0.0,
    flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> D = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  return FlatBufferDocSpace::CreateSimulationGridData(
      _fbb,
      ID,
      Type,
      FID,
      Visible,
      Status,
      Name__,
      EntityId,
      Precision,
      D);
}

struct ConnectionData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectionDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_FID = 8,
    VT_VISIBLE = 10,
    VT_STATUS = 12,
    VT_NAME = 14,
    VT_EXPIRE = 16,
    VT_CONNECTIONTYPE = 18,
    VT_SELECTTYPE = 20,
    VT_RADIOTYPE = 22,
    VT_BUTTONTYPE = 24,
    VT_VALPARAM1 = 26,
    VT_VALPARAM2 = 28,
    VT_MASSDENSITYVAL = 30,
    VT_YOUNGMODULUSVAL = 32,
    VT_POISSONRATIOVAL = 34,
    VT_FACEIDS1 = 36,
    VT_FACEIDS2 = 38,
    VT_SUPPRESS = 40,
    VT_MATERIALNAME = 42
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool Status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t Expire() const {
    return GetField<int32_t>(VT_EXPIRE, 0);
  }
  int32_t ConnectionType() const {
    return GetField<int32_t>(VT_CONNECTIONTYPE, 0);
  }
  int32_t SelectType() const {
    return GetField<int32_t>(VT_SELECTTYPE, 0);
  }
  int32_t RadioType() const {
    return GetField<int32_t>(VT_RADIOTYPE, 0);
  }
  int32_t ButtonType() const {
    return GetField<int32_t>(VT_BUTTONTYPE, 0);
  }
  double ValParam1() const {
    return GetField<double>(VT_VALPARAM1, 0.0);
  }
  double ValParam2() const {
    return GetField<double>(VT_VALPARAM2, 0.0);
  }
  double MassDensityVal() const {
    return GetField<double>(VT_MASSDENSITYVAL, 0.0);
  }
  double YoungModulusVal() const {
    return GetField<double>(VT_YOUNGMODULUSVAL, 0.0);
  }
  double PoissonRatioVal() const {
    return GetField<double>(VT_POISSONRATIOVAL, 0.0);
  }
  const flatbuffers::Vector<int32_t> *FaceIds1() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FACEIDS1);
  }
  const flatbuffers::Vector<int32_t> *FaceIds2() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FACEIDS2);
  }
  int32_t Suppress() const {
    return GetField<int32_t>(VT_SUPPRESS, 0);
  }
  const flatbuffers::String *MaterialName() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIALNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_EXPIRE) &&
           VerifyField<int32_t>(verifier, VT_CONNECTIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_SELECTTYPE) &&
           VerifyField<int32_t>(verifier, VT_RADIOTYPE) &&
           VerifyField<int32_t>(verifier, VT_BUTTONTYPE) &&
           VerifyField<double>(verifier, VT_VALPARAM1) &&
           VerifyField<double>(verifier, VT_VALPARAM2) &&
           VerifyField<double>(verifier, VT_MASSDENSITYVAL) &&
           VerifyField<double>(verifier, VT_YOUNGMODULUSVAL) &&
           VerifyField<double>(verifier, VT_POISSONRATIOVAL) &&
           VerifyOffset(verifier, VT_FACEIDS1) &&
           verifier.VerifyVector(FaceIds1()) &&
           VerifyOffset(verifier, VT_FACEIDS2) &&
           verifier.VerifyVector(FaceIds2()) &&
           VerifyField<int32_t>(verifier, VT_SUPPRESS) &&
           VerifyOffset(verifier, VT_MATERIALNAME) &&
           verifier.VerifyString(MaterialName()) &&
           verifier.EndTable();
  }
};

struct ConnectionDataBuilder {
  typedef ConnectionData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_ID, ID, 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_TYPE, Type, 0);
  }
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_FID, FID, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(ConnectionData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_Status(bool Status) {
    fbb_.AddElement<uint8_t>(ConnectionData::VT_STATUS, static_cast<uint8_t>(Status), 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(ConnectionData::VT_NAME, Name);
  }
  void add_Expire(int32_t Expire) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_EXPIRE, Expire, 0);
  }
  void add_ConnectionType(int32_t ConnectionType) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_CONNECTIONTYPE, ConnectionType, 0);
  }
  void add_SelectType(int32_t SelectType) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_SELECTTYPE, SelectType, 0);
  }
  void add_RadioType(int32_t RadioType) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_RADIOTYPE, RadioType, 0);
  }
  void add_ButtonType(int32_t ButtonType) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_BUTTONTYPE, ButtonType, 0);
  }
  void add_ValParam1(double ValParam1) {
    fbb_.AddElement<double>(ConnectionData::VT_VALPARAM1, ValParam1, 0.0);
  }
  void add_ValParam2(double ValParam2) {
    fbb_.AddElement<double>(ConnectionData::VT_VALPARAM2, ValParam2, 0.0);
  }
  void add_MassDensityVal(double MassDensityVal) {
    fbb_.AddElement<double>(ConnectionData::VT_MASSDENSITYVAL, MassDensityVal, 0.0);
  }
  void add_YoungModulusVal(double YoungModulusVal) {
    fbb_.AddElement<double>(ConnectionData::VT_YOUNGMODULUSVAL, YoungModulusVal, 0.0);
  }
  void add_PoissonRatioVal(double PoissonRatioVal) {
    fbb_.AddElement<double>(ConnectionData::VT_POISSONRATIOVAL, PoissonRatioVal, 0.0);
  }
  void add_FaceIds1(flatbuffers::Offset<flatbuffers::Vector<int32_t>> FaceIds1) {
    fbb_.AddOffset(ConnectionData::VT_FACEIDS1, FaceIds1);
  }
  void add_FaceIds2(flatbuffers::Offset<flatbuffers::Vector<int32_t>> FaceIds2) {
    fbb_.AddOffset(ConnectionData::VT_FACEIDS2, FaceIds2);
  }
  void add_Suppress(int32_t Suppress) {
    fbb_.AddElement<int32_t>(ConnectionData::VT_SUPPRESS, Suppress, 0);
  }
  void add_MaterialName(flatbuffers::Offset<flatbuffers::String> MaterialName) {
    fbb_.AddOffset(ConnectionData::VT_MATERIALNAME, MaterialName);
  }
  explicit ConnectionDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConnectionDataBuilder &operator=(const ConnectionDataBuilder &);
  flatbuffers::Offset<ConnectionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectionData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectionData> CreateConnectionData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t Expire = 0,
    int32_t ConnectionType = 0,
    int32_t SelectType = 0,
    int32_t RadioType = 0,
    int32_t ButtonType = 0,
    double ValParam1 = 0.0,
    double ValParam2 = 0.0,
    double MassDensityVal = 0.0,
    double YoungModulusVal = 0.0,
    double PoissonRatioVal = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> FaceIds1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> FaceIds2 = 0,
    int32_t Suppress = 0,
    flatbuffers::Offset<flatbuffers::String> MaterialName = 0) {
  ConnectionDataBuilder builder_(_fbb);
  builder_.add_PoissonRatioVal(PoissonRatioVal);
  builder_.add_YoungModulusVal(YoungModulusVal);
  builder_.add_MassDensityVal(MassDensityVal);
  builder_.add_ValParam2(ValParam2);
  builder_.add_ValParam1(ValParam1);
  builder_.add_MaterialName(MaterialName);
  builder_.add_Suppress(Suppress);
  builder_.add_FaceIds2(FaceIds2);
  builder_.add_FaceIds1(FaceIds1);
  builder_.add_ButtonType(ButtonType);
  builder_.add_RadioType(RadioType);
  builder_.add_SelectType(SelectType);
  builder_.add_ConnectionType(ConnectionType);
  builder_.add_Expire(Expire);
  builder_.add_Name(Name);
  builder_.add_FID(FID);
  builder_.add_Type(Type);
  builder_.add_ID(ID);
  builder_.add_Status(Status);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectionData> CreateConnectionDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    int32_t Type = 0,
    int32_t FID = 0,
    bool Visible = false,
    bool Status = false,
    const char *Name = nullptr,
    int32_t Expire = 0,
    int32_t ConnectionType = 0,
    int32_t SelectType = 0,
    int32_t RadioType = 0,
    int32_t ButtonType = 0,
    double ValParam1 = 0.0,
    double ValParam2 = 0.0,
    double MassDensityVal = 0.0,
    double YoungModulusVal = 0.0,
    double PoissonRatioVal = 0.0,
    const std::vector<int32_t> *FaceIds1 = nullptr,
    const std::vector<int32_t> *FaceIds2 = nullptr,
    int32_t Suppress = 0,
    const char *MaterialName = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto FaceIds1__ = FaceIds1 ? _fbb.CreateVector<int32_t>(*FaceIds1) : 0;
  auto FaceIds2__ = FaceIds2 ? _fbb.CreateVector<int32_t>(*FaceIds2) : 0;
  auto MaterialName__ = MaterialName ? _fbb.CreateString(MaterialName) : 0;
  return FlatBufferDocSpace::CreateConnectionData(
      _fbb,
      ID,
      Type,
      FID,
      Visible,
      Status,
      Name__,
      Expire,
      ConnectionType,
      SelectType,
      RadioType,
      ButtonType,
      ValParam1,
      ValParam2,
      MassDensityVal,
      YoungModulusVal,
      PoissonRatioVal,
      FaceIds1__,
      FaceIds2__,
      Suppress,
      MaterialName__);
}

struct DiscreteDatas FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DiscreteDatasBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *Datas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *>(VT_DATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATAS) &&
           verifier.VerifyVector(Datas()) &&
           verifier.VerifyVectorOfTables(Datas()) &&
           verifier.EndTable();
  }
};

struct DiscreteDatasBuilder {
  typedef DiscreteDatas Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Datas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>> Datas) {
    fbb_.AddOffset(DiscreteDatas::VT_DATAS, Datas);
  }
  explicit DiscreteDatasBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscreteDatasBuilder &operator=(const DiscreteDatasBuilder &);
  flatbuffers::Offset<DiscreteDatas> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DiscreteDatas>(end);
    return o;
  }
};

inline flatbuffers::Offset<DiscreteDatas> CreateDiscreteDatas(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>> Datas = 0) {
  DiscreteDatasBuilder builder_(_fbb);
  builder_.add_Datas(Datas);
  return builder_.Finish();
}

inline flatbuffers::Offset<DiscreteDatas> CreateDiscreteDatasDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *Datas = nullptr) {
  auto Datas__ = Datas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>(*Datas) : 0;
  return FlatBufferDocSpace::CreateDiscreteDatas(
      _fbb,
      Datas__);
}

struct BeadTextureData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BeadTextureDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PD = 4,
    VT_SD = 6,
    VT_LENA = 8,
    VT_RADIUS = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>> *PD() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>> *>(VT_PD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>> *SD() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>> *>(VT_SD);
  }
  const flatbuffers::Vector<double> *LenA() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_LENA);
  }
  double Radius() const {
    return GetField<double>(VT_RADIUS, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PD) &&
           verifier.VerifyVector(PD()) &&
           verifier.VerifyVectorOfTables(PD()) &&
           VerifyOffset(verifier, VT_SD) &&
           verifier.VerifyVector(SD()) &&
           verifier.VerifyVectorOfTables(SD()) &&
           VerifyOffset(verifier, VT_LENA) &&
           verifier.VerifyVector(LenA()) &&
           VerifyField<double>(verifier, VT_RADIUS) &&
           verifier.EndTable();
  }
};

struct BeadTextureDataBuilder {
  typedef BeadTextureData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PD(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>>> PD) {
    fbb_.AddOffset(BeadTextureData::VT_PD, PD);
  }
  void add_SD(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>>> SD) {
    fbb_.AddOffset(BeadTextureData::VT_SD, SD);
  }
  void add_LenA(flatbuffers::Offset<flatbuffers::Vector<double>> LenA) {
    fbb_.AddOffset(BeadTextureData::VT_LENA, LenA);
  }
  void add_Radius(double Radius) {
    fbb_.AddElement<double>(BeadTextureData::VT_RADIUS, Radius, 0.0);
  }
  explicit BeadTextureDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BeadTextureDataBuilder &operator=(const BeadTextureDataBuilder &);
  flatbuffers::Offset<BeadTextureData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BeadTextureData>(end);
    return o;
  }
};

inline flatbuffers::Offset<BeadTextureData> CreateBeadTextureData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>>> PD = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>>> SD = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> LenA = 0,
    double Radius = 0.0) {
  BeadTextureDataBuilder builder_(_fbb);
  builder_.add_Radius(Radius);
  builder_.add_LenA(LenA);
  builder_.add_SD(SD);
  builder_.add_PD(PD);
  return builder_.Finish();
}

inline flatbuffers::Offset<BeadTextureData> CreateBeadTextureDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>> *PD = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>> *SD = nullptr,
    const std::vector<double> *LenA = nullptr,
    double Radius = 0.0) {
  auto PD__ = PD ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>>(*PD) : 0;
  auto SD__ = SD ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteDatas>>(*SD) : 0;
  auto LenA__ = LenA ? _fbb.CreateVector<double>(*LenA) : 0;
  return FlatBufferDocSpace::CreateBeadTextureData(
      _fbb,
      PD__,
      SD__,
      LenA__,
      Radius);
}

struct FeatureData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FeatureDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_STATUS = 6,
    VT_TYPE = 8,
    VT_SUBTYPE = 10,
    VT_FLAG = 12,
    VT_NAME = 14,
    VT_INDEX = 16,
    VT_OPT = 18,
    VT_DIMENSIONVISBLE = 20,
    VT_PARENT = 22,
    VT_REFERSKETCHES = 24,
    VT_FOLDERCHILDREN = 26,
    VT_REFERENTITYS = 28,
    VT_GROUPNAME = 30,
    VT_FLATPATTERNCONNECT = 32,
    VT_VIEWINDEX = 34,
    VT_VIEWORDER = 36,
    VT_SHEETFLAG = 38,
    VT_EXTATTR = 40,
    VT_REFERENCESTATUS = 42
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *Status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *SubType() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBTYPE);
  }
  int32_t Flag() const {
    return GetField<int32_t>(VT_FLAG, 0);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *Index() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX);
  }
  const flatbuffers::String *Opt() const {
    return GetPointer<const flatbuffers::String *>(VT_OPT);
  }
  int32_t DimensionVisble() const {
    return GetField<int32_t>(VT_DIMENSIONVISBLE, 0);
  }
  int32_t Parent() const {
    return GetField<int32_t>(VT_PARENT, 0);
  }
  const flatbuffers::Vector<int32_t> *ReferSketches() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_REFERSKETCHES);
  }
  const flatbuffers::Vector<int32_t> *FolderChildren() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FOLDERCHILDREN);
  }
  const flatbuffers::Vector<int32_t> *ReferEntitys() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_REFERENTITYS);
  }
  const flatbuffers::String *GroupName() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUPNAME);
  }
  const flatbuffers::Vector<int32_t> *FlatPatternConnect() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FLATPATTERNCONNECT);
  }
  const flatbuffers::String *ViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWINDEX);
  }
  int32_t ViewOrder() const {
    return GetField<int32_t>(VT_VIEWORDER, 0);
  }
  int32_t SheetFlag() const {
    return GetField<int32_t>(VT_SHEETFLAG, 0);
  }
  const flatbuffers::String *ExtAttr() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTATTR);
  }
  int32_t ReferenceStatus() const {
    return GetField<int32_t>(VT_REFERENCESTATUS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(Status()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_SUBTYPE) &&
           verifier.VerifyString(SubType()) &&
           VerifyField<int32_t>(verifier, VT_FLAG) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(Index()) &&
           VerifyOffset(verifier, VT_OPT) &&
           verifier.VerifyString(Opt()) &&
           VerifyField<int32_t>(verifier, VT_DIMENSIONVISBLE) &&
           VerifyField<int32_t>(verifier, VT_PARENT) &&
           VerifyOffset(verifier, VT_REFERSKETCHES) &&
           verifier.VerifyVector(ReferSketches()) &&
           VerifyOffset(verifier, VT_FOLDERCHILDREN) &&
           verifier.VerifyVector(FolderChildren()) &&
           VerifyOffset(verifier, VT_REFERENTITYS) &&
           verifier.VerifyVector(ReferEntitys()) &&
           VerifyOffset(verifier, VT_GROUPNAME) &&
           verifier.VerifyString(GroupName()) &&
           VerifyOffset(verifier, VT_FLATPATTERNCONNECT) &&
           verifier.VerifyVector(FlatPatternConnect()) &&
           VerifyOffset(verifier, VT_VIEWINDEX) &&
           verifier.VerifyString(ViewIndex()) &&
           VerifyField<int32_t>(verifier, VT_VIEWORDER) &&
           VerifyField<int32_t>(verifier, VT_SHEETFLAG) &&
           VerifyOffset(verifier, VT_EXTATTR) &&
           verifier.VerifyString(ExtAttr()) &&
           VerifyField<int32_t>(verifier, VT_REFERENCESTATUS) &&
           verifier.EndTable();
  }
};

struct FeatureDataBuilder {
  typedef FeatureData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(FeatureData::VT_ID, ID, 0);
  }
  void add_Status(flatbuffers::Offset<flatbuffers::String> Status) {
    fbb_.AddOffset(FeatureData::VT_STATUS, Status);
  }
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(FeatureData::VT_TYPE, Type);
  }
  void add_SubType(flatbuffers::Offset<flatbuffers::String> SubType) {
    fbb_.AddOffset(FeatureData::VT_SUBTYPE, SubType);
  }
  void add_Flag(int32_t Flag) {
    fbb_.AddElement<int32_t>(FeatureData::VT_FLAG, Flag, 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(FeatureData::VT_NAME, Name);
  }
  void add_Index(flatbuffers::Offset<flatbuffers::String> Index) {
    fbb_.AddOffset(FeatureData::VT_INDEX, Index);
  }
  void add_Opt(flatbuffers::Offset<flatbuffers::String> Opt) {
    fbb_.AddOffset(FeatureData::VT_OPT, Opt);
  }
  void add_DimensionVisble(int32_t DimensionVisble) {
    fbb_.AddElement<int32_t>(FeatureData::VT_DIMENSIONVISBLE, DimensionVisble, 0);
  }
  void add_Parent(int32_t Parent) {
    fbb_.AddElement<int32_t>(FeatureData::VT_PARENT, Parent, 0);
  }
  void add_ReferSketches(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ReferSketches) {
    fbb_.AddOffset(FeatureData::VT_REFERSKETCHES, ReferSketches);
  }
  void add_FolderChildren(flatbuffers::Offset<flatbuffers::Vector<int32_t>> FolderChildren) {
    fbb_.AddOffset(FeatureData::VT_FOLDERCHILDREN, FolderChildren);
  }
  void add_ReferEntitys(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ReferEntitys) {
    fbb_.AddOffset(FeatureData::VT_REFERENTITYS, ReferEntitys);
  }
  void add_GroupName(flatbuffers::Offset<flatbuffers::String> GroupName) {
    fbb_.AddOffset(FeatureData::VT_GROUPNAME, GroupName);
  }
  void add_FlatPatternConnect(flatbuffers::Offset<flatbuffers::Vector<int32_t>> FlatPatternConnect) {
    fbb_.AddOffset(FeatureData::VT_FLATPATTERNCONNECT, FlatPatternConnect);
  }
  void add_ViewIndex(flatbuffers::Offset<flatbuffers::String> ViewIndex) {
    fbb_.AddOffset(FeatureData::VT_VIEWINDEX, ViewIndex);
  }
  void add_ViewOrder(int32_t ViewOrder) {
    fbb_.AddElement<int32_t>(FeatureData::VT_VIEWORDER, ViewOrder, 0);
  }
  void add_SheetFlag(int32_t SheetFlag) {
    fbb_.AddElement<int32_t>(FeatureData::VT_SHEETFLAG, SheetFlag, 0);
  }
  void add_ExtAttr(flatbuffers::Offset<flatbuffers::String> ExtAttr) {
    fbb_.AddOffset(FeatureData::VT_EXTATTR, ExtAttr);
  }
  void add_ReferenceStatus(int32_t ReferenceStatus) {
    fbb_.AddElement<int32_t>(FeatureData::VT_REFERENCESTATUS, ReferenceStatus, 0);
  }
  explicit FeatureDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FeatureDataBuilder &operator=(const FeatureDataBuilder &);
  flatbuffers::Offset<FeatureData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FeatureData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FeatureData> CreateFeatureData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    flatbuffers::Offset<flatbuffers::String> Status = 0,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::String> SubType = 0,
    int32_t Flag = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::String> Index = 0,
    flatbuffers::Offset<flatbuffers::String> Opt = 0,
    int32_t DimensionVisble = 0,
    int32_t Parent = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ReferSketches = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> FolderChildren = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ReferEntitys = 0,
    flatbuffers::Offset<flatbuffers::String> GroupName = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> FlatPatternConnect = 0,
    flatbuffers::Offset<flatbuffers::String> ViewIndex = 0,
    int32_t ViewOrder = 0,
    int32_t SheetFlag = 0,
    flatbuffers::Offset<flatbuffers::String> ExtAttr = 0,
    int32_t ReferenceStatus = 0) {
  FeatureDataBuilder builder_(_fbb);
  builder_.add_ReferenceStatus(ReferenceStatus);
  builder_.add_ExtAttr(ExtAttr);
  builder_.add_SheetFlag(SheetFlag);
  builder_.add_ViewOrder(ViewOrder);
  builder_.add_ViewIndex(ViewIndex);
  builder_.add_FlatPatternConnect(FlatPatternConnect);
  builder_.add_GroupName(GroupName);
  builder_.add_ReferEntitys(ReferEntitys);
  builder_.add_FolderChildren(FolderChildren);
  builder_.add_ReferSketches(ReferSketches);
  builder_.add_Parent(Parent);
  builder_.add_DimensionVisble(DimensionVisble);
  builder_.add_Opt(Opt);
  builder_.add_Index(Index);
  builder_.add_Name(Name);
  builder_.add_Flag(Flag);
  builder_.add_SubType(SubType);
  builder_.add_Type(Type);
  builder_.add_Status(Status);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<FeatureData> CreateFeatureDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    const char *Status = nullptr,
    const char *Type = nullptr,
    const char *SubType = nullptr,
    int32_t Flag = 0,
    const char *Name = nullptr,
    const char *Index = nullptr,
    const char *Opt = nullptr,
    int32_t DimensionVisble = 0,
    int32_t Parent = 0,
    const std::vector<int32_t> *ReferSketches = nullptr,
    const std::vector<int32_t> *FolderChildren = nullptr,
    const std::vector<int32_t> *ReferEntitys = nullptr,
    const char *GroupName = nullptr,
    const std::vector<int32_t> *FlatPatternConnect = nullptr,
    const char *ViewIndex = nullptr,
    int32_t ViewOrder = 0,
    int32_t SheetFlag = 0,
    const char *ExtAttr = nullptr,
    int32_t ReferenceStatus = 0) {
  auto Status__ = Status ? _fbb.CreateString(Status) : 0;
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto SubType__ = SubType ? _fbb.CreateString(SubType) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Index__ = Index ? _fbb.CreateString(Index) : 0;
  auto Opt__ = Opt ? _fbb.CreateString(Opt) : 0;
  auto ReferSketches__ = ReferSketches ? _fbb.CreateVector<int32_t>(*ReferSketches) : 0;
  auto FolderChildren__ = FolderChildren ? _fbb.CreateVector<int32_t>(*FolderChildren) : 0;
  auto ReferEntitys__ = ReferEntitys ? _fbb.CreateVector<int32_t>(*ReferEntitys) : 0;
  auto GroupName__ = GroupName ? _fbb.CreateString(GroupName) : 0;
  auto FlatPatternConnect__ = FlatPatternConnect ? _fbb.CreateVector<int32_t>(*FlatPatternConnect) : 0;
  auto ViewIndex__ = ViewIndex ? _fbb.CreateString(ViewIndex) : 0;
  auto ExtAttr__ = ExtAttr ? _fbb.CreateString(ExtAttr) : 0;
  return FlatBufferDocSpace::CreateFeatureData(
      _fbb,
      ID,
      Status__,
      Type__,
      SubType__,
      Flag,
      Name__,
      Index__,
      Opt__,
      DimensionVisble,
      Parent,
      ReferSketches__,
      FolderChildren__,
      ReferEntitys__,
      GroupName__,
      FlatPatternConnect__,
      ViewIndex__,
      ViewOrder,
      SheetFlag,
      ExtAttr__,
      ReferenceStatus);
}

struct DeleteVariable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeleteVariableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLENAME = 4
  };
  const flatbuffers::String *VariableName() const {
    return GetPointer<const flatbuffers::String *>(VT_VARIABLENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLENAME) &&
           verifier.VerifyString(VariableName()) &&
           verifier.EndTable();
  }
};

struct DeleteVariableBuilder {
  typedef DeleteVariable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_VariableName(flatbuffers::Offset<flatbuffers::String> VariableName) {
    fbb_.AddOffset(DeleteVariable::VT_VARIABLENAME, VariableName);
  }
  explicit DeleteVariableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteVariableBuilder &operator=(const DeleteVariableBuilder &);
  flatbuffers::Offset<DeleteVariable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeleteVariable>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeleteVariable> CreateDeleteVariable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> VariableName = 0) {
  DeleteVariableBuilder builder_(_fbb);
  builder_.add_VariableName(VariableName);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeleteVariable> CreateDeleteVariableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *VariableName = nullptr) {
  auto VariableName__ = VariableName ? _fbb.CreateString(VariableName) : 0;
  return FlatBufferDocSpace::CreateDeleteVariable(
      _fbb,
      VariableName__);
}

struct DeleteAnnotView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeleteAnnotViewBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VIEWID = 4
  };
  int32_t ViewId() const {
    return GetField<int32_t>(VT_VIEWID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VIEWID) &&
           verifier.EndTable();
  }
};

struct DeleteAnnotViewBuilder {
  typedef DeleteAnnotView Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ViewId(int32_t ViewId) {
    fbb_.AddElement<int32_t>(DeleteAnnotView::VT_VIEWID, ViewId, 0);
  }
  explicit DeleteAnnotViewBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteAnnotViewBuilder &operator=(const DeleteAnnotViewBuilder &);
  flatbuffers::Offset<DeleteAnnotView> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeleteAnnotView>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeleteAnnotView> CreateDeleteAnnotView(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ViewId = 0) {
  DeleteAnnotViewBuilder builder_(_fbb);
  builder_.add_ViewId(ViewId);
  return builder_.Finish();
}

struct CompData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_PROTOID = 8,
    VT_MAT = 10,
    VT_VISIBLE = 12,
    VT_FIX = 14,
    VT_STATUS = 16,
    VT_INDEX = 18,
    VT_PARENT = 20,
    VT_FEATUREID = 22,
    VT_ISVALID = 24,
    VT_WELLDEFINED = 26,
    VT_AI = 28,
    VT_FOLDERID = 30,
    VT_ISFOLDER = 32,
    VT_REFERENCESTATUS = 34
  };
  const flatbuffers::String *Id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *ProtoId() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOID);
  }
  const flatbuffers::Vector<double> *Mat() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAT);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool Fix() const {
    return GetField<uint8_t>(VT_FIX, 0) != 0;
  }
  const flatbuffers::String *Status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  const flatbuffers::String *Index() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX);
  }
  const flatbuffers::String *Parent() const {
    return GetPointer<const flatbuffers::String *>(VT_PARENT);
  }
  int32_t FeatureId() const {
    return GetField<int32_t>(VT_FEATUREID, 0);
  }
  int32_t IsValid() const {
    return GetField<int32_t>(VT_ISVALID, 0);
  }
  bool WellDefined() const {
    return GetField<uint8_t>(VT_WELLDEFINED, 0) != 0;
  }
  const flatbuffers::String *AI() const {
    return GetPointer<const flatbuffers::String *>(VT_AI);
  }
  const flatbuffers::String *FolderID() const {
    return GetPointer<const flatbuffers::String *>(VT_FOLDERID);
  }
  int32_t IsFolder() const {
    return GetField<int32_t>(VT_ISFOLDER, 0);
  }
  int32_t ReferenceStatus() const {
    return GetField<int32_t>(VT_REFERENCESTATUS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(Id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_PROTOID) &&
           verifier.VerifyString(ProtoId()) &&
           VerifyOffset(verifier, VT_MAT) &&
           verifier.VerifyVector(Mat()) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<uint8_t>(verifier, VT_FIX) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(Status()) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(Index()) &&
           VerifyOffset(verifier, VT_PARENT) &&
           verifier.VerifyString(Parent()) &&
           VerifyField<int32_t>(verifier, VT_FEATUREID) &&
           VerifyField<int32_t>(verifier, VT_ISVALID) &&
           VerifyField<uint8_t>(verifier, VT_WELLDEFINED) &&
           VerifyOffset(verifier, VT_AI) &&
           verifier.VerifyString(AI()) &&
           VerifyOffset(verifier, VT_FOLDERID) &&
           verifier.VerifyString(FolderID()) &&
           VerifyField<int32_t>(verifier, VT_ISFOLDER) &&
           VerifyField<int32_t>(verifier, VT_REFERENCESTATUS) &&
           verifier.EndTable();
  }
};

struct CompDataBuilder {
  typedef CompData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(flatbuffers::Offset<flatbuffers::String> Id) {
    fbb_.AddOffset(CompData::VT_ID, Id);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(CompData::VT_NAME, Name);
  }
  void add_ProtoId(flatbuffers::Offset<flatbuffers::String> ProtoId) {
    fbb_.AddOffset(CompData::VT_PROTOID, ProtoId);
  }
  void add_Mat(flatbuffers::Offset<flatbuffers::Vector<double>> Mat) {
    fbb_.AddOffset(CompData::VT_MAT, Mat);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(CompData::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  void add_Fix(bool Fix) {
    fbb_.AddElement<uint8_t>(CompData::VT_FIX, static_cast<uint8_t>(Fix), 0);
  }
  void add_Status(flatbuffers::Offset<flatbuffers::String> Status) {
    fbb_.AddOffset(CompData::VT_STATUS, Status);
  }
  void add_Index(flatbuffers::Offset<flatbuffers::String> Index) {
    fbb_.AddOffset(CompData::VT_INDEX, Index);
  }
  void add_Parent(flatbuffers::Offset<flatbuffers::String> Parent) {
    fbb_.AddOffset(CompData::VT_PARENT, Parent);
  }
  void add_FeatureId(int32_t FeatureId) {
    fbb_.AddElement<int32_t>(CompData::VT_FEATUREID, FeatureId, 0);
  }
  void add_IsValid(int32_t IsValid) {
    fbb_.AddElement<int32_t>(CompData::VT_ISVALID, IsValid, 0);
  }
  void add_WellDefined(bool WellDefined) {
    fbb_.AddElement<uint8_t>(CompData::VT_WELLDEFINED, static_cast<uint8_t>(WellDefined), 0);
  }
  void add_AI(flatbuffers::Offset<flatbuffers::String> AI) {
    fbb_.AddOffset(CompData::VT_AI, AI);
  }
  void add_FolderID(flatbuffers::Offset<flatbuffers::String> FolderID) {
    fbb_.AddOffset(CompData::VT_FOLDERID, FolderID);
  }
  void add_IsFolder(int32_t IsFolder) {
    fbb_.AddElement<int32_t>(CompData::VT_ISFOLDER, IsFolder, 0);
  }
  void add_ReferenceStatus(int32_t ReferenceStatus) {
    fbb_.AddElement<int32_t>(CompData::VT_REFERENCESTATUS, ReferenceStatus, 0);
  }
  explicit CompDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompDataBuilder &operator=(const CompDataBuilder &);
  flatbuffers::Offset<CompData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompData> CreateCompData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Id = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::String> ProtoId = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Mat = 0,
    bool Visible = false,
    bool Fix = false,
    flatbuffers::Offset<flatbuffers::String> Status = 0,
    flatbuffers::Offset<flatbuffers::String> Index = 0,
    flatbuffers::Offset<flatbuffers::String> Parent = 0,
    int32_t FeatureId = 0,
    int32_t IsValid = 0,
    bool WellDefined = false,
    flatbuffers::Offset<flatbuffers::String> AI = 0,
    flatbuffers::Offset<flatbuffers::String> FolderID = 0,
    int32_t IsFolder = 0,
    int32_t ReferenceStatus = 0) {
  CompDataBuilder builder_(_fbb);
  builder_.add_ReferenceStatus(ReferenceStatus);
  builder_.add_IsFolder(IsFolder);
  builder_.add_FolderID(FolderID);
  builder_.add_AI(AI);
  builder_.add_IsValid(IsValid);
  builder_.add_FeatureId(FeatureId);
  builder_.add_Parent(Parent);
  builder_.add_Index(Index);
  builder_.add_Status(Status);
  builder_.add_Mat(Mat);
  builder_.add_ProtoId(ProtoId);
  builder_.add_Name(Name);
  builder_.add_Id(Id);
  builder_.add_WellDefined(WellDefined);
  builder_.add_Fix(Fix);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompData> CreateCompDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Id = nullptr,
    const char *Name = nullptr,
    const char *ProtoId = nullptr,
    const std::vector<double> *Mat = nullptr,
    bool Visible = false,
    bool Fix = false,
    const char *Status = nullptr,
    const char *Index = nullptr,
    const char *Parent = nullptr,
    int32_t FeatureId = 0,
    int32_t IsValid = 0,
    bool WellDefined = false,
    const char *AI = nullptr,
    const char *FolderID = nullptr,
    int32_t IsFolder = 0,
    int32_t ReferenceStatus = 0) {
  auto Id__ = Id ? _fbb.CreateString(Id) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto ProtoId__ = ProtoId ? _fbb.CreateString(ProtoId) : 0;
  auto Mat__ = Mat ? _fbb.CreateVector<double>(*Mat) : 0;
  auto Status__ = Status ? _fbb.CreateString(Status) : 0;
  auto Index__ = Index ? _fbb.CreateString(Index) : 0;
  auto Parent__ = Parent ? _fbb.CreateString(Parent) : 0;
  auto AI__ = AI ? _fbb.CreateString(AI) : 0;
  auto FolderID__ = FolderID ? _fbb.CreateString(FolderID) : 0;
  return FlatBufferDocSpace::CreateCompData(
      _fbb,
      Id__,
      Name__,
      ProtoId__,
      Mat__,
      Visible,
      Fix,
      Status__,
      Index__,
      Parent__,
      FeatureId,
      IsValid,
      WellDefined,
      AI__,
      FolderID__,
      IsFolder,
      ReferenceStatus);
}

struct NewMatingData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NewMatingDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FID = 4,
    VT_INDEX = 6,
    VT_MID = 8,
    VT_TYPE = 10,
    VT_NAME = 12,
    VT_ALIGN = 14,
    VT_MINS = 16,
    VT_MELE = 18,
    VT_MELETYPE = 20,
    VT_RINS = 22,
    VT_RELE = 24,
    VT_RELETYPE = 26,
    VT_MPOS = 28,
    VT_RPOS = 30,
    VT_OFFSET = 32,
    VT_STATUS = 34,
    VT_TIMENODE = 36,
    VT_REVERSE = 38,
    VT_GEARVALUE1 = 40,
    VT_GEARVALUE2 = 42,
    VT_MATINGINDEX = 44,
    VT_AINSS = 46,
    VT_AELES = 48,
    VT_AELETYPES = 50,
    VT_APOSS = 52,
    VT_MPROFILECURVES = 54,
    VT_RPROFILECURVES = 56,
    VT_FOLDERID = 58
  };
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  const flatbuffers::String *Index() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX);
  }
  int32_t MID() const {
    return GetField<int32_t>(VT_MID, 0);
  }
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t Align() const {
    return GetField<int32_t>(VT_ALIGN, 0);
  }
  const flatbuffers::String *MIns() const {
    return GetPointer<const flatbuffers::String *>(VT_MINS);
  }
  int32_t MEle() const {
    return GetField<int32_t>(VT_MELE, 0);
  }
  int32_t MEleType() const {
    return GetField<int32_t>(VT_MELETYPE, 0);
  }
  const flatbuffers::String *RIns() const {
    return GetPointer<const flatbuffers::String *>(VT_RINS);
  }
  int32_t REle() const {
    return GetField<int32_t>(VT_RELE, 0);
  }
  int32_t REleType() const {
    return GetField<int32_t>(VT_RELETYPE, 0);
  }
  const flatbuffers::Vector<double> *MPos() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MPOS);
  }
  const flatbuffers::Vector<double> *RPos() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_RPOS);
  }
  const FlatBufferDocSpace::VariableData *Offset() const {
    return GetPointer<const FlatBufferDocSpace::VariableData *>(VT_OFFSET);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  const flatbuffers::String *TimeNode() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMENODE);
  }
  int32_t Reverse() const {
    return GetField<int32_t>(VT_REVERSE, 0);
  }
  const FlatBufferDocSpace::VariableData *GearValue1() const {
    return GetPointer<const FlatBufferDocSpace::VariableData *>(VT_GEARVALUE1);
  }
  const FlatBufferDocSpace::VariableData *GearValue2() const {
    return GetPointer<const FlatBufferDocSpace::VariableData *>(VT_GEARVALUE2);
  }
  int32_t MatingIndex() const {
    return GetField<int32_t>(VT_MATINGINDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *AInss() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_AINSS);
  }
  const flatbuffers::Vector<int32_t> *AEles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AELES);
  }
  const flatbuffers::Vector<int32_t> *AEleTypes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AELETYPES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PickPos>> *APoss() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PickPos>> *>(VT_APOSS);
  }
  const flatbuffers::Vector<int32_t> *MProfileCurves() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MPROFILECURVES);
  }
  const flatbuffers::Vector<int32_t> *RProfileCurves() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_RPROFILECURVES);
  }
  int32_t FolderID() const {
    return GetField<int32_t>(VT_FOLDERID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(Index()) &&
           VerifyField<int32_t>(verifier, VT_MID) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_ALIGN) &&
           VerifyOffset(verifier, VT_MINS) &&
           verifier.VerifyString(MIns()) &&
           VerifyField<int32_t>(verifier, VT_MELE) &&
           VerifyField<int32_t>(verifier, VT_MELETYPE) &&
           VerifyOffset(verifier, VT_RINS) &&
           verifier.VerifyString(RIns()) &&
           VerifyField<int32_t>(verifier, VT_RELE) &&
           VerifyField<int32_t>(verifier, VT_RELETYPE) &&
           VerifyOffset(verifier, VT_MPOS) &&
           verifier.VerifyVector(MPos()) &&
           VerifyOffset(verifier, VT_RPOS) &&
           verifier.VerifyVector(RPos()) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.VerifyTable(Offset()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_TIMENODE) &&
           verifier.VerifyString(TimeNode()) &&
           VerifyField<int32_t>(verifier, VT_REVERSE) &&
           VerifyOffset(verifier, VT_GEARVALUE1) &&
           verifier.VerifyTable(GearValue1()) &&
           VerifyOffset(verifier, VT_GEARVALUE2) &&
           verifier.VerifyTable(GearValue2()) &&
           VerifyField<int32_t>(verifier, VT_MATINGINDEX) &&
           VerifyOffset(verifier, VT_AINSS) &&
           verifier.VerifyVector(AInss()) &&
           verifier.VerifyVectorOfStrings(AInss()) &&
           VerifyOffset(verifier, VT_AELES) &&
           verifier.VerifyVector(AEles()) &&
           VerifyOffset(verifier, VT_AELETYPES) &&
           verifier.VerifyVector(AEleTypes()) &&
           VerifyOffset(verifier, VT_APOSS) &&
           verifier.VerifyVector(APoss()) &&
           verifier.VerifyVectorOfTables(APoss()) &&
           VerifyOffset(verifier, VT_MPROFILECURVES) &&
           verifier.VerifyVector(MProfileCurves()) &&
           VerifyOffset(verifier, VT_RPROFILECURVES) &&
           verifier.VerifyVector(RProfileCurves()) &&
           VerifyField<int32_t>(verifier, VT_FOLDERID) &&
           verifier.EndTable();
  }
};

struct NewMatingDataBuilder {
  typedef NewMatingData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_FID, FID, 0);
  }
  void add_Index(flatbuffers::Offset<flatbuffers::String> Index) {
    fbb_.AddOffset(NewMatingData::VT_INDEX, Index);
  }
  void add_MID(int32_t MID) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_MID, MID, 0);
  }
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(NewMatingData::VT_TYPE, Type);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(NewMatingData::VT_NAME, Name);
  }
  void add_Align(int32_t Align) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_ALIGN, Align, 0);
  }
  void add_MIns(flatbuffers::Offset<flatbuffers::String> MIns) {
    fbb_.AddOffset(NewMatingData::VT_MINS, MIns);
  }
  void add_MEle(int32_t MEle) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_MELE, MEle, 0);
  }
  void add_MEleType(int32_t MEleType) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_MELETYPE, MEleType, 0);
  }
  void add_RIns(flatbuffers::Offset<flatbuffers::String> RIns) {
    fbb_.AddOffset(NewMatingData::VT_RINS, RIns);
  }
  void add_REle(int32_t REle) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_RELE, REle, 0);
  }
  void add_REleType(int32_t REleType) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_RELETYPE, REleType, 0);
  }
  void add_MPos(flatbuffers::Offset<flatbuffers::Vector<double>> MPos) {
    fbb_.AddOffset(NewMatingData::VT_MPOS, MPos);
  }
  void add_RPos(flatbuffers::Offset<flatbuffers::Vector<double>> RPos) {
    fbb_.AddOffset(NewMatingData::VT_RPOS, RPos);
  }
  void add_Offset(flatbuffers::Offset<FlatBufferDocSpace::VariableData> Offset) {
    fbb_.AddOffset(NewMatingData::VT_OFFSET, Offset);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_STATUS, Status, 0);
  }
  void add_TimeNode(flatbuffers::Offset<flatbuffers::String> TimeNode) {
    fbb_.AddOffset(NewMatingData::VT_TIMENODE, TimeNode);
  }
  void add_Reverse(int32_t Reverse) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_REVERSE, Reverse, 0);
  }
  void add_GearValue1(flatbuffers::Offset<FlatBufferDocSpace::VariableData> GearValue1) {
    fbb_.AddOffset(NewMatingData::VT_GEARVALUE1, GearValue1);
  }
  void add_GearValue2(flatbuffers::Offset<FlatBufferDocSpace::VariableData> GearValue2) {
    fbb_.AddOffset(NewMatingData::VT_GEARVALUE2, GearValue2);
  }
  void add_MatingIndex(int32_t MatingIndex) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_MATINGINDEX, MatingIndex, 0);
  }
  void add_AInss(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> AInss) {
    fbb_.AddOffset(NewMatingData::VT_AINSS, AInss);
  }
  void add_AEles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> AEles) {
    fbb_.AddOffset(NewMatingData::VT_AELES, AEles);
  }
  void add_AEleTypes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> AEleTypes) {
    fbb_.AddOffset(NewMatingData::VT_AELETYPES, AEleTypes);
  }
  void add_APoss(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PickPos>>> APoss) {
    fbb_.AddOffset(NewMatingData::VT_APOSS, APoss);
  }
  void add_MProfileCurves(flatbuffers::Offset<flatbuffers::Vector<int32_t>> MProfileCurves) {
    fbb_.AddOffset(NewMatingData::VT_MPROFILECURVES, MProfileCurves);
  }
  void add_RProfileCurves(flatbuffers::Offset<flatbuffers::Vector<int32_t>> RProfileCurves) {
    fbb_.AddOffset(NewMatingData::VT_RPROFILECURVES, RProfileCurves);
  }
  void add_FolderID(int32_t FolderID) {
    fbb_.AddElement<int32_t>(NewMatingData::VT_FOLDERID, FolderID, 0);
  }
  explicit NewMatingDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NewMatingDataBuilder &operator=(const NewMatingDataBuilder &);
  flatbuffers::Offset<NewMatingData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NewMatingData>(end);
    return o;
  }
};

inline flatbuffers::Offset<NewMatingData> CreateNewMatingData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t FID = 0,
    flatbuffers::Offset<flatbuffers::String> Index = 0,
    int32_t MID = 0,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t Align = 0,
    flatbuffers::Offset<flatbuffers::String> MIns = 0,
    int32_t MEle = 0,
    int32_t MEleType = 0,
    flatbuffers::Offset<flatbuffers::String> RIns = 0,
    int32_t REle = 0,
    int32_t REleType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MPos = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> RPos = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> Offset = 0,
    int32_t Status = 0,
    flatbuffers::Offset<flatbuffers::String> TimeNode = 0,
    int32_t Reverse = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> GearValue1 = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> GearValue2 = 0,
    int32_t MatingIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> AInss = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> AEles = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> AEleTypes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PickPos>>> APoss = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> MProfileCurves = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> RProfileCurves = 0,
    int32_t FolderID = 0) {
  NewMatingDataBuilder builder_(_fbb);
  builder_.add_FolderID(FolderID);
  builder_.add_RProfileCurves(RProfileCurves);
  builder_.add_MProfileCurves(MProfileCurves);
  builder_.add_APoss(APoss);
  builder_.add_AEleTypes(AEleTypes);
  builder_.add_AEles(AEles);
  builder_.add_AInss(AInss);
  builder_.add_MatingIndex(MatingIndex);
  builder_.add_GearValue2(GearValue2);
  builder_.add_GearValue1(GearValue1);
  builder_.add_Reverse(Reverse);
  builder_.add_TimeNode(TimeNode);
  builder_.add_Status(Status);
  builder_.add_Offset(Offset);
  builder_.add_RPos(RPos);
  builder_.add_MPos(MPos);
  builder_.add_REleType(REleType);
  builder_.add_REle(REle);
  builder_.add_RIns(RIns);
  builder_.add_MEleType(MEleType);
  builder_.add_MEle(MEle);
  builder_.add_MIns(MIns);
  builder_.add_Align(Align);
  builder_.add_Name(Name);
  builder_.add_Type(Type);
  builder_.add_MID(MID);
  builder_.add_Index(Index);
  builder_.add_FID(FID);
  return builder_.Finish();
}

inline flatbuffers::Offset<NewMatingData> CreateNewMatingDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t FID = 0,
    const char *Index = nullptr,
    int32_t MID = 0,
    const char *Type = nullptr,
    const char *Name = nullptr,
    int32_t Align = 0,
    const char *MIns = nullptr,
    int32_t MEle = 0,
    int32_t MEleType = 0,
    const char *RIns = nullptr,
    int32_t REle = 0,
    int32_t REleType = 0,
    const std::vector<double> *MPos = nullptr,
    const std::vector<double> *RPos = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> Offset = 0,
    int32_t Status = 0,
    const char *TimeNode = nullptr,
    int32_t Reverse = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> GearValue1 = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> GearValue2 = 0,
    int32_t MatingIndex = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *AInss = nullptr,
    const std::vector<int32_t> *AEles = nullptr,
    const std::vector<int32_t> *AEleTypes = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::PickPos>> *APoss = nullptr,
    const std::vector<int32_t> *MProfileCurves = nullptr,
    const std::vector<int32_t> *RProfileCurves = nullptr,
    int32_t FolderID = 0) {
  auto Index__ = Index ? _fbb.CreateString(Index) : 0;
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto MIns__ = MIns ? _fbb.CreateString(MIns) : 0;
  auto RIns__ = RIns ? _fbb.CreateString(RIns) : 0;
  auto MPos__ = MPos ? _fbb.CreateVector<double>(*MPos) : 0;
  auto RPos__ = RPos ? _fbb.CreateVector<double>(*RPos) : 0;
  auto TimeNode__ = TimeNode ? _fbb.CreateString(TimeNode) : 0;
  auto AInss__ = AInss ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*AInss) : 0;
  auto AEles__ = AEles ? _fbb.CreateVector<int32_t>(*AEles) : 0;
  auto AEleTypes__ = AEleTypes ? _fbb.CreateVector<int32_t>(*AEleTypes) : 0;
  auto APoss__ = APoss ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::PickPos>>(*APoss) : 0;
  auto MProfileCurves__ = MProfileCurves ? _fbb.CreateVector<int32_t>(*MProfileCurves) : 0;
  auto RProfileCurves__ = RProfileCurves ? _fbb.CreateVector<int32_t>(*RProfileCurves) : 0;
  return FlatBufferDocSpace::CreateNewMatingData(
      _fbb,
      FID,
      Index__,
      MID,
      Type__,
      Name__,
      Align,
      MIns__,
      MEle,
      MEleType,
      RIns__,
      REle,
      REleType,
      MPos__,
      RPos__,
      Offset,
      Status,
      TimeNode__,
      Reverse,
      GearValue1,
      GearValue2,
      MatingIndex,
      AInss__,
      AEles__,
      AEleTypes__,
      APoss__,
      MProfileCurves__,
      RProfileCurves__,
      FolderID);
}

struct PickPos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PickPosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4
  };
  const flatbuffers::Vector<double> *Pos() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyVector(Pos()) &&
           verifier.EndTable();
  }
};

struct PickPosBuilder {
  typedef PickPos Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Pos(flatbuffers::Offset<flatbuffers::Vector<double>> Pos) {
    fbb_.AddOffset(PickPos::VT_POS, Pos);
  }
  explicit PickPosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PickPosBuilder &operator=(const PickPosBuilder &);
  flatbuffers::Offset<PickPos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PickPos>(end);
    return o;
  }
};

inline flatbuffers::Offset<PickPos> CreatePickPos(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Pos = 0) {
  PickPosBuilder builder_(_fbb);
  builder_.add_Pos(Pos);
  return builder_.Finish();
}

inline flatbuffers::Offset<PickPos> CreatePickPosDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Pos = nullptr) {
  auto Pos__ = Pos ? _fbb.CreateVector<double>(*Pos) : 0;
  return FlatBufferDocSpace::CreatePickPos(
      _fbb,
      Pos__);
}

struct MateRefData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MateRefDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FID = 4,
    VT_NAME = 6,
    VT_ID1 = 8,
    VT_ELETYPE1 = 10,
    VT_INSTANCEID1 = 12,
    VT_TYPE1 = 14,
    VT_ALIGN1 = 16,
    VT_HASELEMENT2MARK = 18,
    VT_ID2 = 20,
    VT_ELETYPE2 = 22,
    VT_INSTANCEID2 = 24,
    VT_TYPE2 = 26,
    VT_ALIGN2 = 28,
    VT_HASELEMENT3MARK = 30,
    VT_ID3 = 32,
    VT_ELETYPE3 = 34,
    VT_INSTANCEID3 = 36,
    VT_TYPE3 = 38,
    VT_ALIGN3 = 40
  };
  int32_t FID() const {
    return GetField<int32_t>(VT_FID, 0);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t Id1() const {
    return GetField<int32_t>(VT_ID1, 0);
  }
  int32_t EleType1() const {
    return GetField<int32_t>(VT_ELETYPE1, 0);
  }
  const flatbuffers::String *InstanceId1() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID1);
  }
  const flatbuffers::String *Type1() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE1);
  }
  int32_t Align1() const {
    return GetField<int32_t>(VT_ALIGN1, 0);
  }
  int32_t HasElement2Mark() const {
    return GetField<int32_t>(VT_HASELEMENT2MARK, 0);
  }
  int32_t Id2() const {
    return GetField<int32_t>(VT_ID2, 0);
  }
  int32_t EleType2() const {
    return GetField<int32_t>(VT_ELETYPE2, 0);
  }
  const flatbuffers::String *InstanceId2() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID2);
  }
  const flatbuffers::String *Type2() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE2);
  }
  int32_t Align2() const {
    return GetField<int32_t>(VT_ALIGN2, 0);
  }
  int32_t HasElement3Mark() const {
    return GetField<int32_t>(VT_HASELEMENT3MARK, 0);
  }
  int32_t Id3() const {
    return GetField<int32_t>(VT_ID3, 0);
  }
  int32_t EleType3() const {
    return GetField<int32_t>(VT_ELETYPE3, 0);
  }
  const flatbuffers::String *InstanceId3() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID3);
  }
  const flatbuffers::String *Type3() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE3);
  }
  int32_t Align3() const {
    return GetField<int32_t>(VT_ALIGN3, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_ID1) &&
           VerifyField<int32_t>(verifier, VT_ELETYPE1) &&
           VerifyOffset(verifier, VT_INSTANCEID1) &&
           verifier.VerifyString(InstanceId1()) &&
           VerifyOffset(verifier, VT_TYPE1) &&
           verifier.VerifyString(Type1()) &&
           VerifyField<int32_t>(verifier, VT_ALIGN1) &&
           VerifyField<int32_t>(verifier, VT_HASELEMENT2MARK) &&
           VerifyField<int32_t>(verifier, VT_ID2) &&
           VerifyField<int32_t>(verifier, VT_ELETYPE2) &&
           VerifyOffset(verifier, VT_INSTANCEID2) &&
           verifier.VerifyString(InstanceId2()) &&
           VerifyOffset(verifier, VT_TYPE2) &&
           verifier.VerifyString(Type2()) &&
           VerifyField<int32_t>(verifier, VT_ALIGN2) &&
           VerifyField<int32_t>(verifier, VT_HASELEMENT3MARK) &&
           VerifyField<int32_t>(verifier, VT_ID3) &&
           VerifyField<int32_t>(verifier, VT_ELETYPE3) &&
           VerifyOffset(verifier, VT_INSTANCEID3) &&
           verifier.VerifyString(InstanceId3()) &&
           VerifyOffset(verifier, VT_TYPE3) &&
           verifier.VerifyString(Type3()) &&
           VerifyField<int32_t>(verifier, VT_ALIGN3) &&
           verifier.EndTable();
  }
};

struct MateRefDataBuilder {
  typedef MateRefData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FID(int32_t FID) {
    fbb_.AddElement<int32_t>(MateRefData::VT_FID, FID, 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(MateRefData::VT_NAME, Name);
  }
  void add_Id1(int32_t Id1) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ID1, Id1, 0);
  }
  void add_EleType1(int32_t EleType1) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ELETYPE1, EleType1, 0);
  }
  void add_InstanceId1(flatbuffers::Offset<flatbuffers::String> InstanceId1) {
    fbb_.AddOffset(MateRefData::VT_INSTANCEID1, InstanceId1);
  }
  void add_Type1(flatbuffers::Offset<flatbuffers::String> Type1) {
    fbb_.AddOffset(MateRefData::VT_TYPE1, Type1);
  }
  void add_Align1(int32_t Align1) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ALIGN1, Align1, 0);
  }
  void add_HasElement2Mark(int32_t HasElement2Mark) {
    fbb_.AddElement<int32_t>(MateRefData::VT_HASELEMENT2MARK, HasElement2Mark, 0);
  }
  void add_Id2(int32_t Id2) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ID2, Id2, 0);
  }
  void add_EleType2(int32_t EleType2) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ELETYPE2, EleType2, 0);
  }
  void add_InstanceId2(flatbuffers::Offset<flatbuffers::String> InstanceId2) {
    fbb_.AddOffset(MateRefData::VT_INSTANCEID2, InstanceId2);
  }
  void add_Type2(flatbuffers::Offset<flatbuffers::String> Type2) {
    fbb_.AddOffset(MateRefData::VT_TYPE2, Type2);
  }
  void add_Align2(int32_t Align2) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ALIGN2, Align2, 0);
  }
  void add_HasElement3Mark(int32_t HasElement3Mark) {
    fbb_.AddElement<int32_t>(MateRefData::VT_HASELEMENT3MARK, HasElement3Mark, 0);
  }
  void add_Id3(int32_t Id3) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ID3, Id3, 0);
  }
  void add_EleType3(int32_t EleType3) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ELETYPE3, EleType3, 0);
  }
  void add_InstanceId3(flatbuffers::Offset<flatbuffers::String> InstanceId3) {
    fbb_.AddOffset(MateRefData::VT_INSTANCEID3, InstanceId3);
  }
  void add_Type3(flatbuffers::Offset<flatbuffers::String> Type3) {
    fbb_.AddOffset(MateRefData::VT_TYPE3, Type3);
  }
  void add_Align3(int32_t Align3) {
    fbb_.AddElement<int32_t>(MateRefData::VT_ALIGN3, Align3, 0);
  }
  explicit MateRefDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MateRefDataBuilder &operator=(const MateRefDataBuilder &);
  flatbuffers::Offset<MateRefData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MateRefData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MateRefData> CreateMateRefData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t FID = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t Id1 = 0,
    int32_t EleType1 = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId1 = 0,
    flatbuffers::Offset<flatbuffers::String> Type1 = 0,
    int32_t Align1 = 0,
    int32_t HasElement2Mark = 0,
    int32_t Id2 = 0,
    int32_t EleType2 = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId2 = 0,
    flatbuffers::Offset<flatbuffers::String> Type2 = 0,
    int32_t Align2 = 0,
    int32_t HasElement3Mark = 0,
    int32_t Id3 = 0,
    int32_t EleType3 = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId3 = 0,
    flatbuffers::Offset<flatbuffers::String> Type3 = 0,
    int32_t Align3 = 0) {
  MateRefDataBuilder builder_(_fbb);
  builder_.add_Align3(Align3);
  builder_.add_Type3(Type3);
  builder_.add_InstanceId3(InstanceId3);
  builder_.add_EleType3(EleType3);
  builder_.add_Id3(Id3);
  builder_.add_HasElement3Mark(HasElement3Mark);
  builder_.add_Align2(Align2);
  builder_.add_Type2(Type2);
  builder_.add_InstanceId2(InstanceId2);
  builder_.add_EleType2(EleType2);
  builder_.add_Id2(Id2);
  builder_.add_HasElement2Mark(HasElement2Mark);
  builder_.add_Align1(Align1);
  builder_.add_Type1(Type1);
  builder_.add_InstanceId1(InstanceId1);
  builder_.add_EleType1(EleType1);
  builder_.add_Id1(Id1);
  builder_.add_Name(Name);
  builder_.add_FID(FID);
  return builder_.Finish();
}

inline flatbuffers::Offset<MateRefData> CreateMateRefDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t FID = 0,
    const char *Name = nullptr,
    int32_t Id1 = 0,
    int32_t EleType1 = 0,
    const char *InstanceId1 = nullptr,
    const char *Type1 = nullptr,
    int32_t Align1 = 0,
    int32_t HasElement2Mark = 0,
    int32_t Id2 = 0,
    int32_t EleType2 = 0,
    const char *InstanceId2 = nullptr,
    const char *Type2 = nullptr,
    int32_t Align2 = 0,
    int32_t HasElement3Mark = 0,
    int32_t Id3 = 0,
    int32_t EleType3 = 0,
    const char *InstanceId3 = nullptr,
    const char *Type3 = nullptr,
    int32_t Align3 = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto InstanceId1__ = InstanceId1 ? _fbb.CreateString(InstanceId1) : 0;
  auto Type1__ = Type1 ? _fbb.CreateString(Type1) : 0;
  auto InstanceId2__ = InstanceId2 ? _fbb.CreateString(InstanceId2) : 0;
  auto Type2__ = Type2 ? _fbb.CreateString(Type2) : 0;
  auto InstanceId3__ = InstanceId3 ? _fbb.CreateString(InstanceId3) : 0;
  auto Type3__ = Type3 ? _fbb.CreateString(Type3) : 0;
  return FlatBufferDocSpace::CreateMateRefData(
      _fbb,
      FID,
      Name__,
      Id1,
      EleType1,
      InstanceId1__,
      Type1__,
      Align1,
      HasElement2Mark,
      Id2,
      EleType2,
      InstanceId2__,
      Type2__,
      Align2,
      HasElement3Mark,
      Id3,
      EleType3,
      InstanceId3__,
      Type3__,
      Align3);
}

struct InstanceNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_CHILDREN = 8
  };
  const flatbuffers::String *Id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *Children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *>(VT_CHILDREN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(Id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(Children()) &&
           verifier.VerifyVectorOfTables(Children()) &&
           verifier.EndTable();
  }
};

struct InstanceNodeBuilder {
  typedef InstanceNode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(flatbuffers::Offset<flatbuffers::String> Id) {
    fbb_.AddOffset(InstanceNode::VT_ID, Id);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(InstanceNode::VT_NAME, Name);
  }
  void add_Children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>> Children) {
    fbb_.AddOffset(InstanceNode::VT_CHILDREN, Children);
  }
  explicit InstanceNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstanceNodeBuilder &operator=(const InstanceNodeBuilder &);
  flatbuffers::Offset<InstanceNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceNode> CreateInstanceNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Id = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>> Children = 0) {
  InstanceNodeBuilder builder_(_fbb);
  builder_.add_Children(Children);
  builder_.add_Name(Name);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstanceNode> CreateInstanceNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Id = nullptr,
    const char *Name = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *Children = nullptr) {
  auto Id__ = Id ? _fbb.CreateString(Id) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Children__ = Children ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>(*Children) : 0;
  return FlatBufferDocSpace::CreateInstanceNode(
      _fbb,
      Id__,
      Name__,
      Children__);
}

struct AppearanceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AppearanceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PARAM = 6
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *Param() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_PARAM) &&
           verifier.VerifyString(Param()) &&
           verifier.EndTable();
  }
};

struct AppearanceDataBuilder {
  typedef AppearanceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(AppearanceData::VT_ID, Id, 0);
  }
  void add_Param(flatbuffers::Offset<flatbuffers::String> Param) {
    fbb_.AddOffset(AppearanceData::VT_PARAM, Param);
  }
  explicit AppearanceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AppearanceDataBuilder &operator=(const AppearanceDataBuilder &);
  flatbuffers::Offset<AppearanceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AppearanceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AppearanceData> CreateAppearanceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    flatbuffers::Offset<flatbuffers::String> Param = 0) {
  AppearanceDataBuilder builder_(_fbb);
  builder_.add_Param(Param);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline flatbuffers::Offset<AppearanceData> CreateAppearanceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    const char *Param = nullptr) {
  auto Param__ = Param ? _fbb.CreateString(Param) : 0;
  return FlatBufferDocSpace::CreateAppearanceData(
      _fbb,
      Id,
      Param__);
}

struct TextureData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PARAM = 6
  };
  const flatbuffers::String *Id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *Param() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(Id()) &&
           VerifyOffset(verifier, VT_PARAM) &&
           verifier.VerifyString(Param()) &&
           verifier.EndTable();
  }
};

struct TextureDataBuilder {
  typedef TextureData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(flatbuffers::Offset<flatbuffers::String> Id) {
    fbb_.AddOffset(TextureData::VT_ID, Id);
  }
  void add_Param(flatbuffers::Offset<flatbuffers::String> Param) {
    fbb_.AddOffset(TextureData::VT_PARAM, Param);
  }
  explicit TextureDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureDataBuilder &operator=(const TextureDataBuilder &);
  flatbuffers::Offset<TextureData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureData> CreateTextureData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Id = 0,
    flatbuffers::Offset<flatbuffers::String> Param = 0) {
  TextureDataBuilder builder_(_fbb);
  builder_.add_Param(Param);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextureData> CreateTextureDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Id = nullptr,
    const char *Param = nullptr) {
  auto Id__ = Id ? _fbb.CreateString(Id) : 0;
  auto Param__ = Param ? _fbb.CreateString(Param) : 0;
  return FlatBufferDocSpace::CreateTextureData(
      _fbb,
      Id__,
      Param__);
}

struct ProtoDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProtoDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DOCID = 6,
    VT_VERSIONID = 8,
    VT_NAME = 10,
    VT_INSTANCES = 12,
    VT_MATINGS = 14,
    VT_MATEREFS = 16,
    VT_FEATUREDATAS = 18,
    VT_INSTANCETREE = 20,
    VT_ELEMENTS = 22,
    VT_ENTITIES = 24,
    VT_TYPE = 26,
    VT_VARIABLES = 28,
    VT_VIEWDATAS = 30,
    VT_APPEARANCEDATAS = 32,
    VT_TEXTUREDATAS = 34,
    VT_AI = 36,
    VT_MATERIALS = 38,
    VT_DIMVISIBLE = 40
  };
  const flatbuffers::String *Id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *DocId() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCID);
  }
  const flatbuffers::String *VersionId() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSIONID);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *Instances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *>(VT_INSTANCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *Matings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *>(VT_MATINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *MateRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *>(VT_MATEREFS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *>(VT_FEATUREDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *InstanceTree() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *>(VT_INSTANCETREE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Elements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_ELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *Entities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_ENTITIES);
  }
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *Variables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_VARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *ViewDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *>(VT_VIEWDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *AppearanceDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *>(VT_APPEARANCEDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *TextureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *>(VT_TEXTUREDATAS);
  }
  int32_t AI() const {
    return GetField<int32_t>(VT_AI, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *Materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *>(VT_MATERIALS);
  }
  bool DimVisible() const {
    return GetField<uint8_t>(VT_DIMVISIBLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(Id()) &&
           VerifyOffset(verifier, VT_DOCID) &&
           verifier.VerifyString(DocId()) &&
           VerifyOffset(verifier, VT_VERSIONID) &&
           verifier.VerifyString(VersionId()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(Instances()) &&
           verifier.VerifyVectorOfTables(Instances()) &&
           VerifyOffset(verifier, VT_MATINGS) &&
           verifier.VerifyVector(Matings()) &&
           verifier.VerifyVectorOfTables(Matings()) &&
           VerifyOffset(verifier, VT_MATEREFS) &&
           verifier.VerifyVector(MateRefs()) &&
           verifier.VerifyVectorOfTables(MateRefs()) &&
           VerifyOffset(verifier, VT_FEATUREDATAS) &&
           verifier.VerifyVector(FeatureDatas()) &&
           verifier.VerifyVectorOfTables(FeatureDatas()) &&
           VerifyOffset(verifier, VT_INSTANCETREE) &&
           verifier.VerifyVector(InstanceTree()) &&
           verifier.VerifyVectorOfTables(InstanceTree()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(Elements()) &&
           verifier.VerifyVectorOfTables(Elements()) &&
           VerifyOffset(verifier, VT_ENTITIES) &&
           verifier.VerifyVector(Entities()) &&
           verifier.VerifyVectorOfTables(Entities()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(Variables()) &&
           verifier.VerifyVectorOfTables(Variables()) &&
           VerifyOffset(verifier, VT_VIEWDATAS) &&
           verifier.VerifyVector(ViewDatas()) &&
           verifier.VerifyVectorOfTables(ViewDatas()) &&
           VerifyOffset(verifier, VT_APPEARANCEDATAS) &&
           verifier.VerifyVector(AppearanceDatas()) &&
           verifier.VerifyVectorOfTables(AppearanceDatas()) &&
           VerifyOffset(verifier, VT_TEXTUREDATAS) &&
           verifier.VerifyVector(TextureDatas()) &&
           verifier.VerifyVectorOfTables(TextureDatas()) &&
           VerifyField<int32_t>(verifier, VT_AI) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(Materials()) &&
           verifier.VerifyVectorOfTables(Materials()) &&
           VerifyField<uint8_t>(verifier, VT_DIMVISIBLE) &&
           verifier.EndTable();
  }
};

struct ProtoDataMessageBuilder {
  typedef ProtoDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(flatbuffers::Offset<flatbuffers::String> Id) {
    fbb_.AddOffset(ProtoDataMessage::VT_ID, Id);
  }
  void add_DocId(flatbuffers::Offset<flatbuffers::String> DocId) {
    fbb_.AddOffset(ProtoDataMessage::VT_DOCID, DocId);
  }
  void add_VersionId(flatbuffers::Offset<flatbuffers::String> VersionId) {
    fbb_.AddOffset(ProtoDataMessage::VT_VERSIONID, VersionId);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(ProtoDataMessage::VT_NAME, Name);
  }
  void add_Instances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>> Instances) {
    fbb_.AddOffset(ProtoDataMessage::VT_INSTANCES, Instances);
  }
  void add_Matings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> Matings) {
    fbb_.AddOffset(ProtoDataMessage::VT_MATINGS, Matings);
  }
  void add_MateRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> MateRefs) {
    fbb_.AddOffset(ProtoDataMessage::VT_MATEREFS, MateRefs);
  }
  void add_FeatureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas) {
    fbb_.AddOffset(ProtoDataMessage::VT_FEATUREDATAS, FeatureDatas);
  }
  void add_InstanceTree(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>> InstanceTree) {
    fbb_.AddOffset(ProtoDataMessage::VT_INSTANCETREE, InstanceTree);
  }
  void add_Elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Elements) {
    fbb_.AddOffset(ProtoDataMessage::VT_ELEMENTS, Elements);
  }
  void add_Entities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> Entities) {
    fbb_.AddOffset(ProtoDataMessage::VT_ENTITIES, Entities);
  }
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(ProtoDataMessage::VT_TYPE, Type);
  }
  void add_Variables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> Variables) {
    fbb_.AddOffset(ProtoDataMessage::VT_VARIABLES, Variables);
  }
  void add_ViewDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> ViewDatas) {
    fbb_.AddOffset(ProtoDataMessage::VT_VIEWDATAS, ViewDatas);
  }
  void add_AppearanceDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>> AppearanceDatas) {
    fbb_.AddOffset(ProtoDataMessage::VT_APPEARANCEDATAS, AppearanceDatas);
  }
  void add_TextureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>> TextureDatas) {
    fbb_.AddOffset(ProtoDataMessage::VT_TEXTUREDATAS, TextureDatas);
  }
  void add_AI(int32_t AI) {
    fbb_.AddElement<int32_t>(ProtoDataMessage::VT_AI, AI, 0);
  }
  void add_Materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>> Materials) {
    fbb_.AddOffset(ProtoDataMessage::VT_MATERIALS, Materials);
  }
  void add_DimVisible(bool DimVisible) {
    fbb_.AddElement<uint8_t>(ProtoDataMessage::VT_DIMVISIBLE, static_cast<uint8_t>(DimVisible), 0);
  }
  explicit ProtoDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProtoDataMessageBuilder &operator=(const ProtoDataMessageBuilder &);
  flatbuffers::Offset<ProtoDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProtoDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProtoDataMessage> CreateProtoDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Id = 0,
    flatbuffers::Offset<flatbuffers::String> DocId = 0,
    flatbuffers::Offset<flatbuffers::String> VersionId = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>> Instances = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> Matings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> MateRefs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>> InstanceTree = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Elements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> Entities = 0,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> Variables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> ViewDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>> AppearanceDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>> TextureDatas = 0,
    int32_t AI = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>> Materials = 0,
    bool DimVisible = false) {
  ProtoDataMessageBuilder builder_(_fbb);
  builder_.add_Materials(Materials);
  builder_.add_AI(AI);
  builder_.add_TextureDatas(TextureDatas);
  builder_.add_AppearanceDatas(AppearanceDatas);
  builder_.add_ViewDatas(ViewDatas);
  builder_.add_Variables(Variables);
  builder_.add_Type(Type);
  builder_.add_Entities(Entities);
  builder_.add_Elements(Elements);
  builder_.add_InstanceTree(InstanceTree);
  builder_.add_FeatureDatas(FeatureDatas);
  builder_.add_MateRefs(MateRefs);
  builder_.add_Matings(Matings);
  builder_.add_Instances(Instances);
  builder_.add_Name(Name);
  builder_.add_VersionId(VersionId);
  builder_.add_DocId(DocId);
  builder_.add_Id(Id);
  builder_.add_DimVisible(DimVisible);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProtoDataMessage> CreateProtoDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Id = nullptr,
    const char *DocId = nullptr,
    const char *VersionId = nullptr,
    const char *Name = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *Instances = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *Matings = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *MateRefs = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *InstanceTree = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Elements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *Entities = nullptr,
    const char *Type = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *Variables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *ViewDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *AppearanceDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *TextureDatas = nullptr,
    int32_t AI = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *Materials = nullptr,
    bool DimVisible = false) {
  auto Id__ = Id ? _fbb.CreateString(Id) : 0;
  auto DocId__ = DocId ? _fbb.CreateString(DocId) : 0;
  auto VersionId__ = VersionId ? _fbb.CreateString(VersionId) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Instances__ = Instances ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>(*Instances) : 0;
  auto Matings__ = Matings ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>(*Matings) : 0;
  auto MateRefs__ = MateRefs ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>(*MateRefs) : 0;
  auto FeatureDatas__ = FeatureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>(*FeatureDatas) : 0;
  auto InstanceTree__ = InstanceTree ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>(*InstanceTree) : 0;
  auto Elements__ = Elements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*Elements) : 0;
  auto Entities__ = Entities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*Entities) : 0;
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto Variables__ = Variables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*Variables) : 0;
  auto ViewDatas__ = ViewDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>(*ViewDatas) : 0;
  auto AppearanceDatas__ = AppearanceDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>(*AppearanceDatas) : 0;
  auto TextureDatas__ = TextureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>(*TextureDatas) : 0;
  auto Materials__ = Materials ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>(*Materials) : 0;
  return FlatBufferDocSpace::CreateProtoDataMessage(
      _fbb,
      Id__,
      DocId__,
      VersionId__,
      Name__,
      Instances__,
      Matings__,
      MateRefs__,
      FeatureDatas__,
      InstanceTree__,
      Elements__,
      Entities__,
      Type__,
      Variables__,
      ViewDatas__,
      AppearanceDatas__,
      TextureDatas__,
      AI,
      Materials__,
      DimVisible);
}

struct ViewData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ViewDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CATEGORYNAME = 4,
    VT_ID = 6,
    VT_NAME = 8,
    VT_MATRIX = 10,
    VT_RELPMI = 12,
    VT_INDEX = 14
  };
  const flatbuffers::String *CategoryName() const {
    return GetPointer<const flatbuffers::String *>(VT_CATEGORYNAME);
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<double> *Matrix() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MATRIX);
  }
  const flatbuffers::Vector<int32_t> *RelPMI() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_RELPMI);
  }
  const flatbuffers::String *Index() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CATEGORYNAME) &&
           verifier.VerifyString(CategoryName()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyVector(Matrix()) &&
           VerifyOffset(verifier, VT_RELPMI) &&
           verifier.VerifyVector(RelPMI()) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(Index()) &&
           verifier.EndTable();
  }
};

struct ViewDataBuilder {
  typedef ViewData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CategoryName(flatbuffers::Offset<flatbuffers::String> CategoryName) {
    fbb_.AddOffset(ViewData::VT_CATEGORYNAME, CategoryName);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(ViewData::VT_ID, ID, 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(ViewData::VT_NAME, Name);
  }
  void add_Matrix(flatbuffers::Offset<flatbuffers::Vector<double>> Matrix) {
    fbb_.AddOffset(ViewData::VT_MATRIX, Matrix);
  }
  void add_RelPMI(flatbuffers::Offset<flatbuffers::Vector<int32_t>> RelPMI) {
    fbb_.AddOffset(ViewData::VT_RELPMI, RelPMI);
  }
  void add_Index(flatbuffers::Offset<flatbuffers::String> Index) {
    fbb_.AddOffset(ViewData::VT_INDEX, Index);
  }
  explicit ViewDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ViewDataBuilder &operator=(const ViewDataBuilder &);
  flatbuffers::Offset<ViewData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ViewData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ViewData> CreateViewData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> CategoryName = 0,
    int32_t ID = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Matrix = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> RelPMI = 0,
    flatbuffers::Offset<flatbuffers::String> Index = 0) {
  ViewDataBuilder builder_(_fbb);
  builder_.add_Index(Index);
  builder_.add_RelPMI(RelPMI);
  builder_.add_Matrix(Matrix);
  builder_.add_Name(Name);
  builder_.add_ID(ID);
  builder_.add_CategoryName(CategoryName);
  return builder_.Finish();
}

inline flatbuffers::Offset<ViewData> CreateViewDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *CategoryName = nullptr,
    int32_t ID = 0,
    const char *Name = nullptr,
    const std::vector<double> *Matrix = nullptr,
    const std::vector<int32_t> *RelPMI = nullptr,
    const char *Index = nullptr) {
  auto CategoryName__ = CategoryName ? _fbb.CreateString(CategoryName) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Matrix__ = Matrix ? _fbb.CreateVector<double>(*Matrix) : 0;
  auto RelPMI__ = RelPMI ? _fbb.CreateVector<int32_t>(*RelPMI) : 0;
  auto Index__ = Index ? _fbb.CreateString(Index) : 0;
  return FlatBufferDocSpace::CreateViewData(
      _fbb,
      CategoryName__,
      ID,
      Name__,
      Matrix__,
      RelPMI__,
      Index__);
}

struct ViewDataParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ViewDataParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *Value() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(Value()) &&
           verifier.VerifyVectorOfTables(Value()) &&
           verifier.EndTable();
  }
};

struct ViewDataParamBuilder {
  typedef ViewDataParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> Value) {
    fbb_.AddOffset(ViewDataParam::VT_VALUE, Value);
  }
  explicit ViewDataParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ViewDataParamBuilder &operator=(const ViewDataParamBuilder &);
  flatbuffers::Offset<ViewDataParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ViewDataParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ViewDataParam> CreateViewDataParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> Value = 0) {
  ViewDataParamBuilder builder_(_fbb);
  builder_.add_Value(Value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ViewDataParam> CreateViewDataParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *Value = nullptr) {
  auto Value__ = Value ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>(*Value) : 0;
  return FlatBufferDocSpace::CreateViewDataParam(
      _fbb,
      Value__);
}

struct IncrementalData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IncrementalDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDELEMENTS = 4,
    VT_MODELEMENTS = 6,
    VT_DELELEMENTS = 8,
    VT_ADDENTITIES = 10,
    VT_MODENTITIES = 12,
    VT_DELENTITIES = 14,
    VT_FEATUREDATAS = 16,
    VT_ADDVARIABLES = 18,
    VT_DELVARIABLES = 20,
    VT_MODVARIABLES = 22,
    VT_ADDANNOTVIEWS = 24,
    VT_DELANNOTVIEWS = 26,
    VT_MODANNOTVIEWS = 28,
    VT_ADDMATEREFS = 30,
    VT_MODMATEREFS = 32,
    VT_DELMATEREFS = 34,
    VT_QUICKTRIMPNTS = 36,
    VT_MATERIALS = 38,
    VT_APPEARANCEDATAS = 40,
    VT_TEXTUREDATAS = 42,
    VT_AI = 44,
    VT_ADDSIMULATIONS = 46,
    VT_MODSIMULATIONS = 48,
    VT_DELSIMULATIONS = 50
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *AddElements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_ADDELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ModElements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_MODELEMENTS);
  }
  const flatbuffers::Vector<int32_t> *DelElements() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *AddEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_ADDENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *ModEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_MODENTITIES);
  }
  const flatbuffers::Vector<int32_t> *DelEntities() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *>(VT_FEATUREDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *AddVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_ADDVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *DelVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *>(VT_DELVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *ModVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_MODVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *AddAnnotViews() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *>(VT_ADDANNOTVIEWS);
  }
  const flatbuffers::Vector<int32_t> *DelAnnotViews() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELANNOTVIEWS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *ModAnnotViews() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *>(VT_MODANNOTVIEWS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *AddMateRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *>(VT_ADDMATEREFS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *ModMateRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *>(VT_MODMATEREFS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *DelMateRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *>(VT_DELMATEREFS);
  }
  const flatbuffers::Vector<double> *QuickTrimPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_QUICKTRIMPNTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *Materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *AppearanceDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *>(VT_APPEARANCEDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *TextureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *>(VT_TEXTUREDATAS);
  }
  int32_t AI() const {
    return GetField<int32_t>(VT_AI, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *AddSimulations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *>(VT_ADDSIMULATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *ModSimulations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *>(VT_MODSIMULATIONS);
  }
  const flatbuffers::Vector<int32_t> *DelSimulations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELSIMULATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDELEMENTS) &&
           verifier.VerifyVector(AddElements()) &&
           verifier.VerifyVectorOfTables(AddElements()) &&
           VerifyOffset(verifier, VT_MODELEMENTS) &&
           verifier.VerifyVector(ModElements()) &&
           verifier.VerifyVectorOfTables(ModElements()) &&
           VerifyOffset(verifier, VT_DELELEMENTS) &&
           verifier.VerifyVector(DelElements()) &&
           VerifyOffset(verifier, VT_ADDENTITIES) &&
           verifier.VerifyVector(AddEntities()) &&
           verifier.VerifyVectorOfTables(AddEntities()) &&
           VerifyOffset(verifier, VT_MODENTITIES) &&
           verifier.VerifyVector(ModEntities()) &&
           verifier.VerifyVectorOfTables(ModEntities()) &&
           VerifyOffset(verifier, VT_DELENTITIES) &&
           verifier.VerifyVector(DelEntities()) &&
           VerifyOffset(verifier, VT_FEATUREDATAS) &&
           verifier.VerifyVector(FeatureDatas()) &&
           verifier.VerifyVectorOfTables(FeatureDatas()) &&
           VerifyOffset(verifier, VT_ADDVARIABLES) &&
           verifier.VerifyVector(AddVariables()) &&
           verifier.VerifyVectorOfTables(AddVariables()) &&
           VerifyOffset(verifier, VT_DELVARIABLES) &&
           verifier.VerifyVector(DelVariables()) &&
           verifier.VerifyVectorOfTables(DelVariables()) &&
           VerifyOffset(verifier, VT_MODVARIABLES) &&
           verifier.VerifyVector(ModVariables()) &&
           verifier.VerifyVectorOfTables(ModVariables()) &&
           VerifyOffset(verifier, VT_ADDANNOTVIEWS) &&
           verifier.VerifyVector(AddAnnotViews()) &&
           verifier.VerifyVectorOfTables(AddAnnotViews()) &&
           VerifyOffset(verifier, VT_DELANNOTVIEWS) &&
           verifier.VerifyVector(DelAnnotViews()) &&
           VerifyOffset(verifier, VT_MODANNOTVIEWS) &&
           verifier.VerifyVector(ModAnnotViews()) &&
           verifier.VerifyVectorOfTables(ModAnnotViews()) &&
           VerifyOffset(verifier, VT_ADDMATEREFS) &&
           verifier.VerifyVector(AddMateRefs()) &&
           verifier.VerifyVectorOfTables(AddMateRefs()) &&
           VerifyOffset(verifier, VT_MODMATEREFS) &&
           verifier.VerifyVector(ModMateRefs()) &&
           verifier.VerifyVectorOfTables(ModMateRefs()) &&
           VerifyOffset(verifier, VT_DELMATEREFS) &&
           verifier.VerifyVector(DelMateRefs()) &&
           verifier.VerifyVectorOfTables(DelMateRefs()) &&
           VerifyOffset(verifier, VT_QUICKTRIMPNTS) &&
           verifier.VerifyVector(QuickTrimPnts()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(Materials()) &&
           verifier.VerifyVectorOfTables(Materials()) &&
           VerifyOffset(verifier, VT_APPEARANCEDATAS) &&
           verifier.VerifyVector(AppearanceDatas()) &&
           verifier.VerifyVectorOfTables(AppearanceDatas()) &&
           VerifyOffset(verifier, VT_TEXTUREDATAS) &&
           verifier.VerifyVector(TextureDatas()) &&
           verifier.VerifyVectorOfTables(TextureDatas()) &&
           VerifyField<int32_t>(verifier, VT_AI) &&
           VerifyOffset(verifier, VT_ADDSIMULATIONS) &&
           verifier.VerifyVector(AddSimulations()) &&
           verifier.VerifyVectorOfTables(AddSimulations()) &&
           VerifyOffset(verifier, VT_MODSIMULATIONS) &&
           verifier.VerifyVector(ModSimulations()) &&
           verifier.VerifyVectorOfTables(ModSimulations()) &&
           VerifyOffset(verifier, VT_DELSIMULATIONS) &&
           verifier.VerifyVector(DelSimulations()) &&
           verifier.EndTable();
  }
};

struct IncrementalDataBuilder {
  typedef IncrementalData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AddElements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> AddElements) {
    fbb_.AddOffset(IncrementalData::VT_ADDELEMENTS, AddElements);
  }
  void add_ModElements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ModElements) {
    fbb_.AddOffset(IncrementalData::VT_MODELEMENTS, ModElements);
  }
  void add_DelElements(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelElements) {
    fbb_.AddOffset(IncrementalData::VT_DELELEMENTS, DelElements);
  }
  void add_AddEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> AddEntities) {
    fbb_.AddOffset(IncrementalData::VT_ADDENTITIES, AddEntities);
  }
  void add_ModEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> ModEntities) {
    fbb_.AddOffset(IncrementalData::VT_MODENTITIES, ModEntities);
  }
  void add_DelEntities(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelEntities) {
    fbb_.AddOffset(IncrementalData::VT_DELENTITIES, DelEntities);
  }
  void add_FeatureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas) {
    fbb_.AddOffset(IncrementalData::VT_FEATUREDATAS, FeatureDatas);
  }
  void add_AddVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> AddVariables) {
    fbb_.AddOffset(IncrementalData::VT_ADDVARIABLES, AddVariables);
  }
  void add_DelVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>> DelVariables) {
    fbb_.AddOffset(IncrementalData::VT_DELVARIABLES, DelVariables);
  }
  void add_ModVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> ModVariables) {
    fbb_.AddOffset(IncrementalData::VT_MODVARIABLES, ModVariables);
  }
  void add_AddAnnotViews(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> AddAnnotViews) {
    fbb_.AddOffset(IncrementalData::VT_ADDANNOTVIEWS, AddAnnotViews);
  }
  void add_DelAnnotViews(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelAnnotViews) {
    fbb_.AddOffset(IncrementalData::VT_DELANNOTVIEWS, DelAnnotViews);
  }
  void add_ModAnnotViews(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> ModAnnotViews) {
    fbb_.AddOffset(IncrementalData::VT_MODANNOTVIEWS, ModAnnotViews);
  }
  void add_AddMateRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> AddMateRefs) {
    fbb_.AddOffset(IncrementalData::VT_ADDMATEREFS, AddMateRefs);
  }
  void add_ModMateRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> ModMateRefs) {
    fbb_.AddOffset(IncrementalData::VT_MODMATEREFS, ModMateRefs);
  }
  void add_DelMateRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> DelMateRefs) {
    fbb_.AddOffset(IncrementalData::VT_DELMATEREFS, DelMateRefs);
  }
  void add_QuickTrimPnts(flatbuffers::Offset<flatbuffers::Vector<double>> QuickTrimPnts) {
    fbb_.AddOffset(IncrementalData::VT_QUICKTRIMPNTS, QuickTrimPnts);
  }
  void add_Materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>> Materials) {
    fbb_.AddOffset(IncrementalData::VT_MATERIALS, Materials);
  }
  void add_AppearanceDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>> AppearanceDatas) {
    fbb_.AddOffset(IncrementalData::VT_APPEARANCEDATAS, AppearanceDatas);
  }
  void add_TextureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>> TextureDatas) {
    fbb_.AddOffset(IncrementalData::VT_TEXTUREDATAS, TextureDatas);
  }
  void add_AI(int32_t AI) {
    fbb_.AddElement<int32_t>(IncrementalData::VT_AI, AI, 0);
  }
  void add_AddSimulations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> AddSimulations) {
    fbb_.AddOffset(IncrementalData::VT_ADDSIMULATIONS, AddSimulations);
  }
  void add_ModSimulations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> ModSimulations) {
    fbb_.AddOffset(IncrementalData::VT_MODSIMULATIONS, ModSimulations);
  }
  void add_DelSimulations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelSimulations) {
    fbb_.AddOffset(IncrementalData::VT_DELSIMULATIONS, DelSimulations);
  }
  explicit IncrementalDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IncrementalDataBuilder &operator=(const IncrementalDataBuilder &);
  flatbuffers::Offset<IncrementalData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IncrementalData>(end);
    return o;
  }
};

inline flatbuffers::Offset<IncrementalData> CreateIncrementalData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> AddElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ModElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> AddEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> ModEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> AddVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>> DelVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> ModVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> AddAnnotViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelAnnotViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> ModAnnotViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> AddMateRefs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> ModMateRefs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> DelMateRefs = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> QuickTrimPnts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>> Materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>> AppearanceDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>> TextureDatas = 0,
    int32_t AI = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> AddSimulations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> ModSimulations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelSimulations = 0) {
  IncrementalDataBuilder builder_(_fbb);
  builder_.add_DelSimulations(DelSimulations);
  builder_.add_ModSimulations(ModSimulations);
  builder_.add_AddSimulations(AddSimulations);
  builder_.add_AI(AI);
  builder_.add_TextureDatas(TextureDatas);
  builder_.add_AppearanceDatas(AppearanceDatas);
  builder_.add_Materials(Materials);
  builder_.add_QuickTrimPnts(QuickTrimPnts);
  builder_.add_DelMateRefs(DelMateRefs);
  builder_.add_ModMateRefs(ModMateRefs);
  builder_.add_AddMateRefs(AddMateRefs);
  builder_.add_ModAnnotViews(ModAnnotViews);
  builder_.add_DelAnnotViews(DelAnnotViews);
  builder_.add_AddAnnotViews(AddAnnotViews);
  builder_.add_ModVariables(ModVariables);
  builder_.add_DelVariables(DelVariables);
  builder_.add_AddVariables(AddVariables);
  builder_.add_FeatureDatas(FeatureDatas);
  builder_.add_DelEntities(DelEntities);
  builder_.add_ModEntities(ModEntities);
  builder_.add_AddEntities(AddEntities);
  builder_.add_DelElements(DelElements);
  builder_.add_ModElements(ModElements);
  builder_.add_AddElements(AddElements);
  return builder_.Finish();
}

inline flatbuffers::Offset<IncrementalData> CreateIncrementalDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *AddElements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ModElements = nullptr,
    const std::vector<int32_t> *DelElements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *AddEntities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *ModEntities = nullptr,
    const std::vector<int32_t> *DelEntities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *AddVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *DelVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *ModVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *AddAnnotViews = nullptr,
    const std::vector<int32_t> *DelAnnotViews = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *ModAnnotViews = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *AddMateRefs = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *ModMateRefs = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *DelMateRefs = nullptr,
    const std::vector<double> *QuickTrimPnts = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *Materials = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *AppearanceDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *TextureDatas = nullptr,
    int32_t AI = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *AddSimulations = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *ModSimulations = nullptr,
    const std::vector<int32_t> *DelSimulations = nullptr) {
  auto AddElements__ = AddElements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*AddElements) : 0;
  auto ModElements__ = ModElements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*ModElements) : 0;
  auto DelElements__ = DelElements ? _fbb.CreateVector<int32_t>(*DelElements) : 0;
  auto AddEntities__ = AddEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*AddEntities) : 0;
  auto ModEntities__ = ModEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*ModEntities) : 0;
  auto DelEntities__ = DelEntities ? _fbb.CreateVector<int32_t>(*DelEntities) : 0;
  auto FeatureDatas__ = FeatureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>(*FeatureDatas) : 0;
  auto AddVariables__ = AddVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*AddVariables) : 0;
  auto DelVariables__ = DelVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>(*DelVariables) : 0;
  auto ModVariables__ = ModVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*ModVariables) : 0;
  auto AddAnnotViews__ = AddAnnotViews ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>(*AddAnnotViews) : 0;
  auto DelAnnotViews__ = DelAnnotViews ? _fbb.CreateVector<int32_t>(*DelAnnotViews) : 0;
  auto ModAnnotViews__ = ModAnnotViews ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>(*ModAnnotViews) : 0;
  auto AddMateRefs__ = AddMateRefs ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>(*AddMateRefs) : 0;
  auto ModMateRefs__ = ModMateRefs ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>(*ModMateRefs) : 0;
  auto DelMateRefs__ = DelMateRefs ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>(*DelMateRefs) : 0;
  auto QuickTrimPnts__ = QuickTrimPnts ? _fbb.CreateVector<double>(*QuickTrimPnts) : 0;
  auto Materials__ = Materials ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>(*Materials) : 0;
  auto AppearanceDatas__ = AppearanceDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>(*AppearanceDatas) : 0;
  auto TextureDatas__ = TextureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>(*TextureDatas) : 0;
  auto AddSimulations__ = AddSimulations ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>(*AddSimulations) : 0;
  auto ModSimulations__ = ModSimulations ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>(*ModSimulations) : 0;
  auto DelSimulations__ = DelSimulations ? _fbb.CreateVector<int32_t>(*DelSimulations) : 0;
  return FlatBufferDocSpace::CreateIncrementalData(
      _fbb,
      AddElements__,
      ModElements__,
      DelElements__,
      AddEntities__,
      ModEntities__,
      DelEntities__,
      FeatureDatas__,
      AddVariables__,
      DelVariables__,
      ModVariables__,
      AddAnnotViews__,
      DelAnnotViews__,
      ModAnnotViews__,
      AddMateRefs__,
      ModMateRefs__,
      DelMateRefs__,
      QuickTrimPnts__,
      Materials__,
      AppearanceDatas__,
      TextureDatas__,
      AI,
      AddSimulations__,
      ModSimulations__,
      DelSimulations__);
}

struct CutInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CutInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AREA = 4,
    VT_VOLUME = 6,
    VT_MATERIAL = 8,
    VT_LENGTH = 10,
    VT_TOTALLENGTH = 12,
    VT_ANGLE1 = 14,
    VT_ANGLE2 = 16,
    VT_ANGLEDIR = 18,
    VT_ANGLEROT = 20,
    VT_DESCR = 22,
    VT_QUANTITY = 24,
    VT_MASS = 26
  };
  double Area() const {
    return GetField<double>(VT_AREA, 0.0);
  }
  double Volume() const {
    return GetField<double>(VT_VOLUME, 0.0);
  }
  const flatbuffers::String *Material() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIAL);
  }
  double Length() const {
    return GetField<double>(VT_LENGTH, 0.0);
  }
  double TotalLength() const {
    return GetField<double>(VT_TOTALLENGTH, 0.0);
  }
  double Angle1() const {
    return GetField<double>(VT_ANGLE1, 0.0);
  }
  double Angle2() const {
    return GetField<double>(VT_ANGLE2, 0.0);
  }
  const flatbuffers::String *AngleDir() const {
    return GetPointer<const flatbuffers::String *>(VT_ANGLEDIR);
  }
  double AngleRot() const {
    return GetField<double>(VT_ANGLEROT, 0.0);
  }
  const flatbuffers::String *Descr() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCR);
  }
  int32_t Quantity() const {
    return GetField<int32_t>(VT_QUANTITY, 0);
  }
  double Mass() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AREA) &&
           VerifyField<double>(verifier, VT_VOLUME) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyString(Material()) &&
           VerifyField<double>(verifier, VT_LENGTH) &&
           VerifyField<double>(verifier, VT_TOTALLENGTH) &&
           VerifyField<double>(verifier, VT_ANGLE1) &&
           VerifyField<double>(verifier, VT_ANGLE2) &&
           VerifyOffset(verifier, VT_ANGLEDIR) &&
           verifier.VerifyString(AngleDir()) &&
           VerifyField<double>(verifier, VT_ANGLEROT) &&
           VerifyOffset(verifier, VT_DESCR) &&
           verifier.VerifyString(Descr()) &&
           VerifyField<int32_t>(verifier, VT_QUANTITY) &&
           VerifyField<double>(verifier, VT_MASS) &&
           verifier.EndTable();
  }
};

struct CutInfoDataBuilder {
  typedef CutInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Area(double Area) {
    fbb_.AddElement<double>(CutInfoData::VT_AREA, Area, 0.0);
  }
  void add_Volume(double Volume) {
    fbb_.AddElement<double>(CutInfoData::VT_VOLUME, Volume, 0.0);
  }
  void add_Material(flatbuffers::Offset<flatbuffers::String> Material) {
    fbb_.AddOffset(CutInfoData::VT_MATERIAL, Material);
  }
  void add_Length(double Length) {
    fbb_.AddElement<double>(CutInfoData::VT_LENGTH, Length, 0.0);
  }
  void add_TotalLength(double TotalLength) {
    fbb_.AddElement<double>(CutInfoData::VT_TOTALLENGTH, TotalLength, 0.0);
  }
  void add_Angle1(double Angle1) {
    fbb_.AddElement<double>(CutInfoData::VT_ANGLE1, Angle1, 0.0);
  }
  void add_Angle2(double Angle2) {
    fbb_.AddElement<double>(CutInfoData::VT_ANGLE2, Angle2, 0.0);
  }
  void add_AngleDir(flatbuffers::Offset<flatbuffers::String> AngleDir) {
    fbb_.AddOffset(CutInfoData::VT_ANGLEDIR, AngleDir);
  }
  void add_AngleRot(double AngleRot) {
    fbb_.AddElement<double>(CutInfoData::VT_ANGLEROT, AngleRot, 0.0);
  }
  void add_Descr(flatbuffers::Offset<flatbuffers::String> Descr) {
    fbb_.AddOffset(CutInfoData::VT_DESCR, Descr);
  }
  void add_Quantity(int32_t Quantity) {
    fbb_.AddElement<int32_t>(CutInfoData::VT_QUANTITY, Quantity, 0);
  }
  void add_Mass(double Mass) {
    fbb_.AddElement<double>(CutInfoData::VT_MASS, Mass, 0.0);
  }
  explicit CutInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CutInfoDataBuilder &operator=(const CutInfoDataBuilder &);
  flatbuffers::Offset<CutInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CutInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CutInfoData> CreateCutInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double Area = 0.0,
    double Volume = 0.0,
    flatbuffers::Offset<flatbuffers::String> Material = 0,
    double Length = 0.0,
    double TotalLength = 0.0,
    double Angle1 = 0.0,
    double Angle2 = 0.0,
    flatbuffers::Offset<flatbuffers::String> AngleDir = 0,
    double AngleRot = 0.0,
    flatbuffers::Offset<flatbuffers::String> Descr = 0,
    int32_t Quantity = 0,
    double Mass = 0.0) {
  CutInfoDataBuilder builder_(_fbb);
  builder_.add_Mass(Mass);
  builder_.add_AngleRot(AngleRot);
  builder_.add_Angle2(Angle2);
  builder_.add_Angle1(Angle1);
  builder_.add_TotalLength(TotalLength);
  builder_.add_Length(Length);
  builder_.add_Volume(Volume);
  builder_.add_Area(Area);
  builder_.add_Quantity(Quantity);
  builder_.add_Descr(Descr);
  builder_.add_AngleDir(AngleDir);
  builder_.add_Material(Material);
  return builder_.Finish();
}

inline flatbuffers::Offset<CutInfoData> CreateCutInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double Area = 0.0,
    double Volume = 0.0,
    const char *Material = nullptr,
    double Length = 0.0,
    double TotalLength = 0.0,
    double Angle1 = 0.0,
    double Angle2 = 0.0,
    const char *AngleDir = nullptr,
    double AngleRot = 0.0,
    const char *Descr = nullptr,
    int32_t Quantity = 0,
    double Mass = 0.0) {
  auto Material__ = Material ? _fbb.CreateString(Material) : 0;
  auto AngleDir__ = AngleDir ? _fbb.CreateString(AngleDir) : 0;
  auto Descr__ = Descr ? _fbb.CreateString(Descr) : 0;
  return FlatBufferDocSpace::CreateCutInfoData(
      _fbb,
      Area,
      Volume,
      Material__,
      Length,
      TotalLength,
      Angle1,
      Angle2,
      AngleDir__,
      AngleRot,
      Descr__,
      Quantity,
      Mass);
}

struct CutUserDefData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CutUserDefDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *Value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           verifier.EndTable();
  }
};

struct CutUserDefDataBuilder {
  typedef CutUserDefData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(CutUserDefData::VT_NAME, Name);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(CutUserDefData::VT_TYPE, Type, 0);
  }
  void add_Value(flatbuffers::Offset<flatbuffers::String> Value) {
    fbb_.AddOffset(CutUserDefData::VT_VALUE, Value);
  }
  explicit CutUserDefDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CutUserDefDataBuilder &operator=(const CutUserDefDataBuilder &);
  flatbuffers::Offset<CutUserDefData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CutUserDefData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CutUserDefData> CreateCutUserDefData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t Type = 0,
    flatbuffers::Offset<flatbuffers::String> Value = 0) {
  CutUserDefDataBuilder builder_(_fbb);
  builder_.add_Value(Value);
  builder_.add_Type(Type);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CutUserDefData> CreateCutUserDefDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    int32_t Type = 0,
    const char *Value = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  return FlatBufferDocSpace::CreateCutUserDefData(
      _fbb,
      Name__,
      Type,
      Value__);
}

struct CutGroupData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CutGroupDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUPNAME = 4,
    VT_TEMPNAME = 6,
    VT_TYPE = 8,
    VT_ID = 10,
    VT_ENTITYIDS = 12,
    VT_INFO = 14,
    VT_USERDEF = 16,
    VT_ISEXCLUDED = 18
  };
  const flatbuffers::String *GroupName() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUPNAME);
  }
  const flatbuffers::String *TempName() const {
    return GetPointer<const flatbuffers::String *>(VT_TEMPNAME);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<int32_t> *EntityIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENTITYIDS);
  }
  const FlatBufferDocSpace::CutInfoData *Info() const {
    return GetPointer<const FlatBufferDocSpace::CutInfoData *>(VT_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutUserDefData>> *UserDef() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutUserDefData>> *>(VT_USERDEF);
  }
  bool IsExcluded() const {
    return GetField<uint8_t>(VT_ISEXCLUDED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUPNAME) &&
           verifier.VerifyString(GroupName()) &&
           VerifyOffset(verifier, VT_TEMPNAME) &&
           verifier.VerifyString(TempName()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_ENTITYIDS) &&
           verifier.VerifyVector(EntityIds()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(Info()) &&
           VerifyOffset(verifier, VT_USERDEF) &&
           verifier.VerifyVector(UserDef()) &&
           verifier.VerifyVectorOfTables(UserDef()) &&
           VerifyField<uint8_t>(verifier, VT_ISEXCLUDED) &&
           verifier.EndTable();
  }
};

struct CutGroupDataBuilder {
  typedef CutGroupData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GroupName(flatbuffers::Offset<flatbuffers::String> GroupName) {
    fbb_.AddOffset(CutGroupData::VT_GROUPNAME, GroupName);
  }
  void add_TempName(flatbuffers::Offset<flatbuffers::String> TempName) {
    fbb_.AddOffset(CutGroupData::VT_TEMPNAME, TempName);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(CutGroupData::VT_TYPE, Type, 0);
  }
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(CutGroupData::VT_ID, Id, 0);
  }
  void add_EntityIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> EntityIds) {
    fbb_.AddOffset(CutGroupData::VT_ENTITYIDS, EntityIds);
  }
  void add_Info(flatbuffers::Offset<FlatBufferDocSpace::CutInfoData> Info) {
    fbb_.AddOffset(CutGroupData::VT_INFO, Info);
  }
  void add_UserDef(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutUserDefData>>> UserDef) {
    fbb_.AddOffset(CutGroupData::VT_USERDEF, UserDef);
  }
  void add_IsExcluded(bool IsExcluded) {
    fbb_.AddElement<uint8_t>(CutGroupData::VT_ISEXCLUDED, static_cast<uint8_t>(IsExcluded), 0);
  }
  explicit CutGroupDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CutGroupDataBuilder &operator=(const CutGroupDataBuilder &);
  flatbuffers::Offset<CutGroupData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CutGroupData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CutGroupData> CreateCutGroupData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> GroupName = 0,
    flatbuffers::Offset<flatbuffers::String> TempName = 0,
    int32_t Type = 0,
    int32_t Id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> EntityIds = 0,
    flatbuffers::Offset<FlatBufferDocSpace::CutInfoData> Info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutUserDefData>>> UserDef = 0,
    bool IsExcluded = false) {
  CutGroupDataBuilder builder_(_fbb);
  builder_.add_UserDef(UserDef);
  builder_.add_Info(Info);
  builder_.add_EntityIds(EntityIds);
  builder_.add_Id(Id);
  builder_.add_Type(Type);
  builder_.add_TempName(TempName);
  builder_.add_GroupName(GroupName);
  builder_.add_IsExcluded(IsExcluded);
  return builder_.Finish();
}

inline flatbuffers::Offset<CutGroupData> CreateCutGroupDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *GroupName = nullptr,
    const char *TempName = nullptr,
    int32_t Type = 0,
    int32_t Id = 0,
    const std::vector<int32_t> *EntityIds = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::CutInfoData> Info = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CutUserDefData>> *UserDef = nullptr,
    bool IsExcluded = false) {
  auto GroupName__ = GroupName ? _fbb.CreateString(GroupName) : 0;
  auto TempName__ = TempName ? _fbb.CreateString(TempName) : 0;
  auto EntityIds__ = EntityIds ? _fbb.CreateVector<int32_t>(*EntityIds) : 0;
  auto UserDef__ = UserDef ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CutUserDefData>>(*UserDef) : 0;
  return FlatBufferDocSpace::CreateCutGroupData(
      _fbb,
      GroupName__,
      TempName__,
      Type,
      Id,
      EntityIds__,
      Info,
      UserDef__,
      IsExcluded);
}

struct RepeatGroupData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RepeatGroupDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITYIDS = 4,
    VT_TRANSMATS = 6
  };
  const flatbuffers::Vector<int32_t> *EntityIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENTITYIDS);
  }
  const flatbuffers::Vector<double> *TransMats() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_TRANSMATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITYIDS) &&
           verifier.VerifyVector(EntityIds()) &&
           VerifyOffset(verifier, VT_TRANSMATS) &&
           verifier.VerifyVector(TransMats()) &&
           verifier.EndTable();
  }
};

struct RepeatGroupDataBuilder {
  typedef RepeatGroupData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_EntityIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> EntityIds) {
    fbb_.AddOffset(RepeatGroupData::VT_ENTITYIDS, EntityIds);
  }
  void add_TransMats(flatbuffers::Offset<flatbuffers::Vector<double>> TransMats) {
    fbb_.AddOffset(RepeatGroupData::VT_TRANSMATS, TransMats);
  }
  explicit RepeatGroupDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RepeatGroupDataBuilder &operator=(const RepeatGroupDataBuilder &);
  flatbuffers::Offset<RepeatGroupData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RepeatGroupData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RepeatGroupData> CreateRepeatGroupData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> EntityIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> TransMats = 0) {
  RepeatGroupDataBuilder builder_(_fbb);
  builder_.add_TransMats(TransMats);
  builder_.add_EntityIds(EntityIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<RepeatGroupData> CreateRepeatGroupDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *EntityIds = nullptr,
    const std::vector<double> *TransMats = nullptr) {
  auto EntityIds__ = EntityIds ? _fbb.CreateVector<int32_t>(*EntityIds) : 0;
  auto TransMats__ = TransMats ? _fbb.CreateVector<double>(*TransMats) : 0;
  return FlatBufferDocSpace::CreateRepeatGroupData(
      _fbb,
      EntityIds__,
      TransMats__);
}

struct AssemblyPartData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssemblyPartDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCES = 4,
    VT_MATINGS = 6,
    VT_MATEREFS = 8,
    VT_FEATUREDATAS = 10,
    VT_INSTANCETREE = 12,
    VT_ELEMENTS = 14,
    VT_ENTITIES = 16,
    VT_TYPE = 18,
    VT_VARIABLES = 20,
    VT_PROTODATAS = 22,
    VT_VIEWDATAS = 24,
    VT_CUTLISTDATAS = 26,
    VT_APPEARANCEDATAS = 28,
    VT_TEXTUREDATAS = 30,
    VT_AI = 32,
    VT_MATERIALS = 34,
    VT_REPEATENTITIES = 36,
    VT_SIMULATIONS = 38
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *Instances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *>(VT_INSTANCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *Matings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *>(VT_MATINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *MateRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *>(VT_MATEREFS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *>(VT_FEATUREDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *InstanceTree() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *>(VT_INSTANCETREE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Elements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_ELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *Entities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_ENTITIES);
  }
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *Variables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_VARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>> *ProtoDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>> *>(VT_PROTODATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *ViewDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *>(VT_VIEWDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>> *CutListDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>> *>(VT_CUTLISTDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *AppearanceDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *>(VT_APPEARANCEDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *TextureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *>(VT_TEXTUREDATAS);
  }
  int32_t AI() const {
    return GetField<int32_t>(VT_AI, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *Materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>> *RepeatEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>> *>(VT_REPEATENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *Simulations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *>(VT_SIMULATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(Instances()) &&
           verifier.VerifyVectorOfTables(Instances()) &&
           VerifyOffset(verifier, VT_MATINGS) &&
           verifier.VerifyVector(Matings()) &&
           verifier.VerifyVectorOfTables(Matings()) &&
           VerifyOffset(verifier, VT_MATEREFS) &&
           verifier.VerifyVector(MateRefs()) &&
           verifier.VerifyVectorOfTables(MateRefs()) &&
           VerifyOffset(verifier, VT_FEATUREDATAS) &&
           verifier.VerifyVector(FeatureDatas()) &&
           verifier.VerifyVectorOfTables(FeatureDatas()) &&
           VerifyOffset(verifier, VT_INSTANCETREE) &&
           verifier.VerifyVector(InstanceTree()) &&
           verifier.VerifyVectorOfTables(InstanceTree()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(Elements()) &&
           verifier.VerifyVectorOfTables(Elements()) &&
           VerifyOffset(verifier, VT_ENTITIES) &&
           verifier.VerifyVector(Entities()) &&
           verifier.VerifyVectorOfTables(Entities()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(Variables()) &&
           verifier.VerifyVectorOfTables(Variables()) &&
           VerifyOffset(verifier, VT_PROTODATAS) &&
           verifier.VerifyVector(ProtoDatas()) &&
           verifier.VerifyVectorOfTables(ProtoDatas()) &&
           VerifyOffset(verifier, VT_VIEWDATAS) &&
           verifier.VerifyVector(ViewDatas()) &&
           verifier.VerifyVectorOfTables(ViewDatas()) &&
           VerifyOffset(verifier, VT_CUTLISTDATAS) &&
           verifier.VerifyVector(CutListDatas()) &&
           verifier.VerifyVectorOfTables(CutListDatas()) &&
           VerifyOffset(verifier, VT_APPEARANCEDATAS) &&
           verifier.VerifyVector(AppearanceDatas()) &&
           verifier.VerifyVectorOfTables(AppearanceDatas()) &&
           VerifyOffset(verifier, VT_TEXTUREDATAS) &&
           verifier.VerifyVector(TextureDatas()) &&
           verifier.VerifyVectorOfTables(TextureDatas()) &&
           VerifyField<int32_t>(verifier, VT_AI) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(Materials()) &&
           verifier.VerifyVectorOfTables(Materials()) &&
           VerifyOffset(verifier, VT_REPEATENTITIES) &&
           verifier.VerifyVector(RepeatEntities()) &&
           verifier.VerifyVectorOfTables(RepeatEntities()) &&
           VerifyOffset(verifier, VT_SIMULATIONS) &&
           verifier.VerifyVector(Simulations()) &&
           verifier.VerifyVectorOfTables(Simulations()) &&
           verifier.EndTable();
  }
};

struct AssemblyPartDataBuilder {
  typedef AssemblyPartData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Instances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>> Instances) {
    fbb_.AddOffset(AssemblyPartData::VT_INSTANCES, Instances);
  }
  void add_Matings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> Matings) {
    fbb_.AddOffset(AssemblyPartData::VT_MATINGS, Matings);
  }
  void add_MateRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> MateRefs) {
    fbb_.AddOffset(AssemblyPartData::VT_MATEREFS, MateRefs);
  }
  void add_FeatureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas) {
    fbb_.AddOffset(AssemblyPartData::VT_FEATUREDATAS, FeatureDatas);
  }
  void add_InstanceTree(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>> InstanceTree) {
    fbb_.AddOffset(AssemblyPartData::VT_INSTANCETREE, InstanceTree);
  }
  void add_Elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Elements) {
    fbb_.AddOffset(AssemblyPartData::VT_ELEMENTS, Elements);
  }
  void add_Entities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> Entities) {
    fbb_.AddOffset(AssemblyPartData::VT_ENTITIES, Entities);
  }
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(AssemblyPartData::VT_TYPE, Type);
  }
  void add_Variables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> Variables) {
    fbb_.AddOffset(AssemblyPartData::VT_VARIABLES, Variables);
  }
  void add_ProtoDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>>> ProtoDatas) {
    fbb_.AddOffset(AssemblyPartData::VT_PROTODATAS, ProtoDatas);
  }
  void add_ViewDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> ViewDatas) {
    fbb_.AddOffset(AssemblyPartData::VT_VIEWDATAS, ViewDatas);
  }
  void add_CutListDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>>> CutListDatas) {
    fbb_.AddOffset(AssemblyPartData::VT_CUTLISTDATAS, CutListDatas);
  }
  void add_AppearanceDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>> AppearanceDatas) {
    fbb_.AddOffset(AssemblyPartData::VT_APPEARANCEDATAS, AppearanceDatas);
  }
  void add_TextureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>> TextureDatas) {
    fbb_.AddOffset(AssemblyPartData::VT_TEXTUREDATAS, TextureDatas);
  }
  void add_AI(int32_t AI) {
    fbb_.AddElement<int32_t>(AssemblyPartData::VT_AI, AI, 0);
  }
  void add_Materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>> Materials) {
    fbb_.AddOffset(AssemblyPartData::VT_MATERIALS, Materials);
  }
  void add_RepeatEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>>> RepeatEntities) {
    fbb_.AddOffset(AssemblyPartData::VT_REPEATENTITIES, RepeatEntities);
  }
  void add_Simulations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> Simulations) {
    fbb_.AddOffset(AssemblyPartData::VT_SIMULATIONS, Simulations);
  }
  explicit AssemblyPartDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssemblyPartDataBuilder &operator=(const AssemblyPartDataBuilder &);
  flatbuffers::Offset<AssemblyPartData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssemblyPartData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssemblyPartData> CreateAssemblyPartData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>> Instances = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> Matings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> MateRefs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>> InstanceTree = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Elements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> Entities = 0,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> Variables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>>> ProtoDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> ViewDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>>> CutListDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>> AppearanceDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>> TextureDatas = 0,
    int32_t AI = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>> Materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>>> RepeatEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> Simulations = 0) {
  AssemblyPartDataBuilder builder_(_fbb);
  builder_.add_Simulations(Simulations);
  builder_.add_RepeatEntities(RepeatEntities);
  builder_.add_Materials(Materials);
  builder_.add_AI(AI);
  builder_.add_TextureDatas(TextureDatas);
  builder_.add_AppearanceDatas(AppearanceDatas);
  builder_.add_CutListDatas(CutListDatas);
  builder_.add_ViewDatas(ViewDatas);
  builder_.add_ProtoDatas(ProtoDatas);
  builder_.add_Variables(Variables);
  builder_.add_Type(Type);
  builder_.add_Entities(Entities);
  builder_.add_Elements(Elements);
  builder_.add_InstanceTree(InstanceTree);
  builder_.add_FeatureDatas(FeatureDatas);
  builder_.add_MateRefs(MateRefs);
  builder_.add_Matings(Matings);
  builder_.add_Instances(Instances);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssemblyPartData> CreateAssemblyPartDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *Instances = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *Matings = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *MateRefs = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>> *InstanceTree = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Elements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *Entities = nullptr,
    const char *Type = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *Variables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>> *ProtoDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *ViewDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>> *CutListDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *AppearanceDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *TextureDatas = nullptr,
    int32_t AI = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *Materials = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>> *RepeatEntities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *Simulations = nullptr) {
  auto Instances__ = Instances ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>(*Instances) : 0;
  auto Matings__ = Matings ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>(*Matings) : 0;
  auto MateRefs__ = MateRefs ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>(*MateRefs) : 0;
  auto FeatureDatas__ = FeatureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>(*FeatureDatas) : 0;
  auto InstanceTree__ = InstanceTree ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::InstanceNode>>(*InstanceTree) : 0;
  auto Elements__ = Elements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*Elements) : 0;
  auto Entities__ = Entities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*Entities) : 0;
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto Variables__ = Variables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*Variables) : 0;
  auto ProtoDatas__ = ProtoDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>>(*ProtoDatas) : 0;
  auto ViewDatas__ = ViewDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>(*ViewDatas) : 0;
  auto CutListDatas__ = CutListDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>>(*CutListDatas) : 0;
  auto AppearanceDatas__ = AppearanceDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>(*AppearanceDatas) : 0;
  auto TextureDatas__ = TextureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>(*TextureDatas) : 0;
  auto Materials__ = Materials ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>(*Materials) : 0;
  auto RepeatEntities__ = RepeatEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>>(*RepeatEntities) : 0;
  auto Simulations__ = Simulations ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>(*Simulations) : 0;
  return FlatBufferDocSpace::CreateAssemblyPartData(
      _fbb,
      Instances__,
      Matings__,
      MateRefs__,
      FeatureDatas__,
      InstanceTree__,
      Elements__,
      Entities__,
      Type__,
      Variables__,
      ProtoDatas__,
      ViewDatas__,
      CutListDatas__,
      AppearanceDatas__,
      TextureDatas__,
      AI,
      Materials__,
      RepeatEntities__,
      Simulations__);
}

struct InitDataForPart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitDataForPartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDODATA = 4,
    VT_UNDODATA = 6
  };
  const FlatBufferDocSpace::IncrementalData *RedoData() const {
    return GetPointer<const FlatBufferDocSpace::IncrementalData *>(VT_REDODATA);
  }
  const flatbuffers::Vector<int32_t> *UndoData() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_UNDODATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REDODATA) &&
           verifier.VerifyTable(RedoData()) &&
           VerifyOffset(verifier, VT_UNDODATA) &&
           verifier.VerifyVector(UndoData()) &&
           verifier.EndTable();
  }
};

struct InitDataForPartBuilder {
  typedef InitDataForPart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RedoData(flatbuffers::Offset<FlatBufferDocSpace::IncrementalData> RedoData) {
    fbb_.AddOffset(InitDataForPart::VT_REDODATA, RedoData);
  }
  void add_UndoData(flatbuffers::Offset<flatbuffers::Vector<int32_t>> UndoData) {
    fbb_.AddOffset(InitDataForPart::VT_UNDODATA, UndoData);
  }
  explicit InitDataForPartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitDataForPartBuilder &operator=(const InitDataForPartBuilder &);
  flatbuffers::Offset<InitDataForPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitDataForPart>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitDataForPart> CreateInitDataForPart(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::IncrementalData> RedoData = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> UndoData = 0) {
  InitDataForPartBuilder builder_(_fbb);
  builder_.add_UndoData(UndoData);
  builder_.add_RedoData(RedoData);
  return builder_.Finish();
}

inline flatbuffers::Offset<InitDataForPart> CreateInitDataForPartDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::IncrementalData> RedoData = 0,
    const std::vector<int32_t> *UndoData = nullptr) {
  auto UndoData__ = UndoData ? _fbb.CreateVector<int32_t>(*UndoData) : 0;
  return FlatBufferDocSpace::CreateInitDataForPart(
      _fbb,
      RedoData,
      UndoData__);
}

struct InitDataForAssembly FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitDataForAssemblyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDODATA = 4,
    VT_UNDODATA = 6
  };
  const FlatBufferDocSpace::IncrementalCompData *RedoData() const {
    return GetPointer<const FlatBufferDocSpace::IncrementalCompData *>(VT_REDODATA);
  }
  const flatbuffers::Vector<int32_t> *UndoData() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_UNDODATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REDODATA) &&
           verifier.VerifyTable(RedoData()) &&
           VerifyOffset(verifier, VT_UNDODATA) &&
           verifier.VerifyVector(UndoData()) &&
           verifier.EndTable();
  }
};

struct InitDataForAssemblyBuilder {
  typedef InitDataForAssembly Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RedoData(flatbuffers::Offset<FlatBufferDocSpace::IncrementalCompData> RedoData) {
    fbb_.AddOffset(InitDataForAssembly::VT_REDODATA, RedoData);
  }
  void add_UndoData(flatbuffers::Offset<flatbuffers::Vector<int32_t>> UndoData) {
    fbb_.AddOffset(InitDataForAssembly::VT_UNDODATA, UndoData);
  }
  explicit InitDataForAssemblyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitDataForAssemblyBuilder &operator=(const InitDataForAssemblyBuilder &);
  flatbuffers::Offset<InitDataForAssembly> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitDataForAssembly>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitDataForAssembly> CreateInitDataForAssembly(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::IncrementalCompData> RedoData = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> UndoData = 0) {
  InitDataForAssemblyBuilder builder_(_fbb);
  builder_.add_UndoData(UndoData);
  builder_.add_RedoData(RedoData);
  return builder_.Finish();
}

inline flatbuffers::Offset<InitDataForAssembly> CreateInitDataForAssemblyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::IncrementalCompData> RedoData = 0,
    const std::vector<int32_t> *UndoData = nullptr) {
  auto UndoData__ = UndoData ? _fbb.CreateVector<int32_t>(*UndoData) : 0;
  return FlatBufferDocSpace::CreateInitDataForAssembly(
      _fbb,
      RedoData,
      UndoData__);
}

struct PlaneAxisData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlaneAxisDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXISTYPE = 4,
    VT_LINEID = 6,
    VT_COMPID = 8,
    VT_PNT1 = 10,
    VT_PNT2 = 12
  };
  int32_t AxisType() const {
    return GetField<int32_t>(VT_AXISTYPE, 0);
  }
  int32_t LineId() const {
    return GetField<int32_t>(VT_LINEID, 0);
  }
  const flatbuffers::String *CompId() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPID);
  }
  const FlatBufferDocSpace::SnapPoint *Pnt1() const {
    return GetPointer<const FlatBufferDocSpace::SnapPoint *>(VT_PNT1);
  }
  const FlatBufferDocSpace::SnapPoint *Pnt2() const {
    return GetPointer<const FlatBufferDocSpace::SnapPoint *>(VT_PNT2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXISTYPE) &&
           VerifyField<int32_t>(verifier, VT_LINEID) &&
           VerifyOffset(verifier, VT_COMPID) &&
           verifier.VerifyString(CompId()) &&
           VerifyOffset(verifier, VT_PNT1) &&
           verifier.VerifyTable(Pnt1()) &&
           VerifyOffset(verifier, VT_PNT2) &&
           verifier.VerifyTable(Pnt2()) &&
           verifier.EndTable();
  }
};

struct PlaneAxisDataBuilder {
  typedef PlaneAxisData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AxisType(int32_t AxisType) {
    fbb_.AddElement<int32_t>(PlaneAxisData::VT_AXISTYPE, AxisType, 0);
  }
  void add_LineId(int32_t LineId) {
    fbb_.AddElement<int32_t>(PlaneAxisData::VT_LINEID, LineId, 0);
  }
  void add_CompId(flatbuffers::Offset<flatbuffers::String> CompId) {
    fbb_.AddOffset(PlaneAxisData::VT_COMPID, CompId);
  }
  void add_Pnt1(flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt1) {
    fbb_.AddOffset(PlaneAxisData::VT_PNT1, Pnt1);
  }
  void add_Pnt2(flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt2) {
    fbb_.AddOffset(PlaneAxisData::VT_PNT2, Pnt2);
  }
  explicit PlaneAxisDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlaneAxisDataBuilder &operator=(const PlaneAxisDataBuilder &);
  flatbuffers::Offset<PlaneAxisData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlaneAxisData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlaneAxisData> CreatePlaneAxisData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t AxisType = 0,
    int32_t LineId = 0,
    flatbuffers::Offset<flatbuffers::String> CompId = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt1 = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt2 = 0) {
  PlaneAxisDataBuilder builder_(_fbb);
  builder_.add_Pnt2(Pnt2);
  builder_.add_Pnt1(Pnt1);
  builder_.add_CompId(CompId);
  builder_.add_LineId(LineId);
  builder_.add_AxisType(AxisType);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlaneAxisData> CreatePlaneAxisDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t AxisType = 0,
    int32_t LineId = 0,
    const char *CompId = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt1 = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SnapPoint> Pnt2 = 0) {
  auto CompId__ = CompId ? _fbb.CreateString(CompId) : 0;
  return FlatBufferDocSpace::CreatePlaneAxisData(
      _fbb,
      AxisType,
      LineId,
      CompId__,
      Pnt1,
      Pnt2);
}

struct InitCmdData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitCmdDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INITDATA_TYPE = 4,
    VT_INITDATA = 6,
    VT_PARAMDATA = 8,
    VT_FEATUREID = 10
  };
  FlatBufferDocSpace::InitDataMessage InitData_type() const {
    return static_cast<FlatBufferDocSpace::InitDataMessage>(GetField<uint8_t>(VT_INITDATA_TYPE, 0));
  }
  const void *InitData() const {
    return GetPointer<const void *>(VT_INITDATA);
  }
  template<typename T> const T *InitData_as() const;
  const FlatBufferDocSpace::InitDataForPart *InitData_as_InitDataForPart() const {
    return InitData_type() == FlatBufferDocSpace::InitDataMessage_InitDataForPart ? static_cast<const FlatBufferDocSpace::InitDataForPart *>(InitData()) : nullptr;
  }
  const FlatBufferDocSpace::InitDataForAssembly *InitData_as_InitDataForAssembly() const {
    return InitData_type() == FlatBufferDocSpace::InitDataMessage_InitDataForAssembly ? static_cast<const FlatBufferDocSpace::InitDataForAssembly *>(InitData()) : nullptr;
  }
  const flatbuffers::String *ParamData() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMDATA);
  }
  int32_t FeatureId() const {
    return GetField<int32_t>(VT_FEATUREID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INITDATA_TYPE) &&
           VerifyOffset(verifier, VT_INITDATA) &&
           VerifyInitDataMessage(verifier, InitData(), InitData_type()) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyString(ParamData()) &&
           VerifyField<int32_t>(verifier, VT_FEATUREID) &&
           verifier.EndTable();
  }
};

template<> inline const FlatBufferDocSpace::InitDataForPart *InitCmdData::InitData_as<FlatBufferDocSpace::InitDataForPart>() const {
  return InitData_as_InitDataForPart();
}

template<> inline const FlatBufferDocSpace::InitDataForAssembly *InitCmdData::InitData_as<FlatBufferDocSpace::InitDataForAssembly>() const {
  return InitData_as_InitDataForAssembly();
}

struct InitCmdDataBuilder {
  typedef InitCmdData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_InitData_type(FlatBufferDocSpace::InitDataMessage InitData_type) {
    fbb_.AddElement<uint8_t>(InitCmdData::VT_INITDATA_TYPE, static_cast<uint8_t>(InitData_type), 0);
  }
  void add_InitData(flatbuffers::Offset<void> InitData) {
    fbb_.AddOffset(InitCmdData::VT_INITDATA, InitData);
  }
  void add_ParamData(flatbuffers::Offset<flatbuffers::String> ParamData) {
    fbb_.AddOffset(InitCmdData::VT_PARAMDATA, ParamData);
  }
  void add_FeatureId(int32_t FeatureId) {
    fbb_.AddElement<int32_t>(InitCmdData::VT_FEATUREID, FeatureId, 0);
  }
  explicit InitCmdDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitCmdDataBuilder &operator=(const InitCmdDataBuilder &);
  flatbuffers::Offset<InitCmdData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitCmdData>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitCmdData> CreateInitCmdData(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::InitDataMessage InitData_type = FlatBufferDocSpace::InitDataMessage_NONE,
    flatbuffers::Offset<void> InitData = 0,
    flatbuffers::Offset<flatbuffers::String> ParamData = 0,
    int32_t FeatureId = 0) {
  InitCmdDataBuilder builder_(_fbb);
  builder_.add_FeatureId(FeatureId);
  builder_.add_ParamData(ParamData);
  builder_.add_InitData(InitData);
  builder_.add_InitData_type(InitData_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<InitCmdData> CreateInitCmdDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::InitDataMessage InitData_type = FlatBufferDocSpace::InitDataMessage_NONE,
    flatbuffers::Offset<void> InitData = 0,
    const char *ParamData = nullptr,
    int32_t FeatureId = 0) {
  auto ParamData__ = ParamData ? _fbb.CreateString(ParamData) : 0;
  return FlatBufferDocSpace::CreateInitCmdData(
      _fbb,
      InitData_type,
      InitData,
      ParamData__,
      FeatureId);
}

struct ArchData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArchDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ISPARTDATA = 6,
    VT_NAME = 8,
    VT_DOCID = 10,
    VT_VERSIONID = 12
  };
  const flatbuffers::String *Id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  bool IsPartData() const {
    return GetField<uint8_t>(VT_ISPARTDATA, 0) != 0;
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *DocId() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCID);
  }
  const flatbuffers::String *VersionId() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSIONID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(Id()) &&
           VerifyField<uint8_t>(verifier, VT_ISPARTDATA) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_DOCID) &&
           verifier.VerifyString(DocId()) &&
           VerifyOffset(verifier, VT_VERSIONID) &&
           verifier.VerifyString(VersionId()) &&
           verifier.EndTable();
  }
};

struct ArchDataBuilder {
  typedef ArchData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(flatbuffers::Offset<flatbuffers::String> Id) {
    fbb_.AddOffset(ArchData::VT_ID, Id);
  }
  void add_IsPartData(bool IsPartData) {
    fbb_.AddElement<uint8_t>(ArchData::VT_ISPARTDATA, static_cast<uint8_t>(IsPartData), 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(ArchData::VT_NAME, Name);
  }
  void add_DocId(flatbuffers::Offset<flatbuffers::String> DocId) {
    fbb_.AddOffset(ArchData::VT_DOCID, DocId);
  }
  void add_VersionId(flatbuffers::Offset<flatbuffers::String> VersionId) {
    fbb_.AddOffset(ArchData::VT_VERSIONID, VersionId);
  }
  explicit ArchDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArchDataBuilder &operator=(const ArchDataBuilder &);
  flatbuffers::Offset<ArchData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArchData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArchData> CreateArchData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Id = 0,
    bool IsPartData = false,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::String> DocId = 0,
    flatbuffers::Offset<flatbuffers::String> VersionId = 0) {
  ArchDataBuilder builder_(_fbb);
  builder_.add_VersionId(VersionId);
  builder_.add_DocId(DocId);
  builder_.add_Name(Name);
  builder_.add_Id(Id);
  builder_.add_IsPartData(IsPartData);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArchData> CreateArchDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Id = nullptr,
    bool IsPartData = false,
    const char *Name = nullptr,
    const char *DocId = nullptr,
    const char *VersionId = nullptr) {
  auto Id__ = Id ? _fbb.CreateString(Id) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto DocId__ = DocId ? _fbb.CreateString(DocId) : 0;
  auto VersionId__ = VersionId ? _fbb.CreateString(VersionId) : 0;
  return FlatBufferDocSpace::CreateArchData(
      _fbb,
      Id__,
      IsPartData,
      Name__,
      DocId__,
      VersionId__);
}

struct IncrementalCompData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IncrementalCompDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDINSTANCES = 4,
    VT_MODINSTANCES = 6,
    VT_DELINSTANCES = 8,
    VT_ADDPROTOS = 10,
    VT_MODPROTOS = 12,
    VT_DELPROTOS = 14,
    VT_ADDMATINGS = 16,
    VT_MODMATINGS = 18,
    VT_DELMATINGS = 20,
    VT_ADDMATEREFS = 22,
    VT_MODMATEREFS = 24,
    VT_DELMATEREFS = 26,
    VT_ADDVARIABLES = 28,
    VT_DELVARIABLES = 30,
    VT_MODVARIABLES = 32,
    VT_ADDELEMENTS = 34,
    VT_MODELEMENTS = 36,
    VT_DELELEMENTS = 38,
    VT_ADDENTITIES = 40,
    VT_MODENTITIES = 42,
    VT_DELENTITIES = 44,
    VT_FEATUREDATAS = 46,
    VT_PROTODATAS = 48,
    VT_ADDANNOTVIEWS = 50,
    VT_DELANNOTVIEWS = 52,
    VT_MODANNOTVIEWS = 54,
    VT_SAVEFILE = 56,
    VT_APPEARANCEDATAS = 58,
    VT_TEXTUREDATAS = 60,
    VT_AI = 62,
    VT_ADDSIMULATIONS = 64,
    VT_MODSIMULATIONS = 66,
    VT_DELSIMULATIONS = 68
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *AddInstances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *>(VT_ADDINSTANCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *ModInstances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *>(VT_MODINSTANCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *DelInstances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DELINSTANCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>> *AddProtos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>> *>(VT_ADDPROTOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>> *ModProtos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>> *>(VT_MODPROTOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *DelProtos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DELPROTOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *AddMatings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *>(VT_ADDMATINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *ModMatings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *>(VT_MODMATINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *DelMatings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *>(VT_DELMATINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *AddMateRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *>(VT_ADDMATEREFS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *ModMateRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *>(VT_MODMATEREFS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *DelMateRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *>(VT_DELMATEREFS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *AddVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_ADDVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *DelVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *>(VT_DELVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *ModVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_MODVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *AddElements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_ADDELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ModElements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_MODELEMENTS);
  }
  const flatbuffers::Vector<int32_t> *DelElements() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *AddEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_ADDENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *ModEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_MODENTITIES);
  }
  const flatbuffers::Vector<int32_t> *DelEntities() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *>(VT_FEATUREDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>> *ProtoDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>> *>(VT_PROTODATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *AddAnnotViews() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *>(VT_ADDANNOTVIEWS);
  }
  const flatbuffers::Vector<int32_t> *DelAnnotViews() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELANNOTVIEWS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *ModAnnotViews() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *>(VT_MODANNOTVIEWS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FileStructData>> *SaveFile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FileStructData>> *>(VT_SAVEFILE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *AppearanceDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *>(VT_APPEARANCEDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *TextureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *>(VT_TEXTUREDATAS);
  }
  int32_t AI() const {
    return GetField<int32_t>(VT_AI, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *AddSimulations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *>(VT_ADDSIMULATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *ModSimulations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *>(VT_MODSIMULATIONS);
  }
  const flatbuffers::Vector<int32_t> *DelSimulations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELSIMULATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDINSTANCES) &&
           verifier.VerifyVector(AddInstances()) &&
           verifier.VerifyVectorOfTables(AddInstances()) &&
           VerifyOffset(verifier, VT_MODINSTANCES) &&
           verifier.VerifyVector(ModInstances()) &&
           verifier.VerifyVectorOfTables(ModInstances()) &&
           VerifyOffset(verifier, VT_DELINSTANCES) &&
           verifier.VerifyVector(DelInstances()) &&
           verifier.VerifyVectorOfStrings(DelInstances()) &&
           VerifyOffset(verifier, VT_ADDPROTOS) &&
           verifier.VerifyVector(AddProtos()) &&
           verifier.VerifyVectorOfTables(AddProtos()) &&
           VerifyOffset(verifier, VT_MODPROTOS) &&
           verifier.VerifyVector(ModProtos()) &&
           verifier.VerifyVectorOfTables(ModProtos()) &&
           VerifyOffset(verifier, VT_DELPROTOS) &&
           verifier.VerifyVector(DelProtos()) &&
           verifier.VerifyVectorOfStrings(DelProtos()) &&
           VerifyOffset(verifier, VT_ADDMATINGS) &&
           verifier.VerifyVector(AddMatings()) &&
           verifier.VerifyVectorOfTables(AddMatings()) &&
           VerifyOffset(verifier, VT_MODMATINGS) &&
           verifier.VerifyVector(ModMatings()) &&
           verifier.VerifyVectorOfTables(ModMatings()) &&
           VerifyOffset(verifier, VT_DELMATINGS) &&
           verifier.VerifyVector(DelMatings()) &&
           verifier.VerifyVectorOfTables(DelMatings()) &&
           VerifyOffset(verifier, VT_ADDMATEREFS) &&
           verifier.VerifyVector(AddMateRefs()) &&
           verifier.VerifyVectorOfTables(AddMateRefs()) &&
           VerifyOffset(verifier, VT_MODMATEREFS) &&
           verifier.VerifyVector(ModMateRefs()) &&
           verifier.VerifyVectorOfTables(ModMateRefs()) &&
           VerifyOffset(verifier, VT_DELMATEREFS) &&
           verifier.VerifyVector(DelMateRefs()) &&
           verifier.VerifyVectorOfTables(DelMateRefs()) &&
           VerifyOffset(verifier, VT_ADDVARIABLES) &&
           verifier.VerifyVector(AddVariables()) &&
           verifier.VerifyVectorOfTables(AddVariables()) &&
           VerifyOffset(verifier, VT_DELVARIABLES) &&
           verifier.VerifyVector(DelVariables()) &&
           verifier.VerifyVectorOfTables(DelVariables()) &&
           VerifyOffset(verifier, VT_MODVARIABLES) &&
           verifier.VerifyVector(ModVariables()) &&
           verifier.VerifyVectorOfTables(ModVariables()) &&
           VerifyOffset(verifier, VT_ADDELEMENTS) &&
           verifier.VerifyVector(AddElements()) &&
           verifier.VerifyVectorOfTables(AddElements()) &&
           VerifyOffset(verifier, VT_MODELEMENTS) &&
           verifier.VerifyVector(ModElements()) &&
           verifier.VerifyVectorOfTables(ModElements()) &&
           VerifyOffset(verifier, VT_DELELEMENTS) &&
           verifier.VerifyVector(DelElements()) &&
           VerifyOffset(verifier, VT_ADDENTITIES) &&
           verifier.VerifyVector(AddEntities()) &&
           verifier.VerifyVectorOfTables(AddEntities()) &&
           VerifyOffset(verifier, VT_MODENTITIES) &&
           verifier.VerifyVector(ModEntities()) &&
           verifier.VerifyVectorOfTables(ModEntities()) &&
           VerifyOffset(verifier, VT_DELENTITIES) &&
           verifier.VerifyVector(DelEntities()) &&
           VerifyOffset(verifier, VT_FEATUREDATAS) &&
           verifier.VerifyVector(FeatureDatas()) &&
           verifier.VerifyVectorOfTables(FeatureDatas()) &&
           VerifyOffset(verifier, VT_PROTODATAS) &&
           verifier.VerifyVector(ProtoDatas()) &&
           verifier.VerifyVectorOfTables(ProtoDatas()) &&
           VerifyOffset(verifier, VT_ADDANNOTVIEWS) &&
           verifier.VerifyVector(AddAnnotViews()) &&
           verifier.VerifyVectorOfTables(AddAnnotViews()) &&
           VerifyOffset(verifier, VT_DELANNOTVIEWS) &&
           verifier.VerifyVector(DelAnnotViews()) &&
           VerifyOffset(verifier, VT_MODANNOTVIEWS) &&
           verifier.VerifyVector(ModAnnotViews()) &&
           verifier.VerifyVectorOfTables(ModAnnotViews()) &&
           VerifyOffset(verifier, VT_SAVEFILE) &&
           verifier.VerifyVector(SaveFile()) &&
           verifier.VerifyVectorOfTables(SaveFile()) &&
           VerifyOffset(verifier, VT_APPEARANCEDATAS) &&
           verifier.VerifyVector(AppearanceDatas()) &&
           verifier.VerifyVectorOfTables(AppearanceDatas()) &&
           VerifyOffset(verifier, VT_TEXTUREDATAS) &&
           verifier.VerifyVector(TextureDatas()) &&
           verifier.VerifyVectorOfTables(TextureDatas()) &&
           VerifyField<int32_t>(verifier, VT_AI) &&
           VerifyOffset(verifier, VT_ADDSIMULATIONS) &&
           verifier.VerifyVector(AddSimulations()) &&
           verifier.VerifyVectorOfTables(AddSimulations()) &&
           VerifyOffset(verifier, VT_MODSIMULATIONS) &&
           verifier.VerifyVector(ModSimulations()) &&
           verifier.VerifyVectorOfTables(ModSimulations()) &&
           VerifyOffset(verifier, VT_DELSIMULATIONS) &&
           verifier.VerifyVector(DelSimulations()) &&
           verifier.EndTable();
  }
};

struct IncrementalCompDataBuilder {
  typedef IncrementalCompData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AddInstances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>> AddInstances) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDINSTANCES, AddInstances);
  }
  void add_ModInstances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>> ModInstances) {
    fbb_.AddOffset(IncrementalCompData::VT_MODINSTANCES, ModInstances);
  }
  void add_DelInstances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> DelInstances) {
    fbb_.AddOffset(IncrementalCompData::VT_DELINSTANCES, DelInstances);
  }
  void add_AddProtos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>>> AddProtos) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDPROTOS, AddProtos);
  }
  void add_ModProtos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>>> ModProtos) {
    fbb_.AddOffset(IncrementalCompData::VT_MODPROTOS, ModProtos);
  }
  void add_DelProtos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> DelProtos) {
    fbb_.AddOffset(IncrementalCompData::VT_DELPROTOS, DelProtos);
  }
  void add_AddMatings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> AddMatings) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDMATINGS, AddMatings);
  }
  void add_ModMatings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> ModMatings) {
    fbb_.AddOffset(IncrementalCompData::VT_MODMATINGS, ModMatings);
  }
  void add_DelMatings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> DelMatings) {
    fbb_.AddOffset(IncrementalCompData::VT_DELMATINGS, DelMatings);
  }
  void add_AddMateRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> AddMateRefs) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDMATEREFS, AddMateRefs);
  }
  void add_ModMateRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> ModMateRefs) {
    fbb_.AddOffset(IncrementalCompData::VT_MODMATEREFS, ModMateRefs);
  }
  void add_DelMateRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> DelMateRefs) {
    fbb_.AddOffset(IncrementalCompData::VT_DELMATEREFS, DelMateRefs);
  }
  void add_AddVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> AddVariables) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDVARIABLES, AddVariables);
  }
  void add_DelVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>> DelVariables) {
    fbb_.AddOffset(IncrementalCompData::VT_DELVARIABLES, DelVariables);
  }
  void add_ModVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> ModVariables) {
    fbb_.AddOffset(IncrementalCompData::VT_MODVARIABLES, ModVariables);
  }
  void add_AddElements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> AddElements) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDELEMENTS, AddElements);
  }
  void add_ModElements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ModElements) {
    fbb_.AddOffset(IncrementalCompData::VT_MODELEMENTS, ModElements);
  }
  void add_DelElements(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelElements) {
    fbb_.AddOffset(IncrementalCompData::VT_DELELEMENTS, DelElements);
  }
  void add_AddEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> AddEntities) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDENTITIES, AddEntities);
  }
  void add_ModEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> ModEntities) {
    fbb_.AddOffset(IncrementalCompData::VT_MODENTITIES, ModEntities);
  }
  void add_DelEntities(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelEntities) {
    fbb_.AddOffset(IncrementalCompData::VT_DELENTITIES, DelEntities);
  }
  void add_FeatureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas) {
    fbb_.AddOffset(IncrementalCompData::VT_FEATUREDATAS, FeatureDatas);
  }
  void add_ProtoDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>>> ProtoDatas) {
    fbb_.AddOffset(IncrementalCompData::VT_PROTODATAS, ProtoDatas);
  }
  void add_AddAnnotViews(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> AddAnnotViews) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDANNOTVIEWS, AddAnnotViews);
  }
  void add_DelAnnotViews(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelAnnotViews) {
    fbb_.AddOffset(IncrementalCompData::VT_DELANNOTVIEWS, DelAnnotViews);
  }
  void add_ModAnnotViews(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> ModAnnotViews) {
    fbb_.AddOffset(IncrementalCompData::VT_MODANNOTVIEWS, ModAnnotViews);
  }
  void add_SaveFile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FileStructData>>> SaveFile) {
    fbb_.AddOffset(IncrementalCompData::VT_SAVEFILE, SaveFile);
  }
  void add_AppearanceDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>> AppearanceDatas) {
    fbb_.AddOffset(IncrementalCompData::VT_APPEARANCEDATAS, AppearanceDatas);
  }
  void add_TextureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>> TextureDatas) {
    fbb_.AddOffset(IncrementalCompData::VT_TEXTUREDATAS, TextureDatas);
  }
  void add_AI(int32_t AI) {
    fbb_.AddElement<int32_t>(IncrementalCompData::VT_AI, AI, 0);
  }
  void add_AddSimulations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> AddSimulations) {
    fbb_.AddOffset(IncrementalCompData::VT_ADDSIMULATIONS, AddSimulations);
  }
  void add_ModSimulations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> ModSimulations) {
    fbb_.AddOffset(IncrementalCompData::VT_MODSIMULATIONS, ModSimulations);
  }
  void add_DelSimulations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelSimulations) {
    fbb_.AddOffset(IncrementalCompData::VT_DELSIMULATIONS, DelSimulations);
  }
  explicit IncrementalCompDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IncrementalCompDataBuilder &operator=(const IncrementalCompDataBuilder &);
  flatbuffers::Offset<IncrementalCompData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IncrementalCompData>(end);
    return o;
  }
};

inline flatbuffers::Offset<IncrementalCompData> CreateIncrementalCompData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>> AddInstances = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>> ModInstances = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> DelInstances = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>>> AddProtos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>>> ModProtos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> DelProtos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> AddMatings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> ModMatings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>> DelMatings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> AddMateRefs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> ModMateRefs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>> DelMateRefs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> AddVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>> DelVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> ModVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> AddElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ModElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> AddEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> ModEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>>> ProtoDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> AddAnnotViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelAnnotViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>> ModAnnotViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FileStructData>>> SaveFile = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>> AppearanceDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>> TextureDatas = 0,
    int32_t AI = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> AddSimulations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>> ModSimulations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelSimulations = 0) {
  IncrementalCompDataBuilder builder_(_fbb);
  builder_.add_DelSimulations(DelSimulations);
  builder_.add_ModSimulations(ModSimulations);
  builder_.add_AddSimulations(AddSimulations);
  builder_.add_AI(AI);
  builder_.add_TextureDatas(TextureDatas);
  builder_.add_AppearanceDatas(AppearanceDatas);
  builder_.add_SaveFile(SaveFile);
  builder_.add_ModAnnotViews(ModAnnotViews);
  builder_.add_DelAnnotViews(DelAnnotViews);
  builder_.add_AddAnnotViews(AddAnnotViews);
  builder_.add_ProtoDatas(ProtoDatas);
  builder_.add_FeatureDatas(FeatureDatas);
  builder_.add_DelEntities(DelEntities);
  builder_.add_ModEntities(ModEntities);
  builder_.add_AddEntities(AddEntities);
  builder_.add_DelElements(DelElements);
  builder_.add_ModElements(ModElements);
  builder_.add_AddElements(AddElements);
  builder_.add_ModVariables(ModVariables);
  builder_.add_DelVariables(DelVariables);
  builder_.add_AddVariables(AddVariables);
  builder_.add_DelMateRefs(DelMateRefs);
  builder_.add_ModMateRefs(ModMateRefs);
  builder_.add_AddMateRefs(AddMateRefs);
  builder_.add_DelMatings(DelMatings);
  builder_.add_ModMatings(ModMatings);
  builder_.add_AddMatings(AddMatings);
  builder_.add_DelProtos(DelProtos);
  builder_.add_ModProtos(ModProtos);
  builder_.add_AddProtos(AddProtos);
  builder_.add_DelInstances(DelInstances);
  builder_.add_ModInstances(ModInstances);
  builder_.add_AddInstances(AddInstances);
  return builder_.Finish();
}

inline flatbuffers::Offset<IncrementalCompData> CreateIncrementalCompDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *AddInstances = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CompData>> *ModInstances = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *DelInstances = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>> *AddProtos = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>> *ModProtos = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *DelProtos = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *AddMatings = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *ModMatings = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>> *DelMatings = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *AddMateRefs = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *ModMateRefs = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>> *DelMateRefs = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *AddVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *DelVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *ModVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *AddElements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ModElements = nullptr,
    const std::vector<int32_t> *DelElements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *AddEntities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *ModEntities = nullptr,
    const std::vector<int32_t> *DelEntities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>> *ProtoDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *AddAnnotViews = nullptr,
    const std::vector<int32_t> *DelAnnotViews = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>> *ModAnnotViews = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FileStructData>> *SaveFile = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>> *AppearanceDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>> *TextureDatas = nullptr,
    int32_t AI = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *AddSimulations = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>> *ModSimulations = nullptr,
    const std::vector<int32_t> *DelSimulations = nullptr) {
  auto AddInstances__ = AddInstances ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>(*AddInstances) : 0;
  auto ModInstances__ = ModInstances ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CompData>>(*ModInstances) : 0;
  auto DelInstances__ = DelInstances ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*DelInstances) : 0;
  auto AddProtos__ = AddProtos ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>>(*AddProtos) : 0;
  auto ModProtos__ = ModProtos ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ArchData>>(*ModProtos) : 0;
  auto DelProtos__ = DelProtos ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*DelProtos) : 0;
  auto AddMatings__ = AddMatings ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>(*AddMatings) : 0;
  auto ModMatings__ = ModMatings ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>(*ModMatings) : 0;
  auto DelMatings__ = DelMatings ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::NewMatingData>>(*DelMatings) : 0;
  auto AddMateRefs__ = AddMateRefs ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>(*AddMateRefs) : 0;
  auto ModMateRefs__ = ModMateRefs ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>(*ModMateRefs) : 0;
  auto DelMateRefs__ = DelMateRefs ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MateRefData>>(*DelMateRefs) : 0;
  auto AddVariables__ = AddVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*AddVariables) : 0;
  auto DelVariables__ = DelVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>(*DelVariables) : 0;
  auto ModVariables__ = ModVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*ModVariables) : 0;
  auto AddElements__ = AddElements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*AddElements) : 0;
  auto ModElements__ = ModElements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*ModElements) : 0;
  auto DelElements__ = DelElements ? _fbb.CreateVector<int32_t>(*DelElements) : 0;
  auto AddEntities__ = AddEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*AddEntities) : 0;
  auto ModEntities__ = ModEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*ModEntities) : 0;
  auto DelEntities__ = DelEntities ? _fbb.CreateVector<int32_t>(*DelEntities) : 0;
  auto FeatureDatas__ = FeatureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>(*FeatureDatas) : 0;
  auto ProtoDatas__ = ProtoDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ProtoDataMessage>>(*ProtoDatas) : 0;
  auto AddAnnotViews__ = AddAnnotViews ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>(*AddAnnotViews) : 0;
  auto DelAnnotViews__ = DelAnnotViews ? _fbb.CreateVector<int32_t>(*DelAnnotViews) : 0;
  auto ModAnnotViews__ = ModAnnotViews ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ViewData>>(*ModAnnotViews) : 0;
  auto SaveFile__ = SaveFile ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FileStructData>>(*SaveFile) : 0;
  auto AppearanceDatas__ = AppearanceDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AppearanceData>>(*AppearanceDatas) : 0;
  auto TextureDatas__ = TextureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TextureData>>(*TextureDatas) : 0;
  auto AddSimulations__ = AddSimulations ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>(*AddSimulations) : 0;
  auto ModSimulations__ = ModSimulations ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SimulationData>>(*ModSimulations) : 0;
  auto DelSimulations__ = DelSimulations ? _fbb.CreateVector<int32_t>(*DelSimulations) : 0;
  return FlatBufferDocSpace::CreateIncrementalCompData(
      _fbb,
      AddInstances__,
      ModInstances__,
      DelInstances__,
      AddProtos__,
      ModProtos__,
      DelProtos__,
      AddMatings__,
      ModMatings__,
      DelMatings__,
      AddMateRefs__,
      ModMateRefs__,
      DelMateRefs__,
      AddVariables__,
      DelVariables__,
      ModVariables__,
      AddElements__,
      ModElements__,
      DelElements__,
      AddEntities__,
      ModEntities__,
      DelEntities__,
      FeatureDatas__,
      ProtoDatas__,
      AddAnnotViews__,
      DelAnnotViews__,
      ModAnnotViews__,
      SaveFile__,
      AppearanceDatas__,
      TextureDatas__,
      AI,
      AddSimulations__,
      ModSimulations__,
      DelSimulations__);
}

struct FileStructData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileStructDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIR = 4,
    VT_FILE = 6
  };
  const flatbuffers::String *dir() const {
    return GetPointer<const flatbuffers::String *>(VT_DIR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FileData>> *file() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FileData>> *>(VT_FILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIR) &&
           verifier.VerifyString(dir()) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyVector(file()) &&
           verifier.VerifyVectorOfTables(file()) &&
           verifier.EndTable();
  }
};

struct FileStructDataBuilder {
  typedef FileStructData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dir(flatbuffers::Offset<flatbuffers::String> dir) {
    fbb_.AddOffset(FileStructData::VT_DIR, dir);
  }
  void add_file(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FileData>>> file) {
    fbb_.AddOffset(FileStructData::VT_FILE, file);
  }
  explicit FileStructDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileStructDataBuilder &operator=(const FileStructDataBuilder &);
  flatbuffers::Offset<FileStructData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileStructData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileStructData> CreateFileStructData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> dir = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FileData>>> file = 0) {
  FileStructDataBuilder builder_(_fbb);
  builder_.add_file(file);
  builder_.add_dir(dir);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileStructData> CreateFileStructDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *dir = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FileData>> *file = nullptr) {
  auto dir__ = dir ? _fbb.CreateString(dir) : 0;
  auto file__ = file ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FileData>>(*file) : 0;
  return FlatBufferDocSpace::CreateFileStructData(
      _fbb,
      dir__,
      file__);
}

struct FileData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4,
    VT_HYPFILENAME = 6,
    VT_TYPE = 8,
    VT_EXTERNALREFS = 10
  };
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  const flatbuffers::String *hypFilename() const {
    return GetPointer<const flatbuffers::String *>(VT_HYPFILENAME);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *externalRefs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_EXTERNALREFS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           VerifyOffset(verifier, VT_HYPFILENAME) &&
           verifier.VerifyString(hypFilename()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_EXTERNALREFS) &&
           verifier.VerifyVector(externalRefs()) &&
           verifier.VerifyVectorOfStrings(externalRefs()) &&
           verifier.EndTable();
  }
};

struct FileDataBuilder {
  typedef FileData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(FileData::VT_FILE, file);
  }
  void add_hypFilename(flatbuffers::Offset<flatbuffers::String> hypFilename) {
    fbb_.AddOffset(FileData::VT_HYPFILENAME, hypFilename);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(FileData::VT_TYPE, type);
  }
  void add_externalRefs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> externalRefs) {
    fbb_.AddOffset(FileData::VT_EXTERNALREFS, externalRefs);
  }
  explicit FileDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileDataBuilder &operator=(const FileDataBuilder &);
  flatbuffers::Offset<FileData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileData> CreateFileData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file = 0,
    flatbuffers::Offset<flatbuffers::String> hypFilename = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> externalRefs = 0) {
  FileDataBuilder builder_(_fbb);
  builder_.add_externalRefs(externalRefs);
  builder_.add_type(type);
  builder_.add_hypFilename(hypFilename);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileData> CreateFileDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr,
    const char *hypFilename = nullptr,
    const char *type = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *externalRefs = nullptr) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  auto hypFilename__ = hypFilename ? _fbb.CreateString(hypFilename) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto externalRefs__ = externalRefs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*externalRefs) : 0;
  return FlatBufferDocSpace::CreateFileData(
      _fbb,
      file__,
      hypFilename__,
      type__,
      externalRefs__);
}

struct DiscreteData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DiscreteDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_V = 6,
    VT_I = 8,
    VT_N = 10,
    VT_TE = 12,
    VT_FT = 14,
    VT_FN = 16
  };
  const flatbuffers::String *T() const {
    return GetPointer<const flatbuffers::String *>(VT_T);
  }
  const flatbuffers::Vector<float> *V() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_V);
  }
  const flatbuffers::Vector<int32_t> *I() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_I);
  }
  const flatbuffers::Vector<float> *N() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_N);
  }
  const flatbuffers::Vector<float> *TE() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TE);
  }
  int32_t FT() const {
    return GetField<int32_t>(VT_FT, 0);
  }
  int32_t FN() const {
    return GetField<int32_t>(VT_FN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyString(T()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.VerifyVector(V()) &&
           VerifyOffset(verifier, VT_I) &&
           verifier.VerifyVector(I()) &&
           VerifyOffset(verifier, VT_N) &&
           verifier.VerifyVector(N()) &&
           VerifyOffset(verifier, VT_TE) &&
           verifier.VerifyVector(TE()) &&
           VerifyField<int32_t>(verifier, VT_FT) &&
           VerifyField<int32_t>(verifier, VT_FN) &&
           verifier.EndTable();
  }
};

struct DiscreteDataBuilder {
  typedef DiscreteData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(flatbuffers::Offset<flatbuffers::String> T) {
    fbb_.AddOffset(DiscreteData::VT_T, T);
  }
  void add_V(flatbuffers::Offset<flatbuffers::Vector<float>> V) {
    fbb_.AddOffset(DiscreteData::VT_V, V);
  }
  void add_I(flatbuffers::Offset<flatbuffers::Vector<int32_t>> I) {
    fbb_.AddOffset(DiscreteData::VT_I, I);
  }
  void add_N(flatbuffers::Offset<flatbuffers::Vector<float>> N) {
    fbb_.AddOffset(DiscreteData::VT_N, N);
  }
  void add_TE(flatbuffers::Offset<flatbuffers::Vector<float>> TE) {
    fbb_.AddOffset(DiscreteData::VT_TE, TE);
  }
  void add_FT(int32_t FT) {
    fbb_.AddElement<int32_t>(DiscreteData::VT_FT, FT, 0);
  }
  void add_FN(int32_t FN) {
    fbb_.AddElement<int32_t>(DiscreteData::VT_FN, FN, 0);
  }
  explicit DiscreteDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscreteDataBuilder &operator=(const DiscreteDataBuilder &);
  flatbuffers::Offset<DiscreteData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DiscreteData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DiscreteData> CreateDiscreteData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> T = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> V = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> I = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> N = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> TE = 0,
    int32_t FT = 0,
    int32_t FN = 0) {
  DiscreteDataBuilder builder_(_fbb);
  builder_.add_FN(FN);
  builder_.add_FT(FT);
  builder_.add_TE(TE);
  builder_.add_N(N);
  builder_.add_I(I);
  builder_.add_V(V);
  builder_.add_T(T);
  return builder_.Finish();
}

inline flatbuffers::Offset<DiscreteData> CreateDiscreteDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *T = nullptr,
    const std::vector<float> *V = nullptr,
    const std::vector<int32_t> *I = nullptr,
    const std::vector<float> *N = nullptr,
    const std::vector<float> *TE = nullptr,
    int32_t FT = 0,
    int32_t FN = 0) {
  auto T__ = T ? _fbb.CreateString(T) : 0;
  auto V__ = V ? _fbb.CreateVector<float>(*V) : 0;
  auto I__ = I ? _fbb.CreateVector<int32_t>(*I) : 0;
  auto N__ = N ? _fbb.CreateVector<float>(*N) : 0;
  auto TE__ = TE ? _fbb.CreateVector<float>(*TE) : 0;
  return FlatBufferDocSpace::CreateDiscreteData(
      _fbb,
      T__,
      V__,
      I__,
      N__,
      TE__,
      FT,
      FN);
}

struct MatrixData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatrixDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAT = 4
  };
  const flatbuffers::Vector<double> *mat() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAT) &&
           verifier.VerifyVector(mat()) &&
           verifier.EndTable();
  }
};

struct MatrixDataBuilder {
  typedef MatrixData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mat(flatbuffers::Offset<flatbuffers::Vector<double>> mat) {
    fbb_.AddOffset(MatrixData::VT_MAT, mat);
  }
  explicit MatrixDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixDataBuilder &operator=(const MatrixDataBuilder &);
  flatbuffers::Offset<MatrixData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixData> CreateMatrixData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> mat = 0) {
  MatrixDataBuilder builder_(_fbb);
  builder_.add_mat(mat);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatrixData> CreateMatrixDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *mat = nullptr) {
  auto mat__ = mat ? _fbb.CreateVector<double>(*mat) : 0;
  return FlatBufferDocSpace::CreateMatrixData(
      _fbb,
      mat__);
}

struct PreviewDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PreviewDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_D = 6,
    VT_MATRIX = 8
  };
  int32_t T() const {
    return GetField<int32_t>(VT_T, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *D() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *>(VT_D);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MatrixData>> *Matrix() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MatrixData>> *>(VT_MATRIX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyVector(D()) &&
           verifier.VerifyVectorOfTables(D()) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyVector(Matrix()) &&
           verifier.VerifyVectorOfTables(Matrix()) &&
           verifier.EndTable();
  }
};

struct PreviewDataMessageBuilder {
  typedef PreviewDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(int32_t T) {
    fbb_.AddElement<int32_t>(PreviewDataMessage::VT_T, T, 0);
  }
  void add_D(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>> D) {
    fbb_.AddOffset(PreviewDataMessage::VT_D, D);
  }
  void add_Matrix(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MatrixData>>> Matrix) {
    fbb_.AddOffset(PreviewDataMessage::VT_MATRIX, Matrix);
  }
  explicit PreviewDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PreviewDataMessageBuilder &operator=(const PreviewDataMessageBuilder &);
  flatbuffers::Offset<PreviewDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PreviewDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<PreviewDataMessage> CreatePreviewDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t T = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>> D = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MatrixData>>> Matrix = 0) {
  PreviewDataMessageBuilder builder_(_fbb);
  builder_.add_Matrix(Matrix);
  builder_.add_D(D);
  builder_.add_T(T);
  return builder_.Finish();
}

inline flatbuffers::Offset<PreviewDataMessage> CreatePreviewDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t T = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *D = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MatrixData>> *Matrix = nullptr) {
  auto D__ = D ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>(*D) : 0;
  auto Matrix__ = Matrix ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MatrixData>>(*Matrix) : 0;
  return FlatBufferDocSpace::CreatePreviewDataMessage(
      _fbb,
      T,
      D__,
      Matrix__);
}

struct TransformInstanceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformInstanceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::Vector<double> *value() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct TransformInstanceDataBuilder {
  typedef TransformInstanceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(TransformInstanceData::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<double>> value) {
    fbb_.AddOffset(TransformInstanceData::VT_VALUE, value);
  }
  explicit TransformInstanceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransformInstanceDataBuilder &operator=(const TransformInstanceDataBuilder &);
  flatbuffers::Offset<TransformInstanceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransformInstanceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransformInstanceData> CreateTransformInstanceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> value = 0) {
  TransformInstanceDataBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransformInstanceData> CreateTransformInstanceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<double> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<double>(*value) : 0;
  return FlatBufferDocSpace::CreateTransformInstanceData(
      _fbb,
      key__,
      value__);
}

struct TransformDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSFORMINSTANCE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *TransformInstance() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *>(VT_TRANSFORMINSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRANSFORMINSTANCE) &&
           verifier.VerifyVector(TransformInstance()) &&
           verifier.VerifyVectorOfTables(TransformInstance()) &&
           verifier.EndTable();
  }
};

struct TransformDataMessageBuilder {
  typedef TransformDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TransformInstance(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>> TransformInstance) {
    fbb_.AddOffset(TransformDataMessage::VT_TRANSFORMINSTANCE, TransformInstance);
  }
  explicit TransformDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransformDataMessageBuilder &operator=(const TransformDataMessageBuilder &);
  flatbuffers::Offset<TransformDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransformDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransformDataMessage> CreateTransformDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>> TransformInstance = 0) {
  TransformDataMessageBuilder builder_(_fbb);
  builder_.add_TransformInstance(TransformInstance);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransformDataMessage> CreateTransformDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *TransformInstance = nullptr) {
  auto TransformInstance__ = TransformInstance ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>(*TransformInstance) : 0;
  return FlatBufferDocSpace::CreateTransformDataMessage(
      _fbb,
      TransformInstance__);
}

struct MatInforData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatInforDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAT = 4
  };
  const flatbuffers::Vector<double> *mat() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAT) &&
           verifier.VerifyVector(mat()) &&
           verifier.EndTable();
  }
};

struct MatInforDataBuilder {
  typedef MatInforData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mat(flatbuffers::Offset<flatbuffers::Vector<double>> mat) {
    fbb_.AddOffset(MatInforData::VT_MAT, mat);
  }
  explicit MatInforDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatInforDataBuilder &operator=(const MatInforDataBuilder &);
  flatbuffers::Offset<MatInforData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatInforData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatInforData> CreateMatInforData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> mat = 0) {
  MatInforDataBuilder builder_(_fbb);
  builder_.add_mat(mat);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatInforData> CreateMatInforDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *mat = nullptr) {
  auto mat__ = mat ? _fbb.CreateVector<double>(*mat) : 0;
  return FlatBufferDocSpace::CreateMatInforData(
      _fbb,
      mat__);
}

struct AnimationInstanceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationInstanceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MatInforData>> *value() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MatInforData>> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfTables(value()) &&
           verifier.EndTable();
  }
};

struct AnimationInstanceDataBuilder {
  typedef AnimationInstanceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(AnimationInstanceData::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MatInforData>>> value) {
    fbb_.AddOffset(AnimationInstanceData::VT_VALUE, value);
  }
  explicit AnimationInstanceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationInstanceDataBuilder &operator=(const AnimationInstanceDataBuilder &);
  flatbuffers::Offset<AnimationInstanceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationInstanceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationInstanceData> CreateAnimationInstanceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MatInforData>>> value = 0) {
  AnimationInstanceDataBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationInstanceData> CreateAnimationInstanceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MatInforData>> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MatInforData>>(*value) : 0;
  return FlatBufferDocSpace::CreateAnimationInstanceData(
      _fbb,
      key__,
      value__);
}

struct AnimationDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANIMATIONINSTANCE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationInstanceData>> *AnimationInstance() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationInstanceData>> *>(VT_ANIMATIONINSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANIMATIONINSTANCE) &&
           verifier.VerifyVector(AnimationInstance()) &&
           verifier.VerifyVectorOfTables(AnimationInstance()) &&
           verifier.EndTable();
  }
};

struct AnimationDataMessageBuilder {
  typedef AnimationDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AnimationInstance(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationInstanceData>>> AnimationInstance) {
    fbb_.AddOffset(AnimationDataMessage::VT_ANIMATIONINSTANCE, AnimationInstance);
  }
  explicit AnimationDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationDataMessageBuilder &operator=(const AnimationDataMessageBuilder &);
  flatbuffers::Offset<AnimationDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationDataMessage> CreateAnimationDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationInstanceData>>> AnimationInstance = 0) {
  AnimationDataMessageBuilder builder_(_fbb);
  builder_.add_AnimationInstance(AnimationInstance);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationDataMessage> CreateAnimationDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationInstanceData>> *AnimationInstance = nullptr) {
  auto AnimationInstance__ = AnimationInstance ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AnimationInstanceData>>(*AnimationInstance) : 0;
  return FlatBufferDocSpace::CreateAnimationDataMessage(
      _fbb,
      AnimationInstance__);
}

struct DistanceHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DistanceHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN = 4,
    VT_DIRECTION = 6,
    VT_DIRECTION2 = 8,
    VT_LENGTH = 10
  };
  const flatbuffers::Vector<double> *Origin() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ORIGIN);
  }
  const flatbuffers::Vector<double> *Direction() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIRECTION);
  }
  const flatbuffers::Vector<double> *Direction2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIRECTION2);
  }
  double Length() const {
    return GetField<double>(VT_LENGTH, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyVector(Origin()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyVector(Direction()) &&
           VerifyOffset(verifier, VT_DIRECTION2) &&
           verifier.VerifyVector(Direction2()) &&
           VerifyField<double>(verifier, VT_LENGTH) &&
           verifier.EndTable();
  }
};

struct DistanceHandleDataBuilder {
  typedef DistanceHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Origin(flatbuffers::Offset<flatbuffers::Vector<double>> Origin) {
    fbb_.AddOffset(DistanceHandleData::VT_ORIGIN, Origin);
  }
  void add_Direction(flatbuffers::Offset<flatbuffers::Vector<double>> Direction) {
    fbb_.AddOffset(DistanceHandleData::VT_DIRECTION, Direction);
  }
  void add_Direction2(flatbuffers::Offset<flatbuffers::Vector<double>> Direction2) {
    fbb_.AddOffset(DistanceHandleData::VT_DIRECTION2, Direction2);
  }
  void add_Length(double Length) {
    fbb_.AddElement<double>(DistanceHandleData::VT_LENGTH, Length, 0.0);
  }
  explicit DistanceHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DistanceHandleDataBuilder &operator=(const DistanceHandleDataBuilder &);
  flatbuffers::Offset<DistanceHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DistanceHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DistanceHandleData> CreateDistanceHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Origin = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Direction = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Direction2 = 0,
    double Length = 0.0) {
  DistanceHandleDataBuilder builder_(_fbb);
  builder_.add_Length(Length);
  builder_.add_Direction2(Direction2);
  builder_.add_Direction(Direction);
  builder_.add_Origin(Origin);
  return builder_.Finish();
}

inline flatbuffers::Offset<DistanceHandleData> CreateDistanceHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Origin = nullptr,
    const std::vector<double> *Direction = nullptr,
    const std::vector<double> *Direction2 = nullptr,
    double Length = 0.0) {
  auto Origin__ = Origin ? _fbb.CreateVector<double>(*Origin) : 0;
  auto Direction__ = Direction ? _fbb.CreateVector<double>(*Direction) : 0;
  auto Direction2__ = Direction2 ? _fbb.CreateVector<double>(*Direction2) : 0;
  return FlatBufferDocSpace::CreateDistanceHandleData(
      _fbb,
      Origin__,
      Direction__,
      Direction2__,
      Length);
}

struct AngleHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AngleHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN = 4,
    VT_DIRECTION1 = 6,
    VT_DIRECTION2 = 8,
    VT_RADIUS = 10,
    VT_ANGLE = 12
  };
  const flatbuffers::Vector<double> *Origin() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ORIGIN);
  }
  const flatbuffers::Vector<double> *Direction1() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIRECTION1);
  }
  const flatbuffers::Vector<double> *Direction2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIRECTION2);
  }
  double Radius() const {
    return GetField<double>(VT_RADIUS, 0.0);
  }
  double Angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyVector(Origin()) &&
           VerifyOffset(verifier, VT_DIRECTION1) &&
           verifier.VerifyVector(Direction1()) &&
           VerifyOffset(verifier, VT_DIRECTION2) &&
           verifier.VerifyVector(Direction2()) &&
           VerifyField<double>(verifier, VT_RADIUS) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           verifier.EndTable();
  }
};

struct AngleHandleDataBuilder {
  typedef AngleHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Origin(flatbuffers::Offset<flatbuffers::Vector<double>> Origin) {
    fbb_.AddOffset(AngleHandleData::VT_ORIGIN, Origin);
  }
  void add_Direction1(flatbuffers::Offset<flatbuffers::Vector<double>> Direction1) {
    fbb_.AddOffset(AngleHandleData::VT_DIRECTION1, Direction1);
  }
  void add_Direction2(flatbuffers::Offset<flatbuffers::Vector<double>> Direction2) {
    fbb_.AddOffset(AngleHandleData::VT_DIRECTION2, Direction2);
  }
  void add_Radius(double Radius) {
    fbb_.AddElement<double>(AngleHandleData::VT_RADIUS, Radius, 0.0);
  }
  void add_Angle(double Angle) {
    fbb_.AddElement<double>(AngleHandleData::VT_ANGLE, Angle, 0.0);
  }
  explicit AngleHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AngleHandleDataBuilder &operator=(const AngleHandleDataBuilder &);
  flatbuffers::Offset<AngleHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AngleHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AngleHandleData> CreateAngleHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Origin = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Direction1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Direction2 = 0,
    double Radius = 0.0,
    double Angle = 0.0) {
  AngleHandleDataBuilder builder_(_fbb);
  builder_.add_Angle(Angle);
  builder_.add_Radius(Radius);
  builder_.add_Direction2(Direction2);
  builder_.add_Direction1(Direction1);
  builder_.add_Origin(Origin);
  return builder_.Finish();
}

inline flatbuffers::Offset<AngleHandleData> CreateAngleHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Origin = nullptr,
    const std::vector<double> *Direction1 = nullptr,
    const std::vector<double> *Direction2 = nullptr,
    double Radius = 0.0,
    double Angle = 0.0) {
  auto Origin__ = Origin ? _fbb.CreateVector<double>(*Origin) : 0;
  auto Direction1__ = Direction1 ? _fbb.CreateVector<double>(*Direction1) : 0;
  auto Direction2__ = Direction2 ? _fbb.CreateVector<double>(*Direction2) : 0;
  return FlatBufferDocSpace::CreateAngleHandleData(
      _fbb,
      Origin__,
      Direction1__,
      Direction2__,
      Radius,
      Angle);
}

struct RadiusHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RadiusHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN = 4,
    VT_DIRECTION = 6,
    VT_LENGTH = 8,
    VT_DIRECTION2 = 10
  };
  const flatbuffers::Vector<double> *Origin() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ORIGIN);
  }
  const flatbuffers::Vector<double> *Direction() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIRECTION);
  }
  double Length() const {
    return GetField<double>(VT_LENGTH, 0.0);
  }
  const flatbuffers::Vector<double> *Direction2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIRECTION2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyVector(Origin()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyVector(Direction()) &&
           VerifyField<double>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_DIRECTION2) &&
           verifier.VerifyVector(Direction2()) &&
           verifier.EndTable();
  }
};

struct RadiusHandleDataBuilder {
  typedef RadiusHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Origin(flatbuffers::Offset<flatbuffers::Vector<double>> Origin) {
    fbb_.AddOffset(RadiusHandleData::VT_ORIGIN, Origin);
  }
  void add_Direction(flatbuffers::Offset<flatbuffers::Vector<double>> Direction) {
    fbb_.AddOffset(RadiusHandleData::VT_DIRECTION, Direction);
  }
  void add_Length(double Length) {
    fbb_.AddElement<double>(RadiusHandleData::VT_LENGTH, Length, 0.0);
  }
  void add_Direction2(flatbuffers::Offset<flatbuffers::Vector<double>> Direction2) {
    fbb_.AddOffset(RadiusHandleData::VT_DIRECTION2, Direction2);
  }
  explicit RadiusHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RadiusHandleDataBuilder &operator=(const RadiusHandleDataBuilder &);
  flatbuffers::Offset<RadiusHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RadiusHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RadiusHandleData> CreateRadiusHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Origin = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Direction = 0,
    double Length = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Direction2 = 0) {
  RadiusHandleDataBuilder builder_(_fbb);
  builder_.add_Length(Length);
  builder_.add_Direction2(Direction2);
  builder_.add_Direction(Direction);
  builder_.add_Origin(Origin);
  return builder_.Finish();
}

inline flatbuffers::Offset<RadiusHandleData> CreateRadiusHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Origin = nullptr,
    const std::vector<double> *Direction = nullptr,
    double Length = 0.0,
    const std::vector<double> *Direction2 = nullptr) {
  auto Origin__ = Origin ? _fbb.CreateVector<double>(*Origin) : 0;
  auto Direction__ = Direction ? _fbb.CreateVector<double>(*Direction) : 0;
  auto Direction2__ = Direction2 ? _fbb.CreateVector<double>(*Direction2) : 0;
  return FlatBufferDocSpace::CreateRadiusHandleData(
      _fbb,
      Origin__,
      Direction__,
      Length,
      Direction2__);
}

struct TangentHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TangentHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STARTLENGTH = 4,
    VT_ENDLENGTH = 6,
    VT_STARTTANG = 8,
    VT_ENDTANG = 10,
    VT_STARTROTATE = 12,
    VT_ENDROTATE = 14
  };
  double StartLength() const {
    return GetField<double>(VT_STARTLENGTH, 0.0);
  }
  double EndLength() const {
    return GetField<double>(VT_ENDLENGTH, 0.0);
  }
  const flatbuffers::Vector<double> *StartTang() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTTANG);
  }
  const flatbuffers::Vector<double> *EndTang() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDTANG);
  }
  bool StartRotate() const {
    return GetField<uint8_t>(VT_STARTROTATE, 0) != 0;
  }
  bool EndRotate() const {
    return GetField<uint8_t>(VT_ENDROTATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_STARTLENGTH) &&
           VerifyField<double>(verifier, VT_ENDLENGTH) &&
           VerifyOffset(verifier, VT_STARTTANG) &&
           verifier.VerifyVector(StartTang()) &&
           VerifyOffset(verifier, VT_ENDTANG) &&
           verifier.VerifyVector(EndTang()) &&
           VerifyField<uint8_t>(verifier, VT_STARTROTATE) &&
           VerifyField<uint8_t>(verifier, VT_ENDROTATE) &&
           verifier.EndTable();
  }
};

struct TangentHandleDataBuilder {
  typedef TangentHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_StartLength(double StartLength) {
    fbb_.AddElement<double>(TangentHandleData::VT_STARTLENGTH, StartLength, 0.0);
  }
  void add_EndLength(double EndLength) {
    fbb_.AddElement<double>(TangentHandleData::VT_ENDLENGTH, EndLength, 0.0);
  }
  void add_StartTang(flatbuffers::Offset<flatbuffers::Vector<double>> StartTang) {
    fbb_.AddOffset(TangentHandleData::VT_STARTTANG, StartTang);
  }
  void add_EndTang(flatbuffers::Offset<flatbuffers::Vector<double>> EndTang) {
    fbb_.AddOffset(TangentHandleData::VT_ENDTANG, EndTang);
  }
  void add_StartRotate(bool StartRotate) {
    fbb_.AddElement<uint8_t>(TangentHandleData::VT_STARTROTATE, static_cast<uint8_t>(StartRotate), 0);
  }
  void add_EndRotate(bool EndRotate) {
    fbb_.AddElement<uint8_t>(TangentHandleData::VT_ENDROTATE, static_cast<uint8_t>(EndRotate), 0);
  }
  explicit TangentHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TangentHandleDataBuilder &operator=(const TangentHandleDataBuilder &);
  flatbuffers::Offset<TangentHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TangentHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TangentHandleData> CreateTangentHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double StartLength = 0.0,
    double EndLength = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartTang = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndTang = 0,
    bool StartRotate = false,
    bool EndRotate = false) {
  TangentHandleDataBuilder builder_(_fbb);
  builder_.add_EndLength(EndLength);
  builder_.add_StartLength(StartLength);
  builder_.add_EndTang(EndTang);
  builder_.add_StartTang(StartTang);
  builder_.add_EndRotate(EndRotate);
  builder_.add_StartRotate(StartRotate);
  return builder_.Finish();
}

inline flatbuffers::Offset<TangentHandleData> CreateTangentHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double StartLength = 0.0,
    double EndLength = 0.0,
    const std::vector<double> *StartTang = nullptr,
    const std::vector<double> *EndTang = nullptr,
    bool StartRotate = false,
    bool EndRotate = false) {
  auto StartTang__ = StartTang ? _fbb.CreateVector<double>(*StartTang) : 0;
  auto EndTang__ = EndTang ? _fbb.CreateVector<double>(*EndTang) : 0;
  return FlatBufferDocSpace::CreateTangentHandleData(
      _fbb,
      StartLength,
      EndLength,
      StartTang__,
      EndTang__,
      StartRotate,
      EndRotate);
}

struct PointHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_STATUS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SnapPoint>> *Points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SnapPoint>> *>(VT_POINTS);
  }
  const flatbuffers::Vector<int32_t> *Status() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(Points()) &&
           verifier.VerifyVectorOfTables(Points()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyVector(Status()) &&
           verifier.EndTable();
  }
};

struct PointHandleDataBuilder {
  typedef PointHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SnapPoint>>> Points) {
    fbb_.AddOffset(PointHandleData::VT_POINTS, Points);
  }
  void add_Status(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Status) {
    fbb_.AddOffset(PointHandleData::VT_STATUS, Status);
  }
  explicit PointHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointHandleDataBuilder &operator=(const PointHandleDataBuilder &);
  flatbuffers::Offset<PointHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PointHandleData> CreatePointHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SnapPoint>>> Points = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Status = 0) {
  PointHandleDataBuilder builder_(_fbb);
  builder_.add_Status(Status);
  builder_.add_Points(Points);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointHandleData> CreatePointHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SnapPoint>> *Points = nullptr,
    const std::vector<int32_t> *Status = nullptr) {
  auto Points__ = Points ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SnapPoint>>(*Points) : 0;
  auto Status__ = Status ? _fbb.CreateVector<int32_t>(*Status) : 0;
  return FlatBufferDocSpace::CreatePointHandleData(
      _fbb,
      Points__,
      Status__);
}

struct MatrixHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatrixHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN = 4,
    VT_VECTORX = 6,
    VT_VECTORY = 8,
    VT_VECTORZ = 10
  };
  const flatbuffers::Vector<double> *Origin() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ORIGIN);
  }
  const flatbuffers::Vector<double> *VectorX() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VECTORX);
  }
  const flatbuffers::Vector<double> *VectorY() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VECTORY);
  }
  const flatbuffers::Vector<double> *VectorZ() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VECTORZ);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyVector(Origin()) &&
           VerifyOffset(verifier, VT_VECTORX) &&
           verifier.VerifyVector(VectorX()) &&
           VerifyOffset(verifier, VT_VECTORY) &&
           verifier.VerifyVector(VectorY()) &&
           VerifyOffset(verifier, VT_VECTORZ) &&
           verifier.VerifyVector(VectorZ()) &&
           verifier.EndTable();
  }
};

struct MatrixHandleDataBuilder {
  typedef MatrixHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Origin(flatbuffers::Offset<flatbuffers::Vector<double>> Origin) {
    fbb_.AddOffset(MatrixHandleData::VT_ORIGIN, Origin);
  }
  void add_VectorX(flatbuffers::Offset<flatbuffers::Vector<double>> VectorX) {
    fbb_.AddOffset(MatrixHandleData::VT_VECTORX, VectorX);
  }
  void add_VectorY(flatbuffers::Offset<flatbuffers::Vector<double>> VectorY) {
    fbb_.AddOffset(MatrixHandleData::VT_VECTORY, VectorY);
  }
  void add_VectorZ(flatbuffers::Offset<flatbuffers::Vector<double>> VectorZ) {
    fbb_.AddOffset(MatrixHandleData::VT_VECTORZ, VectorZ);
  }
  explicit MatrixHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixHandleDataBuilder &operator=(const MatrixHandleDataBuilder &);
  flatbuffers::Offset<MatrixHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixHandleData> CreateMatrixHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Origin = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> VectorX = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> VectorY = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> VectorZ = 0) {
  MatrixHandleDataBuilder builder_(_fbb);
  builder_.add_VectorZ(VectorZ);
  builder_.add_VectorY(VectorY);
  builder_.add_VectorX(VectorX);
  builder_.add_Origin(Origin);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatrixHandleData> CreateMatrixHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Origin = nullptr,
    const std::vector<double> *VectorX = nullptr,
    const std::vector<double> *VectorY = nullptr,
    const std::vector<double> *VectorZ = nullptr) {
  auto Origin__ = Origin ? _fbb.CreateVector<double>(*Origin) : 0;
  auto VectorX__ = VectorX ? _fbb.CreateVector<double>(*VectorX) : 0;
  auto VectorY__ = VectorY ? _fbb.CreateVector<double>(*VectorY) : 0;
  auto VectorZ__ = VectorZ ? _fbb.CreateVector<double>(*VectorZ) : 0;
  return FlatBufferDocSpace::CreateMatrixHandleData(
      _fbb,
      Origin__,
      VectorX__,
      VectorY__,
      VectorZ__);
}

struct DirectionHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DirectionHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN = 4,
    VT_DIRECTION = 6
  };
  const flatbuffers::Vector<float> *Origin() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ORIGIN);
  }
  const flatbuffers::Vector<float> *Direction() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyVector(Origin()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyVector(Direction()) &&
           verifier.EndTable();
  }
};

struct DirectionHandleDataBuilder {
  typedef DirectionHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Origin(flatbuffers::Offset<flatbuffers::Vector<float>> Origin) {
    fbb_.AddOffset(DirectionHandleData::VT_ORIGIN, Origin);
  }
  void add_Direction(flatbuffers::Offset<flatbuffers::Vector<float>> Direction) {
    fbb_.AddOffset(DirectionHandleData::VT_DIRECTION, Direction);
  }
  explicit DirectionHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DirectionHandleDataBuilder &operator=(const DirectionHandleDataBuilder &);
  flatbuffers::Offset<DirectionHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DirectionHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DirectionHandleData> CreateDirectionHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> Origin = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Direction = 0) {
  DirectionHandleDataBuilder builder_(_fbb);
  builder_.add_Direction(Direction);
  builder_.add_Origin(Origin);
  return builder_.Finish();
}

inline flatbuffers::Offset<DirectionHandleData> CreateDirectionHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *Origin = nullptr,
    const std::vector<float> *Direction = nullptr) {
  auto Origin__ = Origin ? _fbb.CreateVector<float>(*Origin) : 0;
  auto Direction__ = Direction ? _fbb.CreateVector<float>(*Direction) : 0;
  return FlatBufferDocSpace::CreateDirectionHandleData(
      _fbb,
      Origin__,
      Direction__);
}

struct DimensionHandleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimensionHandleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DIRECTION = 6,
    VT_POSITION = 8,
    VT_REFPLANE = 10,
    VT_GEOMPNTS = 12,
    VT_CENTERPNT = 14,
    VT_VALUE = 16
  };
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<double> *Direction() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIRECTION);
  }
  const flatbuffers::Vector<double> *Position() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POSITION);
  }
  const flatbuffers::Vector<double> *RefPlane() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_REFPLANE);
  }
  const flatbuffers::Vector<double> *GeomPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_GEOMPNTS);
  }
  const flatbuffers::Vector<double> *CenterPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CENTERPNT);
  }
  double Value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyVector(Direction()) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyVector(Position()) &&
           VerifyOffset(verifier, VT_REFPLANE) &&
           verifier.VerifyVector(RefPlane()) &&
           VerifyOffset(verifier, VT_GEOMPNTS) &&
           verifier.VerifyVector(GeomPnts()) &&
           VerifyOffset(verifier, VT_CENTERPNT) &&
           verifier.VerifyVector(CenterPnt()) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DimensionHandleDataBuilder {
  typedef DimensionHandleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(DimensionHandleData::VT_TYPE, Type);
  }
  void add_Direction(flatbuffers::Offset<flatbuffers::Vector<double>> Direction) {
    fbb_.AddOffset(DimensionHandleData::VT_DIRECTION, Direction);
  }
  void add_Position(flatbuffers::Offset<flatbuffers::Vector<double>> Position) {
    fbb_.AddOffset(DimensionHandleData::VT_POSITION, Position);
  }
  void add_RefPlane(flatbuffers::Offset<flatbuffers::Vector<double>> RefPlane) {
    fbb_.AddOffset(DimensionHandleData::VT_REFPLANE, RefPlane);
  }
  void add_GeomPnts(flatbuffers::Offset<flatbuffers::Vector<double>> GeomPnts) {
    fbb_.AddOffset(DimensionHandleData::VT_GEOMPNTS, GeomPnts);
  }
  void add_CenterPnt(flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt) {
    fbb_.AddOffset(DimensionHandleData::VT_CENTERPNT, CenterPnt);
  }
  void add_Value(double Value) {
    fbb_.AddElement<double>(DimensionHandleData::VT_VALUE, Value, 0.0);
  }
  explicit DimensionHandleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionHandleDataBuilder &operator=(const DimensionHandleDataBuilder &);
  flatbuffers::Offset<DimensionHandleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionHandleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionHandleData> CreateDimensionHandleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Direction = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Position = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> RefPlane = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> GeomPnts = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt = 0,
    double Value = 0.0) {
  DimensionHandleDataBuilder builder_(_fbb);
  builder_.add_Value(Value);
  builder_.add_CenterPnt(CenterPnt);
  builder_.add_GeomPnts(GeomPnts);
  builder_.add_RefPlane(RefPlane);
  builder_.add_Position(Position);
  builder_.add_Direction(Direction);
  builder_.add_Type(Type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DimensionHandleData> CreateDimensionHandleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Type = nullptr,
    const std::vector<double> *Direction = nullptr,
    const std::vector<double> *Position = nullptr,
    const std::vector<double> *RefPlane = nullptr,
    const std::vector<double> *GeomPnts = nullptr,
    const std::vector<double> *CenterPnt = nullptr,
    double Value = 0.0) {
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto Direction__ = Direction ? _fbb.CreateVector<double>(*Direction) : 0;
  auto Position__ = Position ? _fbb.CreateVector<double>(*Position) : 0;
  auto RefPlane__ = RefPlane ? _fbb.CreateVector<double>(*RefPlane) : 0;
  auto GeomPnts__ = GeomPnts ? _fbb.CreateVector<double>(*GeomPnts) : 0;
  auto CenterPnt__ = CenterPnt ? _fbb.CreateVector<double>(*CenterPnt) : 0;
  return FlatBufferDocSpace::CreateDimensionHandleData(
      _fbb,
      Type__,
      Direction__,
      Position__,
      RefPlane__,
      GeomPnts__,
      CenterPnt__,
      Value);
}

struct HandleDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandleDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFPARAM = 4,
    VT_TYPE = 6,
    VT_DEFINEDATA_TYPE = 8,
    VT_DEFINEDATA = 10
  };
  const flatbuffers::String *RefParam() const {
    return GetPointer<const flatbuffers::String *>(VT_REFPARAM);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  FlatBufferDocSpace::DefineDataMessage DefineData_type() const {
    return static_cast<FlatBufferDocSpace::DefineDataMessage>(GetField<uint8_t>(VT_DEFINEDATA_TYPE, 0));
  }
  const void *DefineData() const {
    return GetPointer<const void *>(VT_DEFINEDATA);
  }
  template<typename T> const T *DefineData_as() const;
  const FlatBufferDocSpace::DistanceHandleData *DefineData_as_DistanceHandleData() const {
    return DefineData_type() == FlatBufferDocSpace::DefineDataMessage_DistanceHandleData ? static_cast<const FlatBufferDocSpace::DistanceHandleData *>(DefineData()) : nullptr;
  }
  const FlatBufferDocSpace::AngleHandleData *DefineData_as_AngleHandleData() const {
    return DefineData_type() == FlatBufferDocSpace::DefineDataMessage_AngleHandleData ? static_cast<const FlatBufferDocSpace::AngleHandleData *>(DefineData()) : nullptr;
  }
  const FlatBufferDocSpace::RadiusHandleData *DefineData_as_RadiusHandleData() const {
    return DefineData_type() == FlatBufferDocSpace::DefineDataMessage_RadiusHandleData ? static_cast<const FlatBufferDocSpace::RadiusHandleData *>(DefineData()) : nullptr;
  }
  const FlatBufferDocSpace::TangentHandleData *DefineData_as_TangentHandleData() const {
    return DefineData_type() == FlatBufferDocSpace::DefineDataMessage_TangentHandleData ? static_cast<const FlatBufferDocSpace::TangentHandleData *>(DefineData()) : nullptr;
  }
  const FlatBufferDocSpace::PointHandleData *DefineData_as_PointHandleData() const {
    return DefineData_type() == FlatBufferDocSpace::DefineDataMessage_PointHandleData ? static_cast<const FlatBufferDocSpace::PointHandleData *>(DefineData()) : nullptr;
  }
  const FlatBufferDocSpace::MatrixHandleData *DefineData_as_MatrixHandleData() const {
    return DefineData_type() == FlatBufferDocSpace::DefineDataMessage_MatrixHandleData ? static_cast<const FlatBufferDocSpace::MatrixHandleData *>(DefineData()) : nullptr;
  }
  const FlatBufferDocSpace::DirectionHandleData *DefineData_as_DirectionHandleData() const {
    return DefineData_type() == FlatBufferDocSpace::DefineDataMessage_DirectionHandleData ? static_cast<const FlatBufferDocSpace::DirectionHandleData *>(DefineData()) : nullptr;
  }
  const FlatBufferDocSpace::DimensionHandleData *DefineData_as_DimensionHandleData() const {
    return DefineData_type() == FlatBufferDocSpace::DefineDataMessage_DimensionHandleData ? static_cast<const FlatBufferDocSpace::DimensionHandleData *>(DefineData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REFPARAM) &&
           verifier.VerifyString(RefParam()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DEFINEDATA_TYPE) &&
           VerifyOffset(verifier, VT_DEFINEDATA) &&
           VerifyDefineDataMessage(verifier, DefineData(), DefineData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FlatBufferDocSpace::DistanceHandleData *HandleDataMessage::DefineData_as<FlatBufferDocSpace::DistanceHandleData>() const {
  return DefineData_as_DistanceHandleData();
}

template<> inline const FlatBufferDocSpace::AngleHandleData *HandleDataMessage::DefineData_as<FlatBufferDocSpace::AngleHandleData>() const {
  return DefineData_as_AngleHandleData();
}

template<> inline const FlatBufferDocSpace::RadiusHandleData *HandleDataMessage::DefineData_as<FlatBufferDocSpace::RadiusHandleData>() const {
  return DefineData_as_RadiusHandleData();
}

template<> inline const FlatBufferDocSpace::TangentHandleData *HandleDataMessage::DefineData_as<FlatBufferDocSpace::TangentHandleData>() const {
  return DefineData_as_TangentHandleData();
}

template<> inline const FlatBufferDocSpace::PointHandleData *HandleDataMessage::DefineData_as<FlatBufferDocSpace::PointHandleData>() const {
  return DefineData_as_PointHandleData();
}

template<> inline const FlatBufferDocSpace::MatrixHandleData *HandleDataMessage::DefineData_as<FlatBufferDocSpace::MatrixHandleData>() const {
  return DefineData_as_MatrixHandleData();
}

template<> inline const FlatBufferDocSpace::DirectionHandleData *HandleDataMessage::DefineData_as<FlatBufferDocSpace::DirectionHandleData>() const {
  return DefineData_as_DirectionHandleData();
}

template<> inline const FlatBufferDocSpace::DimensionHandleData *HandleDataMessage::DefineData_as<FlatBufferDocSpace::DimensionHandleData>() const {
  return DefineData_as_DimensionHandleData();
}

struct HandleDataMessageBuilder {
  typedef HandleDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RefParam(flatbuffers::Offset<flatbuffers::String> RefParam) {
    fbb_.AddOffset(HandleDataMessage::VT_REFPARAM, RefParam);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(HandleDataMessage::VT_TYPE, Type, 0);
  }
  void add_DefineData_type(FlatBufferDocSpace::DefineDataMessage DefineData_type) {
    fbb_.AddElement<uint8_t>(HandleDataMessage::VT_DEFINEDATA_TYPE, static_cast<uint8_t>(DefineData_type), 0);
  }
  void add_DefineData(flatbuffers::Offset<void> DefineData) {
    fbb_.AddOffset(HandleDataMessage::VT_DEFINEDATA, DefineData);
  }
  explicit HandleDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandleDataMessageBuilder &operator=(const HandleDataMessageBuilder &);
  flatbuffers::Offset<HandleDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandleDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandleDataMessage> CreateHandleDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> RefParam = 0,
    int32_t Type = 0,
    FlatBufferDocSpace::DefineDataMessage DefineData_type = FlatBufferDocSpace::DefineDataMessage_NONE,
    flatbuffers::Offset<void> DefineData = 0) {
  HandleDataMessageBuilder builder_(_fbb);
  builder_.add_DefineData(DefineData);
  builder_.add_Type(Type);
  builder_.add_RefParam(RefParam);
  builder_.add_DefineData_type(DefineData_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandleDataMessage> CreateHandleDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *RefParam = nullptr,
    int32_t Type = 0,
    FlatBufferDocSpace::DefineDataMessage DefineData_type = FlatBufferDocSpace::DefineDataMessage_NONE,
    flatbuffers::Offset<void> DefineData = 0) {
  auto RefParam__ = RefParam ? _fbb.CreateString(RefParam) : 0;
  return FlatBufferDocSpace::CreateHandleDataMessage(
      _fbb,
      RefParam__,
      Type,
      DefineData_type,
      DefineData);
}

struct TopoDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopoDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TID = 6,
    VT_INSTANCEID = 8,
    VT_INSTANCEINDEX = 10
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *TID() const {
    return GetPointer<const flatbuffers::String *>(VT_TID);
  }
  const flatbuffers::String *InstanceId() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID);
  }
  const flatbuffers::String *InstanceIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEINDEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_TID) &&
           verifier.VerifyString(TID()) &&
           VerifyOffset(verifier, VT_INSTANCEID) &&
           verifier.VerifyString(InstanceId()) &&
           VerifyOffset(verifier, VT_INSTANCEINDEX) &&
           verifier.VerifyString(InstanceIndex()) &&
           verifier.EndTable();
  }
};

struct TopoDataMessageBuilder {
  typedef TopoDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(TopoDataMessage::VT_ID, Id, 0);
  }
  void add_TID(flatbuffers::Offset<flatbuffers::String> TID) {
    fbb_.AddOffset(TopoDataMessage::VT_TID, TID);
  }
  void add_InstanceId(flatbuffers::Offset<flatbuffers::String> InstanceId) {
    fbb_.AddOffset(TopoDataMessage::VT_INSTANCEID, InstanceId);
  }
  void add_InstanceIndex(flatbuffers::Offset<flatbuffers::String> InstanceIndex) {
    fbb_.AddOffset(TopoDataMessage::VT_INSTANCEINDEX, InstanceIndex);
  }
  explicit TopoDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopoDataMessageBuilder &operator=(const TopoDataMessageBuilder &);
  flatbuffers::Offset<TopoDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopoDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopoDataMessage> CreateTopoDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    flatbuffers::Offset<flatbuffers::String> TID = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceIndex = 0) {
  TopoDataMessageBuilder builder_(_fbb);
  builder_.add_InstanceIndex(InstanceIndex);
  builder_.add_InstanceId(InstanceId);
  builder_.add_TID(TID);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopoDataMessage> CreateTopoDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    const char *TID = nullptr,
    const char *InstanceId = nullptr,
    const char *InstanceIndex = nullptr) {
  auto TID__ = TID ? _fbb.CreateString(TID) : 0;
  auto InstanceId__ = InstanceId ? _fbb.CreateString(InstanceId) : 0;
  auto InstanceIndex__ = InstanceIndex ? _fbb.CreateString(InstanceIndex) : 0;
  return FlatBufferDocSpace::CreateTopoDataMessage(
      _fbb,
      Id,
      TID__,
      InstanceId__,
      InstanceIndex__);
}

struct SerializePreviewData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerializePreviewDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREVIEWDATA = 4,
    VT_TRANSFORMDATA = 6,
    VT_ANIMATIONDATA = 8,
    VT_HANDLEDATA = 10,
    VT_PARAMDATA = 12,
    VT_TOPODATA = 14,
    VT_SWEEPDIRECTIONDATA = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>> *PreviewData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>> *>(VT_PREVIEWDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformDataMessage>> *TransformData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformDataMessage>> *>(VT_TRANSFORMDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationDataMessage>> *AnimationData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationDataMessage>> *>(VT_ANIMATIONDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *>(VT_HANDLEDATA);
  }
  const flatbuffers::String *ParamData() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *>(VT_TOPODATA);
  }
  int32_t SweepDirectionData() const {
    return GetField<int32_t>(VT_SWEEPDIRECTIONDATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PREVIEWDATA) &&
           verifier.VerifyVector(PreviewData()) &&
           verifier.VerifyVectorOfTables(PreviewData()) &&
           VerifyOffset(verifier, VT_TRANSFORMDATA) &&
           verifier.VerifyVector(TransformData()) &&
           verifier.VerifyVectorOfTables(TransformData()) &&
           VerifyOffset(verifier, VT_ANIMATIONDATA) &&
           verifier.VerifyVector(AnimationData()) &&
           verifier.VerifyVectorOfTables(AnimationData()) &&
           VerifyOffset(verifier, VT_HANDLEDATA) &&
           verifier.VerifyVector(HandleData()) &&
           verifier.VerifyVectorOfTables(HandleData()) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyString(ParamData()) &&
           VerifyOffset(verifier, VT_TOPODATA) &&
           verifier.VerifyVector(TopoData()) &&
           verifier.VerifyVectorOfTables(TopoData()) &&
           VerifyField<int32_t>(verifier, VT_SWEEPDIRECTIONDATA) &&
           verifier.EndTable();
  }
};

struct SerializePreviewDataBuilder {
  typedef SerializePreviewData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PreviewData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>>> PreviewData) {
    fbb_.AddOffset(SerializePreviewData::VT_PREVIEWDATA, PreviewData);
  }
  void add_TransformData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformDataMessage>>> TransformData) {
    fbb_.AddOffset(SerializePreviewData::VT_TRANSFORMDATA, TransformData);
  }
  void add_AnimationData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationDataMessage>>> AnimationData) {
    fbb_.AddOffset(SerializePreviewData::VT_ANIMATIONDATA, AnimationData);
  }
  void add_HandleData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData) {
    fbb_.AddOffset(SerializePreviewData::VT_HANDLEDATA, HandleData);
  }
  void add_ParamData(flatbuffers::Offset<flatbuffers::String> ParamData) {
    fbb_.AddOffset(SerializePreviewData::VT_PARAMDATA, ParamData);
  }
  void add_TopoData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData) {
    fbb_.AddOffset(SerializePreviewData::VT_TOPODATA, TopoData);
  }
  void add_SweepDirectionData(int32_t SweepDirectionData) {
    fbb_.AddElement<int32_t>(SerializePreviewData::VT_SWEEPDIRECTIONDATA, SweepDirectionData, 0);
  }
  explicit SerializePreviewDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SerializePreviewDataBuilder &operator=(const SerializePreviewDataBuilder &);
  flatbuffers::Offset<SerializePreviewData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerializePreviewData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerializePreviewData> CreateSerializePreviewData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>>> PreviewData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformDataMessage>>> TransformData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationDataMessage>>> AnimationData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData = 0,
    flatbuffers::Offset<flatbuffers::String> ParamData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData = 0,
    int32_t SweepDirectionData = 0) {
  SerializePreviewDataBuilder builder_(_fbb);
  builder_.add_SweepDirectionData(SweepDirectionData);
  builder_.add_TopoData(TopoData);
  builder_.add_ParamData(ParamData);
  builder_.add_HandleData(HandleData);
  builder_.add_AnimationData(AnimationData);
  builder_.add_TransformData(TransformData);
  builder_.add_PreviewData(PreviewData);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerializePreviewData> CreateSerializePreviewDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>> *PreviewData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TransformDataMessage>> *TransformData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AnimationDataMessage>> *AnimationData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData = nullptr,
    const char *ParamData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData = nullptr,
    int32_t SweepDirectionData = 0) {
  auto PreviewData__ = PreviewData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>>(*PreviewData) : 0;
  auto TransformData__ = TransformData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TransformDataMessage>>(*TransformData) : 0;
  auto AnimationData__ = AnimationData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AnimationDataMessage>>(*AnimationData) : 0;
  auto HandleData__ = HandleData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>(*HandleData) : 0;
  auto ParamData__ = ParamData ? _fbb.CreateString(ParamData) : 0;
  auto TopoData__ = TopoData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>(*TopoData) : 0;
  return FlatBufferDocSpace::CreateSerializePreviewData(
      _fbb,
      PreviewData__,
      TransformData__,
      AnimationData__,
      HandleData__,
      ParamData__,
      TopoData__,
      SweepDirectionData);
}

struct HoleParamDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HoleParamDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMDATA = 4
  };
  const flatbuffers::String *ParamData() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyString(ParamData()) &&
           verifier.EndTable();
  }
};

struct HoleParamDataMessageBuilder {
  typedef HoleParamDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ParamData(flatbuffers::Offset<flatbuffers::String> ParamData) {
    fbb_.AddOffset(HoleParamDataMessage::VT_PARAMDATA, ParamData);
  }
  explicit HoleParamDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HoleParamDataMessageBuilder &operator=(const HoleParamDataMessageBuilder &);
  flatbuffers::Offset<HoleParamDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HoleParamDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<HoleParamDataMessage> CreateHoleParamDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ParamData = 0) {
  HoleParamDataMessageBuilder builder_(_fbb);
  builder_.add_ParamData(ParamData);
  return builder_.Finish();
}

inline flatbuffers::Offset<HoleParamDataMessage> CreateHoleParamDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ParamData = nullptr) {
  auto ParamData__ = ParamData ? _fbb.CreateString(ParamData) : 0;
  return FlatBufferDocSpace::CreateHoleParamDataMessage(
      _fbb,
      ParamData__);
}

struct CosmeticThreadParamDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CosmeticThreadParamDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMDATA = 4
  };
  const flatbuffers::String *ParamData() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyString(ParamData()) &&
           verifier.EndTable();
  }
};

struct CosmeticThreadParamDataMessageBuilder {
  typedef CosmeticThreadParamDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ParamData(flatbuffers::Offset<flatbuffers::String> ParamData) {
    fbb_.AddOffset(CosmeticThreadParamDataMessage::VT_PARAMDATA, ParamData);
  }
  explicit CosmeticThreadParamDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CosmeticThreadParamDataMessageBuilder &operator=(const CosmeticThreadParamDataMessageBuilder &);
  flatbuffers::Offset<CosmeticThreadParamDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CosmeticThreadParamDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<CosmeticThreadParamDataMessage> CreateCosmeticThreadParamDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ParamData = 0) {
  CosmeticThreadParamDataMessageBuilder builder_(_fbb);
  builder_.add_ParamData(ParamData);
  return builder_.Finish();
}

inline flatbuffers::Offset<CosmeticThreadParamDataMessage> CreateCosmeticThreadParamDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ParamData = nullptr) {
  auto ParamData__ = ParamData ? _fbb.CreateString(ParamData) : 0;
  return FlatBufferDocSpace::CreateCosmeticThreadParamDataMessage(
      _fbb,
      ParamData__);
}

struct SweepPathParamDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SweepPathParamDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMDATA = 4
  };
  const flatbuffers::String *ParamData() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyString(ParamData()) &&
           verifier.EndTable();
  }
};

struct SweepPathParamDataMessageBuilder {
  typedef SweepPathParamDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ParamData(flatbuffers::Offset<flatbuffers::String> ParamData) {
    fbb_.AddOffset(SweepPathParamDataMessage::VT_PARAMDATA, ParamData);
  }
  explicit SweepPathParamDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SweepPathParamDataMessageBuilder &operator=(const SweepPathParamDataMessageBuilder &);
  flatbuffers::Offset<SweepPathParamDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SweepPathParamDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SweepPathParamDataMessage> CreateSweepPathParamDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ParamData = 0) {
  SweepPathParamDataMessageBuilder builder_(_fbb);
  builder_.add_ParamData(ParamData);
  return builder_.Finish();
}

inline flatbuffers::Offset<SweepPathParamDataMessage> CreateSweepPathParamDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ParamData = nullptr) {
  auto ParamData__ = ParamData ? _fbb.CreateString(ParamData) : 0;
  return FlatBufferDocSpace::CreateSweepPathParamDataMessage(
      _fbb,
      ParamData__);
}

struct SolidPreviewData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SolidPreviewDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_D = 6
  };
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *D() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *>(VT_D);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyVector(D()) &&
           verifier.VerifyVectorOfTables(D()) &&
           verifier.EndTable();
  }
};

struct SolidPreviewDataBuilder {
  typedef SolidPreviewData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(SolidPreviewData::VT_TYPE, Type, 0);
  }
  void add_D(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>> D) {
    fbb_.AddOffset(SolidPreviewData::VT_D, D);
  }
  explicit SolidPreviewDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SolidPreviewDataBuilder &operator=(const SolidPreviewDataBuilder &);
  flatbuffers::Offset<SolidPreviewData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SolidPreviewData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SolidPreviewData> CreateSolidPreviewData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>> D = 0) {
  SolidPreviewDataBuilder builder_(_fbb);
  builder_.add_D(D);
  builder_.add_Type(Type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SolidPreviewData> CreateSolidPreviewDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Type = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>> *D = nullptr) {
  auto D__ = D ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteData>>(*D) : 0;
  return FlatBufferDocSpace::CreateSolidPreviewData(
      _fbb,
      Type,
      D__);
}

struct SpecialPreviewInforData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpecialPreviewInforDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIDDLEDATA = 4,
    VT_OLDSRFDATA = 6,
    VT_NEWSRFDATA = 8,
    VT_PREVIEWDATA = 10,
    VT_TOPODATA = 12,
    VT_HANDLEDATA = 14,
    VT_PARAMDATA = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>> *MiddleData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>> *>(VT_MIDDLEDATA);
  }
  const flatbuffers::Vector<int32_t> *OldSrfData() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OLDSRFDATA);
  }
  const flatbuffers::Vector<int32_t> *NewSrfData() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEWSRFDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SolidPreviewData>> *PreviewData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SolidPreviewData>> *>(VT_PREVIEWDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *>(VT_TOPODATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *>(VT_HANDLEDATA);
  }
  const flatbuffers::String *ParamData() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIDDLEDATA) &&
           verifier.VerifyVector(MiddleData()) &&
           verifier.VerifyVectorOfTables(MiddleData()) &&
           VerifyOffset(verifier, VT_OLDSRFDATA) &&
           verifier.VerifyVector(OldSrfData()) &&
           VerifyOffset(verifier, VT_NEWSRFDATA) &&
           verifier.VerifyVector(NewSrfData()) &&
           VerifyOffset(verifier, VT_PREVIEWDATA) &&
           verifier.VerifyVector(PreviewData()) &&
           verifier.VerifyVectorOfTables(PreviewData()) &&
           VerifyOffset(verifier, VT_TOPODATA) &&
           verifier.VerifyVector(TopoData()) &&
           verifier.VerifyVectorOfTables(TopoData()) &&
           VerifyOffset(verifier, VT_HANDLEDATA) &&
           verifier.VerifyVector(HandleData()) &&
           verifier.VerifyVectorOfTables(HandleData()) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyString(ParamData()) &&
           verifier.EndTable();
  }
};

struct SpecialPreviewInforDataBuilder {
  typedef SpecialPreviewInforData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MiddleData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>>> MiddleData) {
    fbb_.AddOffset(SpecialPreviewInforData::VT_MIDDLEDATA, MiddleData);
  }
  void add_OldSrfData(flatbuffers::Offset<flatbuffers::Vector<int32_t>> OldSrfData) {
    fbb_.AddOffset(SpecialPreviewInforData::VT_OLDSRFDATA, OldSrfData);
  }
  void add_NewSrfData(flatbuffers::Offset<flatbuffers::Vector<int32_t>> NewSrfData) {
    fbb_.AddOffset(SpecialPreviewInforData::VT_NEWSRFDATA, NewSrfData);
  }
  void add_PreviewData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SolidPreviewData>>> PreviewData) {
    fbb_.AddOffset(SpecialPreviewInforData::VT_PREVIEWDATA, PreviewData);
  }
  void add_TopoData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData) {
    fbb_.AddOffset(SpecialPreviewInforData::VT_TOPODATA, TopoData);
  }
  void add_HandleData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData) {
    fbb_.AddOffset(SpecialPreviewInforData::VT_HANDLEDATA, HandleData);
  }
  void add_ParamData(flatbuffers::Offset<flatbuffers::String> ParamData) {
    fbb_.AddOffset(SpecialPreviewInforData::VT_PARAMDATA, ParamData);
  }
  explicit SpecialPreviewInforDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpecialPreviewInforDataBuilder &operator=(const SpecialPreviewInforDataBuilder &);
  flatbuffers::Offset<SpecialPreviewInforData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpecialPreviewInforData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpecialPreviewInforData> CreateSpecialPreviewInforData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>>> MiddleData = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> OldSrfData = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> NewSrfData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SolidPreviewData>>> PreviewData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData = 0,
    flatbuffers::Offset<flatbuffers::String> ParamData = 0) {
  SpecialPreviewInforDataBuilder builder_(_fbb);
  builder_.add_ParamData(ParamData);
  builder_.add_HandleData(HandleData);
  builder_.add_TopoData(TopoData);
  builder_.add_PreviewData(PreviewData);
  builder_.add_NewSrfData(NewSrfData);
  builder_.add_OldSrfData(OldSrfData);
  builder_.add_MiddleData(MiddleData);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpecialPreviewInforData> CreateSpecialPreviewInforDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>> *MiddleData = nullptr,
    const std::vector<int32_t> *OldSrfData = nullptr,
    const std::vector<int32_t> *NewSrfData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SolidPreviewData>> *PreviewData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData = nullptr,
    const char *ParamData = nullptr) {
  auto MiddleData__ = MiddleData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::PreviewDataMessage>>(*MiddleData) : 0;
  auto OldSrfData__ = OldSrfData ? _fbb.CreateVector<int32_t>(*OldSrfData) : 0;
  auto NewSrfData__ = NewSrfData ? _fbb.CreateVector<int32_t>(*NewSrfData) : 0;
  auto PreviewData__ = PreviewData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SolidPreviewData>>(*PreviewData) : 0;
  auto TopoData__ = TopoData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>(*TopoData) : 0;
  auto HandleData__ = HandleData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>(*HandleData) : 0;
  auto ParamData__ = ParamData ? _fbb.CreateString(ParamData) : 0;
  return FlatBufferDocSpace::CreateSpecialPreviewInforData(
      _fbb,
      MiddleData__,
      OldSrfData__,
      NewSrfData__,
      PreviewData__,
      TopoData__,
      HandleData__,
      ParamData__);
}

struct GeometrieData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometrieDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOMTOPOID = 4,
    VT_GEOMID = 6,
    VT_SNAPTYPE = 8,
    VT_PICKPNT = 10,
    VT_INSTANCEID = 12,
    VT_SILHOUETTEINDEX = 14
  };
  const flatbuffers::String *GeomTopoId() const {
    return GetPointer<const flatbuffers::String *>(VT_GEOMTOPOID);
  }
  int32_t GeomId() const {
    return GetField<int32_t>(VT_GEOMID, 0);
  }
  int32_t SnapType() const {
    return GetField<int32_t>(VT_SNAPTYPE, 0);
  }
  const flatbuffers::Vector<double> *PickPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PICKPNT);
  }
  const flatbuffers::String *InstanceId() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID);
  }
  int32_t SilhouetteIndex() const {
    return GetField<int32_t>(VT_SILHOUETTEINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GEOMTOPOID) &&
           verifier.VerifyString(GeomTopoId()) &&
           VerifyField<int32_t>(verifier, VT_GEOMID) &&
           VerifyField<int32_t>(verifier, VT_SNAPTYPE) &&
           VerifyOffset(verifier, VT_PICKPNT) &&
           verifier.VerifyVector(PickPnt()) &&
           VerifyOffset(verifier, VT_INSTANCEID) &&
           verifier.VerifyString(InstanceId()) &&
           VerifyField<int32_t>(verifier, VT_SILHOUETTEINDEX) &&
           verifier.EndTable();
  }
};

struct GeometrieDataBuilder {
  typedef GeometrieData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GeomTopoId(flatbuffers::Offset<flatbuffers::String> GeomTopoId) {
    fbb_.AddOffset(GeometrieData::VT_GEOMTOPOID, GeomTopoId);
  }
  void add_GeomId(int32_t GeomId) {
    fbb_.AddElement<int32_t>(GeometrieData::VT_GEOMID, GeomId, 0);
  }
  void add_SnapType(int32_t SnapType) {
    fbb_.AddElement<int32_t>(GeometrieData::VT_SNAPTYPE, SnapType, 0);
  }
  void add_PickPnt(flatbuffers::Offset<flatbuffers::Vector<double>> PickPnt) {
    fbb_.AddOffset(GeometrieData::VT_PICKPNT, PickPnt);
  }
  void add_InstanceId(flatbuffers::Offset<flatbuffers::String> InstanceId) {
    fbb_.AddOffset(GeometrieData::VT_INSTANCEID, InstanceId);
  }
  void add_SilhouetteIndex(int32_t SilhouetteIndex) {
    fbb_.AddElement<int32_t>(GeometrieData::VT_SILHOUETTEINDEX, SilhouetteIndex, 0);
  }
  explicit GeometrieDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometrieDataBuilder &operator=(const GeometrieDataBuilder &);
  flatbuffers::Offset<GeometrieData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometrieData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometrieData> CreateGeometrieData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> GeomTopoId = 0,
    int32_t GeomId = 0,
    int32_t SnapType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> PickPnt = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId = 0,
    int32_t SilhouetteIndex = 0) {
  GeometrieDataBuilder builder_(_fbb);
  builder_.add_SilhouetteIndex(SilhouetteIndex);
  builder_.add_InstanceId(InstanceId);
  builder_.add_PickPnt(PickPnt);
  builder_.add_SnapType(SnapType);
  builder_.add_GeomId(GeomId);
  builder_.add_GeomTopoId(GeomTopoId);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeometrieData> CreateGeometrieDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *GeomTopoId = nullptr,
    int32_t GeomId = 0,
    int32_t SnapType = 0,
    const std::vector<double> *PickPnt = nullptr,
    const char *InstanceId = nullptr,
    int32_t SilhouetteIndex = 0) {
  auto GeomTopoId__ = GeomTopoId ? _fbb.CreateString(GeomTopoId) : 0;
  auto PickPnt__ = PickPnt ? _fbb.CreateVector<double>(*PickPnt) : 0;
  auto InstanceId__ = InstanceId ? _fbb.CreateString(InstanceId) : 0;
  return FlatBufferDocSpace::CreateGeometrieData(
      _fbb,
      GeomTopoId__,
      GeomId,
      SnapType,
      PickPnt__,
      InstanceId__,
      SilhouetteIndex);
}

struct DiscreteInforData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DiscreteInforDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_V = 6,
    VT_TE = 8,
    VT_FT = 10,
    VT_FN = 12,
    VT_I = 14,
    VT_IC = 16,
    VT_N = 18,
    VT_NC = 20,
    VT_VN = 22,
    VT_VO = 24,
    VT_C = 26,
    VT_VCL = 28,
    VT_VNL = 30,
    VT_FCL = 32,
    VT_FNL = 34
  };
  const flatbuffers::String *T() const {
    return GetPointer<const flatbuffers::String *>(VT_T);
  }
  const flatbuffers::Vector<float> *V() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_V);
  }
  const flatbuffers::Vector<float> *TE() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TE);
  }
  int32_t FT() const {
    return GetField<int32_t>(VT_FT, 0);
  }
  int32_t FN() const {
    return GetField<int32_t>(VT_FN, 0);
  }
  const flatbuffers::Vector<int32_t> *I() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_I);
  }
  const flatbuffers::Vector<uint16_t> *IC() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_IC);
  }
  const flatbuffers::Vector<float> *N() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_N);
  }
  const flatbuffers::Vector<uint16_t> *NC() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_NC);
  }
  int32_t VN() const {
    return GetField<int32_t>(VT_VN, 0);
  }
  int32_t VO() const {
    return GetField<int32_t>(VT_VO, 0);
  }
  const flatbuffers::Vector<float> *C() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_C);
  }
  const flatbuffers::Vector<float> *VCL() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VCL);
  }
  const flatbuffers::Vector<float> *VNL() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VNL);
  }
  const flatbuffers::Vector<float> *FCL() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FCL);
  }
  const flatbuffers::Vector<float> *FNL() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FNL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyString(T()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.VerifyVector(V()) &&
           VerifyOffset(verifier, VT_TE) &&
           verifier.VerifyVector(TE()) &&
           VerifyField<int32_t>(verifier, VT_FT) &&
           VerifyField<int32_t>(verifier, VT_FN) &&
           VerifyOffset(verifier, VT_I) &&
           verifier.VerifyVector(I()) &&
           VerifyOffset(verifier, VT_IC) &&
           verifier.VerifyVector(IC()) &&
           VerifyOffset(verifier, VT_N) &&
           verifier.VerifyVector(N()) &&
           VerifyOffset(verifier, VT_NC) &&
           verifier.VerifyVector(NC()) &&
           VerifyField<int32_t>(verifier, VT_VN) &&
           VerifyField<int32_t>(verifier, VT_VO) &&
           VerifyOffset(verifier, VT_C) &&
           verifier.VerifyVector(C()) &&
           VerifyOffset(verifier, VT_VCL) &&
           verifier.VerifyVector(VCL()) &&
           VerifyOffset(verifier, VT_VNL) &&
           verifier.VerifyVector(VNL()) &&
           VerifyOffset(verifier, VT_FCL) &&
           verifier.VerifyVector(FCL()) &&
           VerifyOffset(verifier, VT_FNL) &&
           verifier.VerifyVector(FNL()) &&
           verifier.EndTable();
  }
};

struct DiscreteInforDataBuilder {
  typedef DiscreteInforData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(flatbuffers::Offset<flatbuffers::String> T) {
    fbb_.AddOffset(DiscreteInforData::VT_T, T);
  }
  void add_V(flatbuffers::Offset<flatbuffers::Vector<float>> V) {
    fbb_.AddOffset(DiscreteInforData::VT_V, V);
  }
  void add_TE(flatbuffers::Offset<flatbuffers::Vector<float>> TE) {
    fbb_.AddOffset(DiscreteInforData::VT_TE, TE);
  }
  void add_FT(int32_t FT) {
    fbb_.AddElement<int32_t>(DiscreteInforData::VT_FT, FT, 0);
  }
  void add_FN(int32_t FN) {
    fbb_.AddElement<int32_t>(DiscreteInforData::VT_FN, FN, 0);
  }
  void add_I(flatbuffers::Offset<flatbuffers::Vector<int32_t>> I) {
    fbb_.AddOffset(DiscreteInforData::VT_I, I);
  }
  void add_IC(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> IC) {
    fbb_.AddOffset(DiscreteInforData::VT_IC, IC);
  }
  void add_N(flatbuffers::Offset<flatbuffers::Vector<float>> N) {
    fbb_.AddOffset(DiscreteInforData::VT_N, N);
  }
  void add_NC(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> NC) {
    fbb_.AddOffset(DiscreteInforData::VT_NC, NC);
  }
  void add_VN(int32_t VN) {
    fbb_.AddElement<int32_t>(DiscreteInforData::VT_VN, VN, 0);
  }
  void add_VO(int32_t VO) {
    fbb_.AddElement<int32_t>(DiscreteInforData::VT_VO, VO, 0);
  }
  void add_C(flatbuffers::Offset<flatbuffers::Vector<float>> C) {
    fbb_.AddOffset(DiscreteInforData::VT_C, C);
  }
  void add_VCL(flatbuffers::Offset<flatbuffers::Vector<float>> VCL) {
    fbb_.AddOffset(DiscreteInforData::VT_VCL, VCL);
  }
  void add_VNL(flatbuffers::Offset<flatbuffers::Vector<float>> VNL) {
    fbb_.AddOffset(DiscreteInforData::VT_VNL, VNL);
  }
  void add_FCL(flatbuffers::Offset<flatbuffers::Vector<float>> FCL) {
    fbb_.AddOffset(DiscreteInforData::VT_FCL, FCL);
  }
  void add_FNL(flatbuffers::Offset<flatbuffers::Vector<float>> FNL) {
    fbb_.AddOffset(DiscreteInforData::VT_FNL, FNL);
  }
  explicit DiscreteInforDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscreteInforDataBuilder &operator=(const DiscreteInforDataBuilder &);
  flatbuffers::Offset<DiscreteInforData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DiscreteInforData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DiscreteInforData> CreateDiscreteInforData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> T = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> V = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> TE = 0,
    int32_t FT = 0,
    int32_t FN = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> I = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> IC = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> N = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> NC = 0,
    int32_t VN = 0,
    int32_t VO = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> C = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> VCL = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> VNL = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> FCL = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> FNL = 0) {
  DiscreteInforDataBuilder builder_(_fbb);
  builder_.add_FNL(FNL);
  builder_.add_FCL(FCL);
  builder_.add_VNL(VNL);
  builder_.add_VCL(VCL);
  builder_.add_C(C);
  builder_.add_VO(VO);
  builder_.add_VN(VN);
  builder_.add_NC(NC);
  builder_.add_N(N);
  builder_.add_IC(IC);
  builder_.add_I(I);
  builder_.add_FN(FN);
  builder_.add_FT(FT);
  builder_.add_TE(TE);
  builder_.add_V(V);
  builder_.add_T(T);
  return builder_.Finish();
}

inline flatbuffers::Offset<DiscreteInforData> CreateDiscreteInforDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *T = nullptr,
    const std::vector<float> *V = nullptr,
    const std::vector<float> *TE = nullptr,
    int32_t FT = 0,
    int32_t FN = 0,
    const std::vector<int32_t> *I = nullptr,
    const std::vector<uint16_t> *IC = nullptr,
    const std::vector<float> *N = nullptr,
    const std::vector<uint16_t> *NC = nullptr,
    int32_t VN = 0,
    int32_t VO = 0,
    const std::vector<float> *C = nullptr,
    const std::vector<float> *VCL = nullptr,
    const std::vector<float> *VNL = nullptr,
    const std::vector<float> *FCL = nullptr,
    const std::vector<float> *FNL = nullptr) {
  auto T__ = T ? _fbb.CreateString(T) : 0;
  auto V__ = V ? _fbb.CreateVector<float>(*V) : 0;
  auto TE__ = TE ? _fbb.CreateVector<float>(*TE) : 0;
  auto I__ = I ? _fbb.CreateVector<int32_t>(*I) : 0;
  auto IC__ = IC ? _fbb.CreateVector<uint16_t>(*IC) : 0;
  auto N__ = N ? _fbb.CreateVector<float>(*N) : 0;
  auto NC__ = NC ? _fbb.CreateVector<uint16_t>(*NC) : 0;
  auto C__ = C ? _fbb.CreateVector<float>(*C) : 0;
  auto VCL__ = VCL ? _fbb.CreateVector<float>(*VCL) : 0;
  auto VNL__ = VNL ? _fbb.CreateVector<float>(*VNL) : 0;
  auto FCL__ = FCL ? _fbb.CreateVector<float>(*FCL) : 0;
  auto FNL__ = FNL ? _fbb.CreateVector<float>(*FNL) : 0;
  return FlatBufferDocSpace::CreateDiscreteInforData(
      _fbb,
      T__,
      V__,
      TE__,
      FT,
      FN,
      I__,
      IC__,
      N__,
      NC__,
      VN,
      VO,
      C__,
      VCL__,
      VNL__,
      FCL__,
      FNL__);
}

struct DiscreteGroupData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DiscreteGroupDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPEARANCEINDEX = 4,
    VT_GROUPDISCRETEDATA = 6
  };
  const flatbuffers::String *AppearanceIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_APPEARANCEINDEX);
  }
  const FlatBufferDocSpace::DiscreteInforData *GroupDiscreteData() const {
    return GetPointer<const FlatBufferDocSpace::DiscreteInforData *>(VT_GROUPDISCRETEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APPEARANCEINDEX) &&
           verifier.VerifyString(AppearanceIndex()) &&
           VerifyOffset(verifier, VT_GROUPDISCRETEDATA) &&
           verifier.VerifyTable(GroupDiscreteData()) &&
           verifier.EndTable();
  }
};

struct DiscreteGroupDataBuilder {
  typedef DiscreteGroupData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AppearanceIndex(flatbuffers::Offset<flatbuffers::String> AppearanceIndex) {
    fbb_.AddOffset(DiscreteGroupData::VT_APPEARANCEINDEX, AppearanceIndex);
  }
  void add_GroupDiscreteData(flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> GroupDiscreteData) {
    fbb_.AddOffset(DiscreteGroupData::VT_GROUPDISCRETEDATA, GroupDiscreteData);
  }
  explicit DiscreteGroupDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscreteGroupDataBuilder &operator=(const DiscreteGroupDataBuilder &);
  flatbuffers::Offset<DiscreteGroupData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DiscreteGroupData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DiscreteGroupData> CreateDiscreteGroupData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> AppearanceIndex = 0,
    flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> GroupDiscreteData = 0) {
  DiscreteGroupDataBuilder builder_(_fbb);
  builder_.add_GroupDiscreteData(GroupDiscreteData);
  builder_.add_AppearanceIndex(AppearanceIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<DiscreteGroupData> CreateDiscreteGroupDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *AppearanceIndex = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData> GroupDiscreteData = 0) {
  auto AppearanceIndex__ = AppearanceIndex ? _fbb.CreateString(AppearanceIndex) : 0;
  return FlatBufferDocSpace::CreateDiscreteGroupData(
      _fbb,
      AppearanceIndex__,
      GroupDiscreteData);
}

struct ConstraintDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstraintDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_GEOMETRIES = 6,
    VT_STATUS = 8,
    VT_POSITION = 10,
    VT_OFFSETVECTOR = 12,
    VT_NAME = 14,
    VT_PARAMINDEX = 16,
    VT_PATTERNTYPE = 18,
    VT_PATTERNELENUM = 20,
    VT_COPYNUM1 = 22,
    VT_COPYNUM2 = 24,
    VT_SKIPINSTANCE = 26,
    VT_DELETEELEMENT = 28,
    VT_ANGLEFLAG = 30,
    VT_COPYNUM = 32,
    VT_COPYNUMINDEX = 34,
    VT_PATTERNCONSTINDEX = 36,
    VT_CONSSYMBOLPOS = 38,
    VT_IMAGEDATABASEID = 40,
    VT_FILENAME = 42,
    VT_ORIGINXPOS = 44,
    VT_ORIGINYPOS = 46,
    VT_ANGLE = 48,
    VT_WIDTH = 50,
    VT_HEIGHT = 52,
    VT_SCALETOOL = 54,
    VT_STARTPNT = 56,
    VT_ENDPNT = 58,
    VT_STARTSTATUS = 60,
    VT_ENDSTATUS = 62,
    VT_CLOCKPRO = 64,
    VT_HORIZONALFLG = 66,
    VT_VERTICALFLG = 68,
    VT_LUCENCYMODE = 70,
    VT_LUCENCYCOLOR = 72,
    VT_MATCHTOL = 74,
    VT_LUCENCYLEVEL = 76,
    VT_CROSSCURVEINDEX = 78
  };
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *Geometries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *>(VT_GEOMETRIES);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  const flatbuffers::Vector<double> *Position() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POSITION);
  }
  const flatbuffers::Vector<double> *OffsetVector() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_OFFSETVECTOR);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t ParamIndex() const {
    return GetField<int32_t>(VT_PARAMINDEX, 0);
  }
  int32_t PatternType() const {
    return GetField<int32_t>(VT_PATTERNTYPE, 0);
  }
  int32_t PatternEleNum() const {
    return GetField<int32_t>(VT_PATTERNELENUM, 0);
  }
  int32_t CopyNum1() const {
    return GetField<int32_t>(VT_COPYNUM1, 0);
  }
  int32_t CopyNum2() const {
    return GetField<int32_t>(VT_COPYNUM2, 0);
  }
  const flatbuffers::String *SkipInstance() const {
    return GetPointer<const flatbuffers::String *>(VT_SKIPINSTANCE);
  }
  const flatbuffers::String *DeleteElement() const {
    return GetPointer<const flatbuffers::String *>(VT_DELETEELEMENT);
  }
  int32_t AngleFlag() const {
    return GetField<int32_t>(VT_ANGLEFLAG, 0);
  }
  int32_t CopyNum() const {
    return GetField<int32_t>(VT_COPYNUM, 0);
  }
  int32_t CopyNumIndex() const {
    return GetField<int32_t>(VT_COPYNUMINDEX, 0);
  }
  int32_t PatternConstIndex() const {
    return GetField<int32_t>(VT_PATTERNCONSTINDEX, 0);
  }
  const flatbuffers::Vector<double> *ConsSymbolPos() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CONSSYMBOLPOS);
  }
  const flatbuffers::String *ImageDatabaseId() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGEDATABASEID);
  }
  const flatbuffers::String *FileName() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  double OriginXPos() const {
    return GetField<double>(VT_ORIGINXPOS, 0.0);
  }
  double OriginYPos() const {
    return GetField<double>(VT_ORIGINYPOS, 0.0);
  }
  double Angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  double Width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  double Height() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  int32_t ScaleTool() const {
    return GetField<int32_t>(VT_SCALETOOL, 0);
  }
  const flatbuffers::Vector<double> *StartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTPNT);
  }
  const flatbuffers::Vector<double> *EndPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDPNT);
  }
  int32_t StartStatus() const {
    return GetField<int32_t>(VT_STARTSTATUS, 0);
  }
  int32_t EndStatus() const {
    return GetField<int32_t>(VT_ENDSTATUS, 0);
  }
  int32_t ClockPro() const {
    return GetField<int32_t>(VT_CLOCKPRO, 0);
  }
  int32_t HorizonalFlg() const {
    return GetField<int32_t>(VT_HORIZONALFLG, 0);
  }
  int32_t VerticalFlg() const {
    return GetField<int32_t>(VT_VERTICALFLG, 0);
  }
  int32_t LucencyMode() const {
    return GetField<int32_t>(VT_LUCENCYMODE, 0);
  }
  const flatbuffers::String *LucencyColor() const {
    return GetPointer<const flatbuffers::String *>(VT_LUCENCYCOLOR);
  }
  double MatchTol() const {
    return GetField<double>(VT_MATCHTOL, 0.0);
  }
  double LucencyLevel() const {
    return GetField<double>(VT_LUCENCYLEVEL, 0.0);
  }
  int32_t CrossCurveIndex() const {
    return GetField<int32_t>(VT_CROSSCURVEINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.VerifyVector(Geometries()) &&
           verifier.VerifyVectorOfTables(Geometries()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyVector(Position()) &&
           VerifyOffset(verifier, VT_OFFSETVECTOR) &&
           verifier.VerifyVector(OffsetVector()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_PARAMINDEX) &&
           VerifyField<int32_t>(verifier, VT_PATTERNTYPE) &&
           VerifyField<int32_t>(verifier, VT_PATTERNELENUM) &&
           VerifyField<int32_t>(verifier, VT_COPYNUM1) &&
           VerifyField<int32_t>(verifier, VT_COPYNUM2) &&
           VerifyOffset(verifier, VT_SKIPINSTANCE) &&
           verifier.VerifyString(SkipInstance()) &&
           VerifyOffset(verifier, VT_DELETEELEMENT) &&
           verifier.VerifyString(DeleteElement()) &&
           VerifyField<int32_t>(verifier, VT_ANGLEFLAG) &&
           VerifyField<int32_t>(verifier, VT_COPYNUM) &&
           VerifyField<int32_t>(verifier, VT_COPYNUMINDEX) &&
           VerifyField<int32_t>(verifier, VT_PATTERNCONSTINDEX) &&
           VerifyOffset(verifier, VT_CONSSYMBOLPOS) &&
           verifier.VerifyVector(ConsSymbolPos()) &&
           VerifyOffset(verifier, VT_IMAGEDATABASEID) &&
           verifier.VerifyString(ImageDatabaseId()) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(FileName()) &&
           VerifyField<double>(verifier, VT_ORIGINXPOS) &&
           VerifyField<double>(verifier, VT_ORIGINYPOS) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           VerifyField<double>(verifier, VT_WIDTH) &&
           VerifyField<double>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_SCALETOOL) &&
           VerifyOffset(verifier, VT_STARTPNT) &&
           verifier.VerifyVector(StartPnt()) &&
           VerifyOffset(verifier, VT_ENDPNT) &&
           verifier.VerifyVector(EndPnt()) &&
           VerifyField<int32_t>(verifier, VT_STARTSTATUS) &&
           VerifyField<int32_t>(verifier, VT_ENDSTATUS) &&
           VerifyField<int32_t>(verifier, VT_CLOCKPRO) &&
           VerifyField<int32_t>(verifier, VT_HORIZONALFLG) &&
           VerifyField<int32_t>(verifier, VT_VERTICALFLG) &&
           VerifyField<int32_t>(verifier, VT_LUCENCYMODE) &&
           VerifyOffset(verifier, VT_LUCENCYCOLOR) &&
           verifier.VerifyString(LucencyColor()) &&
           VerifyField<double>(verifier, VT_MATCHTOL) &&
           VerifyField<double>(verifier, VT_LUCENCYLEVEL) &&
           VerifyField<int32_t>(verifier, VT_CROSSCURVEINDEX) &&
           verifier.EndTable();
  }
};

struct ConstraintDataMessageBuilder {
  typedef ConstraintDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_TYPE, Type, 0);
  }
  void add_Geometries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>> Geometries) {
    fbb_.AddOffset(ConstraintDataMessage::VT_GEOMETRIES, Geometries);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_STATUS, Status, 0);
  }
  void add_Position(flatbuffers::Offset<flatbuffers::Vector<double>> Position) {
    fbb_.AddOffset(ConstraintDataMessage::VT_POSITION, Position);
  }
  void add_OffsetVector(flatbuffers::Offset<flatbuffers::Vector<double>> OffsetVector) {
    fbb_.AddOffset(ConstraintDataMessage::VT_OFFSETVECTOR, OffsetVector);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(ConstraintDataMessage::VT_NAME, Name);
  }
  void add_ParamIndex(int32_t ParamIndex) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_PARAMINDEX, ParamIndex, 0);
  }
  void add_PatternType(int32_t PatternType) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_PATTERNTYPE, PatternType, 0);
  }
  void add_PatternEleNum(int32_t PatternEleNum) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_PATTERNELENUM, PatternEleNum, 0);
  }
  void add_CopyNum1(int32_t CopyNum1) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_COPYNUM1, CopyNum1, 0);
  }
  void add_CopyNum2(int32_t CopyNum2) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_COPYNUM2, CopyNum2, 0);
  }
  void add_SkipInstance(flatbuffers::Offset<flatbuffers::String> SkipInstance) {
    fbb_.AddOffset(ConstraintDataMessage::VT_SKIPINSTANCE, SkipInstance);
  }
  void add_DeleteElement(flatbuffers::Offset<flatbuffers::String> DeleteElement) {
    fbb_.AddOffset(ConstraintDataMessage::VT_DELETEELEMENT, DeleteElement);
  }
  void add_AngleFlag(int32_t AngleFlag) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_ANGLEFLAG, AngleFlag, 0);
  }
  void add_CopyNum(int32_t CopyNum) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_COPYNUM, CopyNum, 0);
  }
  void add_CopyNumIndex(int32_t CopyNumIndex) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_COPYNUMINDEX, CopyNumIndex, 0);
  }
  void add_PatternConstIndex(int32_t PatternConstIndex) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_PATTERNCONSTINDEX, PatternConstIndex, 0);
  }
  void add_ConsSymbolPos(flatbuffers::Offset<flatbuffers::Vector<double>> ConsSymbolPos) {
    fbb_.AddOffset(ConstraintDataMessage::VT_CONSSYMBOLPOS, ConsSymbolPos);
  }
  void add_ImageDatabaseId(flatbuffers::Offset<flatbuffers::String> ImageDatabaseId) {
    fbb_.AddOffset(ConstraintDataMessage::VT_IMAGEDATABASEID, ImageDatabaseId);
  }
  void add_FileName(flatbuffers::Offset<flatbuffers::String> FileName) {
    fbb_.AddOffset(ConstraintDataMessage::VT_FILENAME, FileName);
  }
  void add_OriginXPos(double OriginXPos) {
    fbb_.AddElement<double>(ConstraintDataMessage::VT_ORIGINXPOS, OriginXPos, 0.0);
  }
  void add_OriginYPos(double OriginYPos) {
    fbb_.AddElement<double>(ConstraintDataMessage::VT_ORIGINYPOS, OriginYPos, 0.0);
  }
  void add_Angle(double Angle) {
    fbb_.AddElement<double>(ConstraintDataMessage::VT_ANGLE, Angle, 0.0);
  }
  void add_Width(double Width) {
    fbb_.AddElement<double>(ConstraintDataMessage::VT_WIDTH, Width, 0.0);
  }
  void add_Height(double Height) {
    fbb_.AddElement<double>(ConstraintDataMessage::VT_HEIGHT, Height, 0.0);
  }
  void add_ScaleTool(int32_t ScaleTool) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_SCALETOOL, ScaleTool, 0);
  }
  void add_StartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt) {
    fbb_.AddOffset(ConstraintDataMessage::VT_STARTPNT, StartPnt);
  }
  void add_EndPnt(flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt) {
    fbb_.AddOffset(ConstraintDataMessage::VT_ENDPNT, EndPnt);
  }
  void add_StartStatus(int32_t StartStatus) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_STARTSTATUS, StartStatus, 0);
  }
  void add_EndStatus(int32_t EndStatus) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_ENDSTATUS, EndStatus, 0);
  }
  void add_ClockPro(int32_t ClockPro) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_CLOCKPRO, ClockPro, 0);
  }
  void add_HorizonalFlg(int32_t HorizonalFlg) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_HORIZONALFLG, HorizonalFlg, 0);
  }
  void add_VerticalFlg(int32_t VerticalFlg) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_VERTICALFLG, VerticalFlg, 0);
  }
  void add_LucencyMode(int32_t LucencyMode) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_LUCENCYMODE, LucencyMode, 0);
  }
  void add_LucencyColor(flatbuffers::Offset<flatbuffers::String> LucencyColor) {
    fbb_.AddOffset(ConstraintDataMessage::VT_LUCENCYCOLOR, LucencyColor);
  }
  void add_MatchTol(double MatchTol) {
    fbb_.AddElement<double>(ConstraintDataMessage::VT_MATCHTOL, MatchTol, 0.0);
  }
  void add_LucencyLevel(double LucencyLevel) {
    fbb_.AddElement<double>(ConstraintDataMessage::VT_LUCENCYLEVEL, LucencyLevel, 0.0);
  }
  void add_CrossCurveIndex(int32_t CrossCurveIndex) {
    fbb_.AddElement<int32_t>(ConstraintDataMessage::VT_CROSSCURVEINDEX, CrossCurveIndex, 0);
  }
  explicit ConstraintDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstraintDataMessageBuilder &operator=(const ConstraintDataMessageBuilder &);
  flatbuffers::Offset<ConstraintDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstraintDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstraintDataMessage> CreateConstraintDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>> Geometries = 0,
    int32_t Status = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Position = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> OffsetVector = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t ParamIndex = 0,
    int32_t PatternType = 0,
    int32_t PatternEleNum = 0,
    int32_t CopyNum1 = 0,
    int32_t CopyNum2 = 0,
    flatbuffers::Offset<flatbuffers::String> SkipInstance = 0,
    flatbuffers::Offset<flatbuffers::String> DeleteElement = 0,
    int32_t AngleFlag = 0,
    int32_t CopyNum = 0,
    int32_t CopyNumIndex = 0,
    int32_t PatternConstIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ConsSymbolPos = 0,
    flatbuffers::Offset<flatbuffers::String> ImageDatabaseId = 0,
    flatbuffers::Offset<flatbuffers::String> FileName = 0,
    double OriginXPos = 0.0,
    double OriginYPos = 0.0,
    double Angle = 0.0,
    double Width = 0.0,
    double Height = 0.0,
    int32_t ScaleTool = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt = 0,
    int32_t StartStatus = 0,
    int32_t EndStatus = 0,
    int32_t ClockPro = 0,
    int32_t HorizonalFlg = 0,
    int32_t VerticalFlg = 0,
    int32_t LucencyMode = 0,
    flatbuffers::Offset<flatbuffers::String> LucencyColor = 0,
    double MatchTol = 0.0,
    double LucencyLevel = 0.0,
    int32_t CrossCurveIndex = 0) {
  ConstraintDataMessageBuilder builder_(_fbb);
  builder_.add_LucencyLevel(LucencyLevel);
  builder_.add_MatchTol(MatchTol);
  builder_.add_Height(Height);
  builder_.add_Width(Width);
  builder_.add_Angle(Angle);
  builder_.add_OriginYPos(OriginYPos);
  builder_.add_OriginXPos(OriginXPos);
  builder_.add_CrossCurveIndex(CrossCurveIndex);
  builder_.add_LucencyColor(LucencyColor);
  builder_.add_LucencyMode(LucencyMode);
  builder_.add_VerticalFlg(VerticalFlg);
  builder_.add_HorizonalFlg(HorizonalFlg);
  builder_.add_ClockPro(ClockPro);
  builder_.add_EndStatus(EndStatus);
  builder_.add_StartStatus(StartStatus);
  builder_.add_EndPnt(EndPnt);
  builder_.add_StartPnt(StartPnt);
  builder_.add_ScaleTool(ScaleTool);
  builder_.add_FileName(FileName);
  builder_.add_ImageDatabaseId(ImageDatabaseId);
  builder_.add_ConsSymbolPos(ConsSymbolPos);
  builder_.add_PatternConstIndex(PatternConstIndex);
  builder_.add_CopyNumIndex(CopyNumIndex);
  builder_.add_CopyNum(CopyNum);
  builder_.add_AngleFlag(AngleFlag);
  builder_.add_DeleteElement(DeleteElement);
  builder_.add_SkipInstance(SkipInstance);
  builder_.add_CopyNum2(CopyNum2);
  builder_.add_CopyNum1(CopyNum1);
  builder_.add_PatternEleNum(PatternEleNum);
  builder_.add_PatternType(PatternType);
  builder_.add_ParamIndex(ParamIndex);
  builder_.add_Name(Name);
  builder_.add_OffsetVector(OffsetVector);
  builder_.add_Position(Position);
  builder_.add_Status(Status);
  builder_.add_Geometries(Geometries);
  builder_.add_Type(Type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConstraintDataMessage> CreateConstraintDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Type = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>> *Geometries = nullptr,
    int32_t Status = 0,
    const std::vector<double> *Position = nullptr,
    const std::vector<double> *OffsetVector = nullptr,
    const char *Name = nullptr,
    int32_t ParamIndex = 0,
    int32_t PatternType = 0,
    int32_t PatternEleNum = 0,
    int32_t CopyNum1 = 0,
    int32_t CopyNum2 = 0,
    const char *SkipInstance = nullptr,
    const char *DeleteElement = nullptr,
    int32_t AngleFlag = 0,
    int32_t CopyNum = 0,
    int32_t CopyNumIndex = 0,
    int32_t PatternConstIndex = 0,
    const std::vector<double> *ConsSymbolPos = nullptr,
    const char *ImageDatabaseId = nullptr,
    const char *FileName = nullptr,
    double OriginXPos = 0.0,
    double OriginYPos = 0.0,
    double Angle = 0.0,
    double Width = 0.0,
    double Height = 0.0,
    int32_t ScaleTool = 0,
    const std::vector<double> *StartPnt = nullptr,
    const std::vector<double> *EndPnt = nullptr,
    int32_t StartStatus = 0,
    int32_t EndStatus = 0,
    int32_t ClockPro = 0,
    int32_t HorizonalFlg = 0,
    int32_t VerticalFlg = 0,
    int32_t LucencyMode = 0,
    const char *LucencyColor = nullptr,
    double MatchTol = 0.0,
    double LucencyLevel = 0.0,
    int32_t CrossCurveIndex = 0) {
  auto Geometries__ = Geometries ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::GeometrieData>>(*Geometries) : 0;
  auto Position__ = Position ? _fbb.CreateVector<double>(*Position) : 0;
  auto OffsetVector__ = OffsetVector ? _fbb.CreateVector<double>(*OffsetVector) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto SkipInstance__ = SkipInstance ? _fbb.CreateString(SkipInstance) : 0;
  auto DeleteElement__ = DeleteElement ? _fbb.CreateString(DeleteElement) : 0;
  auto ConsSymbolPos__ = ConsSymbolPos ? _fbb.CreateVector<double>(*ConsSymbolPos) : 0;
  auto ImageDatabaseId__ = ImageDatabaseId ? _fbb.CreateString(ImageDatabaseId) : 0;
  auto FileName__ = FileName ? _fbb.CreateString(FileName) : 0;
  auto StartPnt__ = StartPnt ? _fbb.CreateVector<double>(*StartPnt) : 0;
  auto EndPnt__ = EndPnt ? _fbb.CreateVector<double>(*EndPnt) : 0;
  auto LucencyColor__ = LucencyColor ? _fbb.CreateString(LucencyColor) : 0;
  return FlatBufferDocSpace::CreateConstraintDataMessage(
      _fbb,
      Type,
      Geometries__,
      Status,
      Position__,
      OffsetVector__,
      Name__,
      ParamIndex,
      PatternType,
      PatternEleNum,
      CopyNum1,
      CopyNum2,
      SkipInstance__,
      DeleteElement__,
      AngleFlag,
      CopyNum,
      CopyNumIndex,
      PatternConstIndex,
      ConsSymbolPos__,
      ImageDatabaseId__,
      FileName__,
      OriginXPos,
      OriginYPos,
      Angle,
      Width,
      Height,
      ScaleTool,
      StartPnt__,
      EndPnt__,
      StartStatus,
      EndStatus,
      ClockPro,
      HorizonalFlg,
      VerticalFlg,
      LucencyMode,
      LucencyColor__,
      MatchTol,
      LucencyLevel,
      CrossCurveIndex);
}

struct GeometriesData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometriesDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOMID = 4,
    VT_SNAPTYPE = 6,
    VT_PICKPNT = 8,
    VT_ARCTYPE = 10,
    VT_STARTPNT = 12,
    VT_ENDPNT = 14,
    VT_MIDPNT = 16,
    VT_INSTANCEID = 18,
    VT_SILHOUETTEINDEX = 20,
    VT_DRAWINGMODE = 22,
    VT_VIEWINDEX = 24
  };
  int32_t GeomId() const {
    return GetField<int32_t>(VT_GEOMID, 0);
  }
  int32_t SnapType() const {
    return GetField<int32_t>(VT_SNAPTYPE, 0);
  }
  const flatbuffers::Vector<double> *PickPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PICKPNT);
  }
  int32_t ArcType() const {
    return GetField<int32_t>(VT_ARCTYPE, 0);
  }
  const flatbuffers::Vector<double> *StartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTPNT);
  }
  const flatbuffers::Vector<double> *EndPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDPNT);
  }
  const flatbuffers::Vector<double> *MidPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MIDPNT);
  }
  const flatbuffers::String *InstanceId() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID);
  }
  int32_t SilhouetteIndex() const {
    return GetField<int32_t>(VT_SILHOUETTEINDEX, 0);
  }
  int32_t DrawingMode() const {
    return GetField<int32_t>(VT_DRAWINGMODE, 0);
  }
  const flatbuffers::String *ViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWINDEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GEOMID) &&
           VerifyField<int32_t>(verifier, VT_SNAPTYPE) &&
           VerifyOffset(verifier, VT_PICKPNT) &&
           verifier.VerifyVector(PickPnt()) &&
           VerifyField<int32_t>(verifier, VT_ARCTYPE) &&
           VerifyOffset(verifier, VT_STARTPNT) &&
           verifier.VerifyVector(StartPnt()) &&
           VerifyOffset(verifier, VT_ENDPNT) &&
           verifier.VerifyVector(EndPnt()) &&
           VerifyOffset(verifier, VT_MIDPNT) &&
           verifier.VerifyVector(MidPnt()) &&
           VerifyOffset(verifier, VT_INSTANCEID) &&
           verifier.VerifyString(InstanceId()) &&
           VerifyField<int32_t>(verifier, VT_SILHOUETTEINDEX) &&
           VerifyField<int32_t>(verifier, VT_DRAWINGMODE) &&
           VerifyOffset(verifier, VT_VIEWINDEX) &&
           verifier.VerifyString(ViewIndex()) &&
           verifier.EndTable();
  }
};

struct GeometriesDataBuilder {
  typedef GeometriesData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GeomId(int32_t GeomId) {
    fbb_.AddElement<int32_t>(GeometriesData::VT_GEOMID, GeomId, 0);
  }
  void add_SnapType(int32_t SnapType) {
    fbb_.AddElement<int32_t>(GeometriesData::VT_SNAPTYPE, SnapType, 0);
  }
  void add_PickPnt(flatbuffers::Offset<flatbuffers::Vector<double>> PickPnt) {
    fbb_.AddOffset(GeometriesData::VT_PICKPNT, PickPnt);
  }
  void add_ArcType(int32_t ArcType) {
    fbb_.AddElement<int32_t>(GeometriesData::VT_ARCTYPE, ArcType, 0);
  }
  void add_StartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt) {
    fbb_.AddOffset(GeometriesData::VT_STARTPNT, StartPnt);
  }
  void add_EndPnt(flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt) {
    fbb_.AddOffset(GeometriesData::VT_ENDPNT, EndPnt);
  }
  void add_MidPnt(flatbuffers::Offset<flatbuffers::Vector<double>> MidPnt) {
    fbb_.AddOffset(GeometriesData::VT_MIDPNT, MidPnt);
  }
  void add_InstanceId(flatbuffers::Offset<flatbuffers::String> InstanceId) {
    fbb_.AddOffset(GeometriesData::VT_INSTANCEID, InstanceId);
  }
  void add_SilhouetteIndex(int32_t SilhouetteIndex) {
    fbb_.AddElement<int32_t>(GeometriesData::VT_SILHOUETTEINDEX, SilhouetteIndex, 0);
  }
  void add_DrawingMode(int32_t DrawingMode) {
    fbb_.AddElement<int32_t>(GeometriesData::VT_DRAWINGMODE, DrawingMode, 0);
  }
  void add_ViewIndex(flatbuffers::Offset<flatbuffers::String> ViewIndex) {
    fbb_.AddOffset(GeometriesData::VT_VIEWINDEX, ViewIndex);
  }
  explicit GeometriesDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometriesDataBuilder &operator=(const GeometriesDataBuilder &);
  flatbuffers::Offset<GeometriesData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometriesData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometriesData> CreateGeometriesData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t GeomId = 0,
    int32_t SnapType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> PickPnt = 0,
    int32_t ArcType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MidPnt = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId = 0,
    int32_t SilhouetteIndex = 0,
    int32_t DrawingMode = 0,
    flatbuffers::Offset<flatbuffers::String> ViewIndex = 0) {
  GeometriesDataBuilder builder_(_fbb);
  builder_.add_ViewIndex(ViewIndex);
  builder_.add_DrawingMode(DrawingMode);
  builder_.add_SilhouetteIndex(SilhouetteIndex);
  builder_.add_InstanceId(InstanceId);
  builder_.add_MidPnt(MidPnt);
  builder_.add_EndPnt(EndPnt);
  builder_.add_StartPnt(StartPnt);
  builder_.add_ArcType(ArcType);
  builder_.add_PickPnt(PickPnt);
  builder_.add_SnapType(SnapType);
  builder_.add_GeomId(GeomId);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeometriesData> CreateGeometriesDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t GeomId = 0,
    int32_t SnapType = 0,
    const std::vector<double> *PickPnt = nullptr,
    int32_t ArcType = 0,
    const std::vector<double> *StartPnt = nullptr,
    const std::vector<double> *EndPnt = nullptr,
    const std::vector<double> *MidPnt = nullptr,
    const char *InstanceId = nullptr,
    int32_t SilhouetteIndex = 0,
    int32_t DrawingMode = 0,
    const char *ViewIndex = nullptr) {
  auto PickPnt__ = PickPnt ? _fbb.CreateVector<double>(*PickPnt) : 0;
  auto StartPnt__ = StartPnt ? _fbb.CreateVector<double>(*StartPnt) : 0;
  auto EndPnt__ = EndPnt ? _fbb.CreateVector<double>(*EndPnt) : 0;
  auto MidPnt__ = MidPnt ? _fbb.CreateVector<double>(*MidPnt) : 0;
  auto InstanceId__ = InstanceId ? _fbb.CreateString(InstanceId) : 0;
  auto ViewIndex__ = ViewIndex ? _fbb.CreateString(ViewIndex) : 0;
  return FlatBufferDocSpace::CreateGeometriesData(
      _fbb,
      GeomId,
      SnapType,
      PickPnt__,
      ArcType,
      StartPnt__,
      EndPnt__,
      MidPnt__,
      InstanceId__,
      SilhouetteIndex,
      DrawingMode,
      ViewIndex__);
}

struct LeaderTreeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeaderTreeDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEADERPOINT = 4,
    VT_LEADERPOINTPATH = 6,
    VT_ARROWTYPE = 8,
    VT_REFGEOM = 10
  };
  const flatbuffers::Vector<double> *LeaderPoint() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_LEADERPOINT);
  }
  const flatbuffers::String *LeaderPointPath() const {
    return GetPointer<const flatbuffers::String *>(VT_LEADERPOINTPATH);
  }
  int32_t ArrowType() const {
    return GetField<int32_t>(VT_ARROWTYPE, 0);
  }
  const FlatBufferDocSpace::GeometriesData *RefGeom() const {
    return GetPointer<const FlatBufferDocSpace::GeometriesData *>(VT_REFGEOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LEADERPOINT) &&
           verifier.VerifyVector(LeaderPoint()) &&
           VerifyOffset(verifier, VT_LEADERPOINTPATH) &&
           verifier.VerifyString(LeaderPointPath()) &&
           VerifyField<int32_t>(verifier, VT_ARROWTYPE) &&
           VerifyOffset(verifier, VT_REFGEOM) &&
           verifier.VerifyTable(RefGeom()) &&
           verifier.EndTable();
  }
};

struct LeaderTreeDataBuilder {
  typedef LeaderTreeData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_LeaderPoint(flatbuffers::Offset<flatbuffers::Vector<double>> LeaderPoint) {
    fbb_.AddOffset(LeaderTreeData::VT_LEADERPOINT, LeaderPoint);
  }
  void add_LeaderPointPath(flatbuffers::Offset<flatbuffers::String> LeaderPointPath) {
    fbb_.AddOffset(LeaderTreeData::VT_LEADERPOINTPATH, LeaderPointPath);
  }
  void add_ArrowType(int32_t ArrowType) {
    fbb_.AddElement<int32_t>(LeaderTreeData::VT_ARROWTYPE, ArrowType, 0);
  }
  void add_RefGeom(flatbuffers::Offset<FlatBufferDocSpace::GeometriesData> RefGeom) {
    fbb_.AddOffset(LeaderTreeData::VT_REFGEOM, RefGeom);
  }
  explicit LeaderTreeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeaderTreeDataBuilder &operator=(const LeaderTreeDataBuilder &);
  flatbuffers::Offset<LeaderTreeData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeaderTreeData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeaderTreeData> CreateLeaderTreeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> LeaderPoint = 0,
    flatbuffers::Offset<flatbuffers::String> LeaderPointPath = 0,
    int32_t ArrowType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::GeometriesData> RefGeom = 0) {
  LeaderTreeDataBuilder builder_(_fbb);
  builder_.add_RefGeom(RefGeom);
  builder_.add_ArrowType(ArrowType);
  builder_.add_LeaderPointPath(LeaderPointPath);
  builder_.add_LeaderPoint(LeaderPoint);
  return builder_.Finish();
}

inline flatbuffers::Offset<LeaderTreeData> CreateLeaderTreeDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *LeaderPoint = nullptr,
    const char *LeaderPointPath = nullptr,
    int32_t ArrowType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::GeometriesData> RefGeom = 0) {
  auto LeaderPoint__ = LeaderPoint ? _fbb.CreateVector<double>(*LeaderPoint) : 0;
  auto LeaderPointPath__ = LeaderPointPath ? _fbb.CreateString(LeaderPointPath) : 0;
  return FlatBufferDocSpace::CreateLeaderTreeData(
      _fbb,
      LeaderPoint__,
      LeaderPointPath__,
      ArrowType,
      RefGeom);
}

struct AttributeDataValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeDataValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTRIBUTENAME = 4,
    VT_ATTRIBUTEVIEWID = 6,
    VT_ATTRIBUTEPOSITION = 8,
    VT_ATTRIBUTEDOCID = 10,
    VT_ATTRIBUTEVERSIONID = 12,
    VT_ATTRIBUTECONTENT = 14,
    VT_ATTRIBUTELINKEDFLAG = 16
  };
  const flatbuffers::String *AttributeName() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTRIBUTENAME);
  }
  int32_t AttributeViewId() const {
    return GetField<int32_t>(VT_ATTRIBUTEVIEWID, 0);
  }
  int32_t AttributePosition() const {
    return GetField<int32_t>(VT_ATTRIBUTEPOSITION, 0);
  }
  const flatbuffers::String *AttributeDocID() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTRIBUTEDOCID);
  }
  const flatbuffers::String *AttributeVersionID() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTRIBUTEVERSIONID);
  }
  const flatbuffers::String *AttributeContent() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTRIBUTECONTENT);
  }
  int32_t AttributeLinkedFlag() const {
    return GetField<int32_t>(VT_ATTRIBUTELINKEDFLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRIBUTENAME) &&
           verifier.VerifyString(AttributeName()) &&
           VerifyField<int32_t>(verifier, VT_ATTRIBUTEVIEWID) &&
           VerifyField<int32_t>(verifier, VT_ATTRIBUTEPOSITION) &&
           VerifyOffset(verifier, VT_ATTRIBUTEDOCID) &&
           verifier.VerifyString(AttributeDocID()) &&
           VerifyOffset(verifier, VT_ATTRIBUTEVERSIONID) &&
           verifier.VerifyString(AttributeVersionID()) &&
           VerifyOffset(verifier, VT_ATTRIBUTECONTENT) &&
           verifier.VerifyString(AttributeContent()) &&
           VerifyField<int32_t>(verifier, VT_ATTRIBUTELINKEDFLAG) &&
           verifier.EndTable();
  }
};

struct AttributeDataValueBuilder {
  typedef AttributeDataValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AttributeName(flatbuffers::Offset<flatbuffers::String> AttributeName) {
    fbb_.AddOffset(AttributeDataValue::VT_ATTRIBUTENAME, AttributeName);
  }
  void add_AttributeViewId(int32_t AttributeViewId) {
    fbb_.AddElement<int32_t>(AttributeDataValue::VT_ATTRIBUTEVIEWID, AttributeViewId, 0);
  }
  void add_AttributePosition(int32_t AttributePosition) {
    fbb_.AddElement<int32_t>(AttributeDataValue::VT_ATTRIBUTEPOSITION, AttributePosition, 0);
  }
  void add_AttributeDocID(flatbuffers::Offset<flatbuffers::String> AttributeDocID) {
    fbb_.AddOffset(AttributeDataValue::VT_ATTRIBUTEDOCID, AttributeDocID);
  }
  void add_AttributeVersionID(flatbuffers::Offset<flatbuffers::String> AttributeVersionID) {
    fbb_.AddOffset(AttributeDataValue::VT_ATTRIBUTEVERSIONID, AttributeVersionID);
  }
  void add_AttributeContent(flatbuffers::Offset<flatbuffers::String> AttributeContent) {
    fbb_.AddOffset(AttributeDataValue::VT_ATTRIBUTECONTENT, AttributeContent);
  }
  void add_AttributeLinkedFlag(int32_t AttributeLinkedFlag) {
    fbb_.AddElement<int32_t>(AttributeDataValue::VT_ATTRIBUTELINKEDFLAG, AttributeLinkedFlag, 0);
  }
  explicit AttributeDataValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeDataValueBuilder &operator=(const AttributeDataValueBuilder &);
  flatbuffers::Offset<AttributeDataValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeDataValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeDataValue> CreateAttributeDataValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> AttributeName = 0,
    int32_t AttributeViewId = 0,
    int32_t AttributePosition = 0,
    flatbuffers::Offset<flatbuffers::String> AttributeDocID = 0,
    flatbuffers::Offset<flatbuffers::String> AttributeVersionID = 0,
    flatbuffers::Offset<flatbuffers::String> AttributeContent = 0,
    int32_t AttributeLinkedFlag = 0) {
  AttributeDataValueBuilder builder_(_fbb);
  builder_.add_AttributeLinkedFlag(AttributeLinkedFlag);
  builder_.add_AttributeContent(AttributeContent);
  builder_.add_AttributeVersionID(AttributeVersionID);
  builder_.add_AttributeDocID(AttributeDocID);
  builder_.add_AttributePosition(AttributePosition);
  builder_.add_AttributeViewId(AttributeViewId);
  builder_.add_AttributeName(AttributeName);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeDataValue> CreateAttributeDataValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *AttributeName = nullptr,
    int32_t AttributeViewId = 0,
    int32_t AttributePosition = 0,
    const char *AttributeDocID = nullptr,
    const char *AttributeVersionID = nullptr,
    const char *AttributeContent = nullptr,
    int32_t AttributeLinkedFlag = 0) {
  auto AttributeName__ = AttributeName ? _fbb.CreateString(AttributeName) : 0;
  auto AttributeDocID__ = AttributeDocID ? _fbb.CreateString(AttributeDocID) : 0;
  auto AttributeVersionID__ = AttributeVersionID ? _fbb.CreateString(AttributeVersionID) : 0;
  auto AttributeContent__ = AttributeContent ? _fbb.CreateString(AttributeContent) : 0;
  return FlatBufferDocSpace::CreateAttributeDataValue(
      _fbb,
      AttributeName__,
      AttributeViewId,
      AttributePosition,
      AttributeDocID__,
      AttributeVersionID__,
      AttributeContent__,
      AttributeLinkedFlag);
}

struct TextData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTELEMENT = 4,
    VT_TEXTPOSITION = 6
  };
  const flatbuffers::String *TextElement() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTELEMENT);
  }
  int32_t TextPosition() const {
    return GetField<int32_t>(VT_TEXTPOSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTELEMENT) &&
           verifier.VerifyString(TextElement()) &&
           VerifyField<int32_t>(verifier, VT_TEXTPOSITION) &&
           verifier.EndTable();
  }
};

struct TextDataBuilder {
  typedef TextData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TextElement(flatbuffers::Offset<flatbuffers::String> TextElement) {
    fbb_.AddOffset(TextData::VT_TEXTELEMENT, TextElement);
  }
  void add_TextPosition(int32_t TextPosition) {
    fbb_.AddElement<int32_t>(TextData::VT_TEXTPOSITION, TextPosition, 0);
  }
  explicit TextDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextDataBuilder &operator=(const TextDataBuilder &);
  flatbuffers::Offset<TextData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextData> CreateTextData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TextElement = 0,
    int32_t TextPosition = 0) {
  TextDataBuilder builder_(_fbb);
  builder_.add_TextPosition(TextPosition);
  builder_.add_TextElement(TextElement);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextData> CreateTextDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TextElement = nullptr,
    int32_t TextPosition = 0) {
  auto TextElement__ = TextElement ? _fbb.CreateString(TextElement) : 0;
  return FlatBufferDocSpace::CreateTextData(
      _fbb,
      TextElement__,
      TextPosition);
}

struct DimensionDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimensionDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6,
    VT_TEXT = 8,
    VT_DIMVARIABLE = 10,
    VT_DIRECTION = 12,
    VT_POSITION = 14,
    VT_REFPLANE = 16,
    VT_GEOMPNTS = 18,
    VT_CENTERPNT = 20,
    VT_GEOMETRIES = 22,
    VT_STATUS = 24,
    VT_STARTANGLE = 26,
    VT_ENDANGLE = 28,
    VT_PARAMNAME = 30,
    VT_PARAMINDEX = 32,
    VT_FEATUREINDEX = 34,
    VT_DIMSTATUS = 36,
    VT_RELVIEW = 38,
    VT_LEADTYPE = 40,
    VT_RIGHTARROWTYPE = 42,
    VT_LEFTARROWTYPE = 44,
    VT_DIMLINETYPE = 46,
    VT_DIMLINEWIDTH = 48,
    VT_DIMCOLOR = 50,
    VT_FRAMETYPE = 52,
    VT_FRAMELINETYPE = 54,
    VT_FRAMELINEWIDTH = 56,
    VT_FONTNAME = 58,
    VT_FONTSIZE = 60,
    VT_FONTGAP = 62,
    VT_FONTCOLOR = 64,
    VT_ISITALIC = 66,
    VT_ISBOLD = 68,
    VT_ISUNDERLINE = 70,
    VT_LINEVERSPACE = 72,
    VT_ISALLSURFACES = 74,
    VT_ANGLE = 76,
    VT_DATUMTYPE = 78,
    VT_DATUMTARGETTYPE = 80,
    VT_DIMTEXTPOS = 82,
    VT_ARROWPOS = 84,
    VT_TOLTYPE = 86,
    VT_VALPRECISION = 88,
    VT_TOLPRECISION = 90,
    VT_ISREFERENCE = 92,
    VT_DETAILLABELFLAG = 94,
    VT_SEPERATEFLAG = 96,
    VT_VIEWINDEX = 98,
    VT_ROWINDEX = 100,
    VT_COLINDEX = 102,
    VT_ATTRIBUTEDATAS = 104,
    VT_TEXTDATAS = 106,
    VT_ISDOCFONT = 108,
    VT_ISMANUAL = 110,
    VT_MANUALVALUE = 112,
    VT_FIRSTARCFLAG = 114,
    VT_SECONDARCFLAG = 116,
    VT_RADIUSORDIAMETER = 118,
    VT_ISTHREADDIM = 120,
    VT_DIMMODE = 122,
    VT_RELATIONTYPE = 124,
    VT_ORIGINID = 126,
    VT_FIRSTGEOMID = 128,
    VT_FIRSTGEOMPNT = 130,
    VT_ISALIGNDIMCHAIN = 132,
    VT_DIMCHAINSIDELINEVIS = 134,
    VT_DIMCHAINSIDELINEJOG = 136,
    VT_REFERENCEANDINSPECTION1 = 138,
    VT_REFERENCEANDINSPECTION2 = 140,
    VT_FITTOLCATEGORY = 142,
    VT_FITTOLSHOWTYPE = 144,
    VT_AUTOCALCTOLVARIABLE = 146,
    VT_ARCDIMSTYLE = 148,
    VT_ARCLEADSTYLE = 150,
    VT_USEDOCARCLEADSTYLE = 152,
    VT_ORIGININDEX = 154,
    VT_ISCUSTOMFONT = 156,
    VT_DINDEX = 158,
    VT_DIAMETERSYMBOLFLAG = 160,
    VT_BROKENLINEMODE = 162,
    VT_BROKENPNTS = 164,
    VT_DIMCHAINTYPE = 166,
    VT_DIMCHAINORIGINID = 168,
    VT_CHAMFERDATA = 170,
    VT_TOLTYPE2 = 172,
    VT_TOLPRECISION2 = 174,
    VT_TOLERANCEVAL3 = 176,
    VT_TOLERANCEVAL4 = 178,
    VT_ARCLENBOUNDTYPE = 180,
    VT_ARCLENSYMBOLPOS = 182,
    VT_ISBENDLINELABEL = 184,
    VT_DISPLAYBENDTEXTCONTENT = 186,
    VT_RICHTEXTINFO = 188,
    VT_BOTTOMTEXT = 190,
    VT_BALLOONTEXTTYPE = 192,
    VT_BOTTOMTEXTTYPE = 194,
    VT_PARTQUANTITY = 196,
    VT_DENOTATIONTEXT = 198,
    VT_SHOWQUANTITY = 200,
    VT_USECUSTOMQUANTITY = 202,
    VT_DENOTATIONTYPE = 204,
    VT_DENOTATIONPLACEMENT = 206,
    VT_DENOTATIONDISTANCE = 208,
    VT_FRAMESIZETYPE = 210,
    VT_FRAMESIZE = 212,
    VT_HOLEDATA = 214,
    VT_REVISIONID = 216,
    VT_CLOUDMODE = 218,
    VT_CLOUDMAXRADIUS = 220,
    VT_CLOUDPOINTS = 222,
    VT_FLATANGLE = 224,
    VT_TXTALIGNMODE = 226,
    VT_STACKEDINDEX = 228,
    VT_BALLOONPRELINE = 230,
    VT_STACKTYPE = 232,
    VT_STACKINDEX = 234,
    VT_FIXEDFACEFLAG = 236,
    VT_HOLETAGFLAG = 238,
    VT_HOLETABLEAXISDATA = 240,
    VT_HOLESIZE = 242,
    VT_HOLEPOS = 244,
    VT_DIRECTIONTYPE = 246,
    VT_LEADERLINETREEDATA = 248,
    VT_PROJMODEFLAG = 250,
    VT_AUTOADJUSTBOUNDARYPNT = 252,
    VT_ROTATEVIEWFLAG = 254,
    VT_ORDINATEDIMLEADERPNTS = 256
  };
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *Value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  const flatbuffers::String *Text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const FlatBufferDocSpace::VariableData *DimVariable() const {
    return GetPointer<const FlatBufferDocSpace::VariableData *>(VT_DIMVARIABLE);
  }
  const flatbuffers::Vector<double> *Direction() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DIRECTION);
  }
  const flatbuffers::Vector<double> *Position() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POSITION);
  }
  const flatbuffers::Vector<double> *RefPlane() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_REFPLANE);
  }
  const flatbuffers::Vector<double> *GeomPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_GEOMPNTS);
  }
  const flatbuffers::Vector<double> *CenterPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CENTERPNT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometriesData>> *Geometries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometriesData>> *>(VT_GEOMETRIES);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  double StartAngle() const {
    return GetField<double>(VT_STARTANGLE, 0.0);
  }
  double EndAngle() const {
    return GetField<double>(VT_ENDANGLE, 0.0);
  }
  const flatbuffers::String *ParamName() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMNAME);
  }
  int32_t ParamIndex() const {
    return GetField<int32_t>(VT_PARAMINDEX, 0);
  }
  const flatbuffers::String *FeatureIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_FEATUREINDEX);
  }
  int32_t DimStatus() const {
    return GetField<int32_t>(VT_DIMSTATUS, 0);
  }
  int32_t RelView() const {
    return GetField<int32_t>(VT_RELVIEW, 0);
  }
  int32_t LeadType() const {
    return GetField<int32_t>(VT_LEADTYPE, 0);
  }
  int32_t RightArrowType() const {
    return GetField<int32_t>(VT_RIGHTARROWTYPE, 0);
  }
  int32_t LeftArrowType() const {
    return GetField<int32_t>(VT_LEFTARROWTYPE, 0);
  }
  int32_t DimLineType() const {
    return GetField<int32_t>(VT_DIMLINETYPE, 0);
  }
  int32_t DimLineWidth() const {
    return GetField<int32_t>(VT_DIMLINEWIDTH, 0);
  }
  int32_t DimColor() const {
    return GetField<int32_t>(VT_DIMCOLOR, 0);
  }
  int32_t FrameType() const {
    return GetField<int32_t>(VT_FRAMETYPE, 0);
  }
  int32_t FrameLineType() const {
    return GetField<int32_t>(VT_FRAMELINETYPE, 0);
  }
  int32_t FrameLineWidth() const {
    return GetField<int32_t>(VT_FRAMELINEWIDTH, 0);
  }
  const flatbuffers::String *FontName() const {
    return GetPointer<const flatbuffers::String *>(VT_FONTNAME);
  }
  double FontSize() const {
    return GetField<double>(VT_FONTSIZE, 0.0);
  }
  int32_t FontGap() const {
    return GetField<int32_t>(VT_FONTGAP, 0);
  }
  int32_t FontColor() const {
    return GetField<int32_t>(VT_FONTCOLOR, 0);
  }
  int32_t IsItalic() const {
    return GetField<int32_t>(VT_ISITALIC, 0);
  }
  int32_t IsBold() const {
    return GetField<int32_t>(VT_ISBOLD, 0);
  }
  int32_t IsUnderLine() const {
    return GetField<int32_t>(VT_ISUNDERLINE, 0);
  }
  int32_t LineVerSpace() const {
    return GetField<int32_t>(VT_LINEVERSPACE, 0);
  }
  int32_t IsAllSurfaces() const {
    return GetField<int32_t>(VT_ISALLSURFACES, 0);
  }
  double Angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  int32_t DatumType() const {
    return GetField<int32_t>(VT_DATUMTYPE, 0);
  }
  int32_t DatumTargetType() const {
    return GetField<int32_t>(VT_DATUMTARGETTYPE, 0);
  }
  int32_t DimTextPos() const {
    return GetField<int32_t>(VT_DIMTEXTPOS, 0);
  }
  int32_t ArrowPos() const {
    return GetField<int32_t>(VT_ARROWPOS, 0);
  }
  int32_t TolType() const {
    return GetField<int32_t>(VT_TOLTYPE, 0);
  }
  int32_t ValPrecision() const {
    return GetField<int32_t>(VT_VALPRECISION, 0);
  }
  int32_t TolPrecision() const {
    return GetField<int32_t>(VT_TOLPRECISION, 0);
  }
  int32_t IsReference() const {
    return GetField<int32_t>(VT_ISREFERENCE, 0);
  }
  int32_t DetailLabelFlag() const {
    return GetField<int32_t>(VT_DETAILLABELFLAG, 0);
  }
  int32_t SeperateFlag() const {
    return GetField<int32_t>(VT_SEPERATEFLAG, 0);
  }
  const flatbuffers::String *ViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWINDEX);
  }
  int32_t RowIndex() const {
    return GetField<int32_t>(VT_ROWINDEX, 0);
  }
  int32_t ColIndex() const {
    return GetField<int32_t>(VT_COLINDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AttributeDataValue>> *AttributeDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AttributeDataValue>> *>(VT_ATTRIBUTEDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>> *TextDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>> *>(VT_TEXTDATAS);
  }
  int32_t IsDocFont() const {
    return GetField<int32_t>(VT_ISDOCFONT, 0);
  }
  int32_t IsManual() const {
    return GetField<int32_t>(VT_ISMANUAL, 0);
  }
  const flatbuffers::String *ManualValue() const {
    return GetPointer<const flatbuffers::String *>(VT_MANUALVALUE);
  }
  int32_t FirstArcFlag() const {
    return GetField<int32_t>(VT_FIRSTARCFLAG, 0);
  }
  int32_t SecondArcFlag() const {
    return GetField<int32_t>(VT_SECONDARCFLAG, 0);
  }
  int32_t RadiusOrDiameter() const {
    return GetField<int32_t>(VT_RADIUSORDIAMETER, 0);
  }
  int32_t IsThreadDim() const {
    return GetField<int32_t>(VT_ISTHREADDIM, 0);
  }
  int32_t DimMode() const {
    return GetField<int32_t>(VT_DIMMODE, 0);
  }
  int32_t RelationType() const {
    return GetField<int32_t>(VT_RELATIONTYPE, 0);
  }
  int32_t OriginId() const {
    return GetField<int32_t>(VT_ORIGINID, 0);
  }
  int32_t FirstGeomId() const {
    return GetField<int32_t>(VT_FIRSTGEOMID, 0);
  }
  const flatbuffers::Vector<double> *FirstGeomPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_FIRSTGEOMPNT);
  }
  int32_t IsAlignDimChain() const {
    return GetField<int32_t>(VT_ISALIGNDIMCHAIN, 0);
  }
  int32_t DimChainSideLineVis() const {
    return GetField<int32_t>(VT_DIMCHAINSIDELINEVIS, 0);
  }
  int32_t DimChainSideLineJog() const {
    return GetField<int32_t>(VT_DIMCHAINSIDELINEJOG, 0);
  }
  int32_t ReferenceAndInspection1() const {
    return GetField<int32_t>(VT_REFERENCEANDINSPECTION1, 0);
  }
  int32_t ReferenceAndInspection2() const {
    return GetField<int32_t>(VT_REFERENCEANDINSPECTION2, 0);
  }
  int32_t FitTolCategory() const {
    return GetField<int32_t>(VT_FITTOLCATEGORY, 0);
  }
  int32_t FitTolShowType() const {
    return GetField<int32_t>(VT_FITTOLSHOWTYPE, 0);
  }
  int32_t AutoCalcTolVariable() const {
    return GetField<int32_t>(VT_AUTOCALCTOLVARIABLE, 0);
  }
  int32_t ArcDimStyle() const {
    return GetField<int32_t>(VT_ARCDIMSTYLE, 0);
  }
  int32_t ArcLeadStyle() const {
    return GetField<int32_t>(VT_ARCLEADSTYLE, 0);
  }
  int32_t UseDocArcLeadStyle() const {
    return GetField<int32_t>(VT_USEDOCARCLEADSTYLE, 0);
  }
  int32_t OriginIndex() const {
    return GetField<int32_t>(VT_ORIGININDEX, 0);
  }
  int32_t IsCustomFont() const {
    return GetField<int32_t>(VT_ISCUSTOMFONT, 0);
  }
  const flatbuffers::String *DIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_DINDEX);
  }
  int32_t DiameterSymbolFlag() const {
    return GetField<int32_t>(VT_DIAMETERSYMBOLFLAG, 0);
  }
  int32_t BrokenLineMode() const {
    return GetField<int32_t>(VT_BROKENLINEMODE, 0);
  }
  const flatbuffers::Vector<double> *BrokenPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_BROKENPNTS);
  }
  int32_t DimChainType() const {
    return GetField<int32_t>(VT_DIMCHAINTYPE, 0);
  }
  int32_t DimChainOriginID() const {
    return GetField<int32_t>(VT_DIMCHAINORIGINID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ChamferDataElement>> *ChamferData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ChamferDataElement>> *>(VT_CHAMFERDATA);
  }
  int32_t TolType2() const {
    return GetField<int32_t>(VT_TOLTYPE2, 0);
  }
  int32_t TolPrecision2() const {
    return GetField<int32_t>(VT_TOLPRECISION2, 0);
  }
  double ToleranceVal3() const {
    return GetField<double>(VT_TOLERANCEVAL3, 0.0);
  }
  double ToleranceVal4() const {
    return GetField<double>(VT_TOLERANCEVAL4, 0.0);
  }
  int32_t ArcLenBoundType() const {
    return GetField<int32_t>(VT_ARCLENBOUNDTYPE, 0);
  }
  int32_t ArcLenSymbolPos() const {
    return GetField<int32_t>(VT_ARCLENSYMBOLPOS, 0);
  }
  int32_t IsBendLineLabel() const {
    return GetField<int32_t>(VT_ISBENDLINELABEL, 0);
  }
  const flatbuffers::String *DisplayBendTextContent() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYBENDTEXTCONTENT);
  }
  const flatbuffers::String *RichTextInfo() const {
    return GetPointer<const flatbuffers::String *>(VT_RICHTEXTINFO);
  }
  const flatbuffers::String *BottomText() const {
    return GetPointer<const flatbuffers::String *>(VT_BOTTOMTEXT);
  }
  const flatbuffers::String *BalloonTextType() const {
    return GetPointer<const flatbuffers::String *>(VT_BALLOONTEXTTYPE);
  }
  const flatbuffers::String *BottomTextType() const {
    return GetPointer<const flatbuffers::String *>(VT_BOTTOMTEXTTYPE);
  }
  const flatbuffers::String *PartQuantity() const {
    return GetPointer<const flatbuffers::String *>(VT_PARTQUANTITY);
  }
  const flatbuffers::String *DenotationText() const {
    return GetPointer<const flatbuffers::String *>(VT_DENOTATIONTEXT);
  }
  int32_t ShowQuantity() const {
    return GetField<int32_t>(VT_SHOWQUANTITY, 0);
  }
  int32_t UseCustomQuantity() const {
    return GetField<int32_t>(VT_USECUSTOMQUANTITY, 0);
  }
  int32_t DenotationType() const {
    return GetField<int32_t>(VT_DENOTATIONTYPE, 0);
  }
  int32_t DenotationPlacement() const {
    return GetField<int32_t>(VT_DENOTATIONPLACEMENT, 0);
  }
  double DenotationDistance() const {
    return GetField<double>(VT_DENOTATIONDISTANCE, 0.0);
  }
  int32_t FrameSizeType() const {
    return GetField<int32_t>(VT_FRAMESIZETYPE, 0);
  }
  float FrameSize() const {
    return GetField<float>(VT_FRAMESIZE, 0.0f);
  }
  const FlatBufferDocSpace::HoleDataElement *HoleData() const {
    return GetPointer<const FlatBufferDocSpace::HoleDataElement *>(VT_HOLEDATA);
  }
  const flatbuffers::String *RevisionId() const {
    return GetPointer<const flatbuffers::String *>(VT_REVISIONID);
  }
  int32_t CloudMode() const {
    return GetField<int32_t>(VT_CLOUDMODE, 0);
  }
  double CloudMaxRadius() const {
    return GetField<double>(VT_CLOUDMAXRADIUS, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CloudPointData>> *CloudPoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CloudPointData>> *>(VT_CLOUDPOINTS);
  }
  double FlatAngle() const {
    return GetField<double>(VT_FLATANGLE, 0.0);
  }
  int32_t TxtAlignMode() const {
    return GetField<int32_t>(VT_TXTALIGNMODE, 0);
  }
  const flatbuffers::String *StackedIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_STACKEDINDEX);
  }
  int32_t BalloonPreLine() const {
    return GetField<int32_t>(VT_BALLOONPRELINE, 0);
  }
  int32_t StackType() const {
    return GetField<int32_t>(VT_STACKTYPE, 0);
  }
  int32_t StackIndex() const {
    return GetField<int32_t>(VT_STACKINDEX, 0);
  }
  int32_t FixedFaceFlag() const {
    return GetField<int32_t>(VT_FIXEDFACEFLAG, 0);
  }
  int32_t HoleTagFlag() const {
    return GetField<int32_t>(VT_HOLETAGFLAG, 0);
  }
  const FlatBufferDocSpace::HoleTableAxis *HoleTableAxisData() const {
    return GetPointer<const FlatBufferDocSpace::HoleTableAxis *>(VT_HOLETABLEAXISDATA);
  }
  const FlatBufferDocSpace::HoleSizeData *HoleSize() const {
    return GetPointer<const FlatBufferDocSpace::HoleSizeData *>(VT_HOLESIZE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HolePosData>> *HolePos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HolePosData>> *>(VT_HOLEPOS);
  }
  int32_t DirectionType() const {
    return GetField<int32_t>(VT_DIRECTIONTYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LeaderTreeData>> *LeaderLineTreeData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LeaderTreeData>> *>(VT_LEADERLINETREEDATA);
  }
  int32_t ProjModeFlag() const {
    return GetField<int32_t>(VT_PROJMODEFLAG, 0);
  }
  int32_t AutoAdjustBoundaryPnt() const {
    return GetField<int32_t>(VT_AUTOADJUSTBOUNDARYPNT, 0);
  }
  int32_t RotateViewFlag() const {
    return GetField<int32_t>(VT_ROTATEVIEWFLAG, 0);
  }
  const flatbuffers::Vector<double> *OrdinateDimLeaderPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ORDINATEDIMLEADERPNTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(Text()) &&
           VerifyOffset(verifier, VT_DIMVARIABLE) &&
           verifier.VerifyTable(DimVariable()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyVector(Direction()) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyVector(Position()) &&
           VerifyOffset(verifier, VT_REFPLANE) &&
           verifier.VerifyVector(RefPlane()) &&
           VerifyOffset(verifier, VT_GEOMPNTS) &&
           verifier.VerifyVector(GeomPnts()) &&
           VerifyOffset(verifier, VT_CENTERPNT) &&
           verifier.VerifyVector(CenterPnt()) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.VerifyVector(Geometries()) &&
           verifier.VerifyVectorOfTables(Geometries()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<double>(verifier, VT_STARTANGLE) &&
           VerifyField<double>(verifier, VT_ENDANGLE) &&
           VerifyOffset(verifier, VT_PARAMNAME) &&
           verifier.VerifyString(ParamName()) &&
           VerifyField<int32_t>(verifier, VT_PARAMINDEX) &&
           VerifyOffset(verifier, VT_FEATUREINDEX) &&
           verifier.VerifyString(FeatureIndex()) &&
           VerifyField<int32_t>(verifier, VT_DIMSTATUS) &&
           VerifyField<int32_t>(verifier, VT_RELVIEW) &&
           VerifyField<int32_t>(verifier, VT_LEADTYPE) &&
           VerifyField<int32_t>(verifier, VT_RIGHTARROWTYPE) &&
           VerifyField<int32_t>(verifier, VT_LEFTARROWTYPE) &&
           VerifyField<int32_t>(verifier, VT_DIMLINETYPE) &&
           VerifyField<int32_t>(verifier, VT_DIMLINEWIDTH) &&
           VerifyField<int32_t>(verifier, VT_DIMCOLOR) &&
           VerifyField<int32_t>(verifier, VT_FRAMETYPE) &&
           VerifyField<int32_t>(verifier, VT_FRAMELINETYPE) &&
           VerifyField<int32_t>(verifier, VT_FRAMELINEWIDTH) &&
           VerifyOffset(verifier, VT_FONTNAME) &&
           verifier.VerifyString(FontName()) &&
           VerifyField<double>(verifier, VT_FONTSIZE) &&
           VerifyField<int32_t>(verifier, VT_FONTGAP) &&
           VerifyField<int32_t>(verifier, VT_FONTCOLOR) &&
           VerifyField<int32_t>(verifier, VT_ISITALIC) &&
           VerifyField<int32_t>(verifier, VT_ISBOLD) &&
           VerifyField<int32_t>(verifier, VT_ISUNDERLINE) &&
           VerifyField<int32_t>(verifier, VT_LINEVERSPACE) &&
           VerifyField<int32_t>(verifier, VT_ISALLSURFACES) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_DATUMTYPE) &&
           VerifyField<int32_t>(verifier, VT_DATUMTARGETTYPE) &&
           VerifyField<int32_t>(verifier, VT_DIMTEXTPOS) &&
           VerifyField<int32_t>(verifier, VT_ARROWPOS) &&
           VerifyField<int32_t>(verifier, VT_TOLTYPE) &&
           VerifyField<int32_t>(verifier, VT_VALPRECISION) &&
           VerifyField<int32_t>(verifier, VT_TOLPRECISION) &&
           VerifyField<int32_t>(verifier, VT_ISREFERENCE) &&
           VerifyField<int32_t>(verifier, VT_DETAILLABELFLAG) &&
           VerifyField<int32_t>(verifier, VT_SEPERATEFLAG) &&
           VerifyOffset(verifier, VT_VIEWINDEX) &&
           verifier.VerifyString(ViewIndex()) &&
           VerifyField<int32_t>(verifier, VT_ROWINDEX) &&
           VerifyField<int32_t>(verifier, VT_COLINDEX) &&
           VerifyOffset(verifier, VT_ATTRIBUTEDATAS) &&
           verifier.VerifyVector(AttributeDatas()) &&
           verifier.VerifyVectorOfTables(AttributeDatas()) &&
           VerifyOffset(verifier, VT_TEXTDATAS) &&
           verifier.VerifyVector(TextDatas()) &&
           verifier.VerifyVectorOfTables(TextDatas()) &&
           VerifyField<int32_t>(verifier, VT_ISDOCFONT) &&
           VerifyField<int32_t>(verifier, VT_ISMANUAL) &&
           VerifyOffset(verifier, VT_MANUALVALUE) &&
           verifier.VerifyString(ManualValue()) &&
           VerifyField<int32_t>(verifier, VT_FIRSTARCFLAG) &&
           VerifyField<int32_t>(verifier, VT_SECONDARCFLAG) &&
           VerifyField<int32_t>(verifier, VT_RADIUSORDIAMETER) &&
           VerifyField<int32_t>(verifier, VT_ISTHREADDIM) &&
           VerifyField<int32_t>(verifier, VT_DIMMODE) &&
           VerifyField<int32_t>(verifier, VT_RELATIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_ORIGINID) &&
           VerifyField<int32_t>(verifier, VT_FIRSTGEOMID) &&
           VerifyOffset(verifier, VT_FIRSTGEOMPNT) &&
           verifier.VerifyVector(FirstGeomPnt()) &&
           VerifyField<int32_t>(verifier, VT_ISALIGNDIMCHAIN) &&
           VerifyField<int32_t>(verifier, VT_DIMCHAINSIDELINEVIS) &&
           VerifyField<int32_t>(verifier, VT_DIMCHAINSIDELINEJOG) &&
           VerifyField<int32_t>(verifier, VT_REFERENCEANDINSPECTION1) &&
           VerifyField<int32_t>(verifier, VT_REFERENCEANDINSPECTION2) &&
           VerifyField<int32_t>(verifier, VT_FITTOLCATEGORY) &&
           VerifyField<int32_t>(verifier, VT_FITTOLSHOWTYPE) &&
           VerifyField<int32_t>(verifier, VT_AUTOCALCTOLVARIABLE) &&
           VerifyField<int32_t>(verifier, VT_ARCDIMSTYLE) &&
           VerifyField<int32_t>(verifier, VT_ARCLEADSTYLE) &&
           VerifyField<int32_t>(verifier, VT_USEDOCARCLEADSTYLE) &&
           VerifyField<int32_t>(verifier, VT_ORIGININDEX) &&
           VerifyField<int32_t>(verifier, VT_ISCUSTOMFONT) &&
           VerifyOffset(verifier, VT_DINDEX) &&
           verifier.VerifyString(DIndex()) &&
           VerifyField<int32_t>(verifier, VT_DIAMETERSYMBOLFLAG) &&
           VerifyField<int32_t>(verifier, VT_BROKENLINEMODE) &&
           VerifyOffset(verifier, VT_BROKENPNTS) &&
           verifier.VerifyVector(BrokenPnts()) &&
           VerifyField<int32_t>(verifier, VT_DIMCHAINTYPE) &&
           VerifyField<int32_t>(verifier, VT_DIMCHAINORIGINID) &&
           VerifyOffset(verifier, VT_CHAMFERDATA) &&
           verifier.VerifyVector(ChamferData()) &&
           verifier.VerifyVectorOfTables(ChamferData()) &&
           VerifyField<int32_t>(verifier, VT_TOLTYPE2) &&
           VerifyField<int32_t>(verifier, VT_TOLPRECISION2) &&
           VerifyField<double>(verifier, VT_TOLERANCEVAL3) &&
           VerifyField<double>(verifier, VT_TOLERANCEVAL4) &&
           VerifyField<int32_t>(verifier, VT_ARCLENBOUNDTYPE) &&
           VerifyField<int32_t>(verifier, VT_ARCLENSYMBOLPOS) &&
           VerifyField<int32_t>(verifier, VT_ISBENDLINELABEL) &&
           VerifyOffset(verifier, VT_DISPLAYBENDTEXTCONTENT) &&
           verifier.VerifyString(DisplayBendTextContent()) &&
           VerifyOffset(verifier, VT_RICHTEXTINFO) &&
           verifier.VerifyString(RichTextInfo()) &&
           VerifyOffset(verifier, VT_BOTTOMTEXT) &&
           verifier.VerifyString(BottomText()) &&
           VerifyOffset(verifier, VT_BALLOONTEXTTYPE) &&
           verifier.VerifyString(BalloonTextType()) &&
           VerifyOffset(verifier, VT_BOTTOMTEXTTYPE) &&
           verifier.VerifyString(BottomTextType()) &&
           VerifyOffset(verifier, VT_PARTQUANTITY) &&
           verifier.VerifyString(PartQuantity()) &&
           VerifyOffset(verifier, VT_DENOTATIONTEXT) &&
           verifier.VerifyString(DenotationText()) &&
           VerifyField<int32_t>(verifier, VT_SHOWQUANTITY) &&
           VerifyField<int32_t>(verifier, VT_USECUSTOMQUANTITY) &&
           VerifyField<int32_t>(verifier, VT_DENOTATIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_DENOTATIONPLACEMENT) &&
           VerifyField<double>(verifier, VT_DENOTATIONDISTANCE) &&
           VerifyField<int32_t>(verifier, VT_FRAMESIZETYPE) &&
           VerifyField<float>(verifier, VT_FRAMESIZE) &&
           VerifyOffset(verifier, VT_HOLEDATA) &&
           verifier.VerifyTable(HoleData()) &&
           VerifyOffset(verifier, VT_REVISIONID) &&
           verifier.VerifyString(RevisionId()) &&
           VerifyField<int32_t>(verifier, VT_CLOUDMODE) &&
           VerifyField<double>(verifier, VT_CLOUDMAXRADIUS) &&
           VerifyOffset(verifier, VT_CLOUDPOINTS) &&
           verifier.VerifyVector(CloudPoints()) &&
           verifier.VerifyVectorOfTables(CloudPoints()) &&
           VerifyField<double>(verifier, VT_FLATANGLE) &&
           VerifyField<int32_t>(verifier, VT_TXTALIGNMODE) &&
           VerifyOffset(verifier, VT_STACKEDINDEX) &&
           verifier.VerifyString(StackedIndex()) &&
           VerifyField<int32_t>(verifier, VT_BALLOONPRELINE) &&
           VerifyField<int32_t>(verifier, VT_STACKTYPE) &&
           VerifyField<int32_t>(verifier, VT_STACKINDEX) &&
           VerifyField<int32_t>(verifier, VT_FIXEDFACEFLAG) &&
           VerifyField<int32_t>(verifier, VT_HOLETAGFLAG) &&
           VerifyOffset(verifier, VT_HOLETABLEAXISDATA) &&
           verifier.VerifyTable(HoleTableAxisData()) &&
           VerifyOffset(verifier, VT_HOLESIZE) &&
           verifier.VerifyTable(HoleSize()) &&
           VerifyOffset(verifier, VT_HOLEPOS) &&
           verifier.VerifyVector(HolePos()) &&
           verifier.VerifyVectorOfTables(HolePos()) &&
           VerifyField<int32_t>(verifier, VT_DIRECTIONTYPE) &&
           VerifyOffset(verifier, VT_LEADERLINETREEDATA) &&
           verifier.VerifyVector(LeaderLineTreeData()) &&
           verifier.VerifyVectorOfTables(LeaderLineTreeData()) &&
           VerifyField<int32_t>(verifier, VT_PROJMODEFLAG) &&
           VerifyField<int32_t>(verifier, VT_AUTOADJUSTBOUNDARYPNT) &&
           VerifyField<int32_t>(verifier, VT_ROTATEVIEWFLAG) &&
           VerifyOffset(verifier, VT_ORDINATEDIMLEADERPNTS) &&
           verifier.VerifyVector(OrdinateDimLeaderPnts()) &&
           verifier.EndTable();
  }
};

struct DimensionDataMessageBuilder {
  typedef DimensionDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(DimensionDataMessage::VT_TYPE, Type);
  }
  void add_Value(flatbuffers::Offset<flatbuffers::String> Value) {
    fbb_.AddOffset(DimensionDataMessage::VT_VALUE, Value);
  }
  void add_Text(flatbuffers::Offset<flatbuffers::String> Text) {
    fbb_.AddOffset(DimensionDataMessage::VT_TEXT, Text);
  }
  void add_DimVariable(flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable) {
    fbb_.AddOffset(DimensionDataMessage::VT_DIMVARIABLE, DimVariable);
  }
  void add_Direction(flatbuffers::Offset<flatbuffers::Vector<double>> Direction) {
    fbb_.AddOffset(DimensionDataMessage::VT_DIRECTION, Direction);
  }
  void add_Position(flatbuffers::Offset<flatbuffers::Vector<double>> Position) {
    fbb_.AddOffset(DimensionDataMessage::VT_POSITION, Position);
  }
  void add_RefPlane(flatbuffers::Offset<flatbuffers::Vector<double>> RefPlane) {
    fbb_.AddOffset(DimensionDataMessage::VT_REFPLANE, RefPlane);
  }
  void add_GeomPnts(flatbuffers::Offset<flatbuffers::Vector<double>> GeomPnts) {
    fbb_.AddOffset(DimensionDataMessage::VT_GEOMPNTS, GeomPnts);
  }
  void add_CenterPnt(flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt) {
    fbb_.AddOffset(DimensionDataMessage::VT_CENTERPNT, CenterPnt);
  }
  void add_Geometries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometriesData>>> Geometries) {
    fbb_.AddOffset(DimensionDataMessage::VT_GEOMETRIES, Geometries);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_STATUS, Status, 0);
  }
  void add_StartAngle(double StartAngle) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_STARTANGLE, StartAngle, 0.0);
  }
  void add_EndAngle(double EndAngle) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_ENDANGLE, EndAngle, 0.0);
  }
  void add_ParamName(flatbuffers::Offset<flatbuffers::String> ParamName) {
    fbb_.AddOffset(DimensionDataMessage::VT_PARAMNAME, ParamName);
  }
  void add_ParamIndex(int32_t ParamIndex) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_PARAMINDEX, ParamIndex, 0);
  }
  void add_FeatureIndex(flatbuffers::Offset<flatbuffers::String> FeatureIndex) {
    fbb_.AddOffset(DimensionDataMessage::VT_FEATUREINDEX, FeatureIndex);
  }
  void add_DimStatus(int32_t DimStatus) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMSTATUS, DimStatus, 0);
  }
  void add_RelView(int32_t RelView) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_RELVIEW, RelView, 0);
  }
  void add_LeadType(int32_t LeadType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_LEADTYPE, LeadType, 0);
  }
  void add_RightArrowType(int32_t RightArrowType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_RIGHTARROWTYPE, RightArrowType, 0);
  }
  void add_LeftArrowType(int32_t LeftArrowType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_LEFTARROWTYPE, LeftArrowType, 0);
  }
  void add_DimLineType(int32_t DimLineType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMLINETYPE, DimLineType, 0);
  }
  void add_DimLineWidth(int32_t DimLineWidth) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMLINEWIDTH, DimLineWidth, 0);
  }
  void add_DimColor(int32_t DimColor) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMCOLOR, DimColor, 0);
  }
  void add_FrameType(int32_t FrameType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FRAMETYPE, FrameType, 0);
  }
  void add_FrameLineType(int32_t FrameLineType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FRAMELINETYPE, FrameLineType, 0);
  }
  void add_FrameLineWidth(int32_t FrameLineWidth) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FRAMELINEWIDTH, FrameLineWidth, 0);
  }
  void add_FontName(flatbuffers::Offset<flatbuffers::String> FontName) {
    fbb_.AddOffset(DimensionDataMessage::VT_FONTNAME, FontName);
  }
  void add_FontSize(double FontSize) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_FONTSIZE, FontSize, 0.0);
  }
  void add_FontGap(int32_t FontGap) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FONTGAP, FontGap, 0);
  }
  void add_FontColor(int32_t FontColor) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FONTCOLOR, FontColor, 0);
  }
  void add_IsItalic(int32_t IsItalic) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISITALIC, IsItalic, 0);
  }
  void add_IsBold(int32_t IsBold) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISBOLD, IsBold, 0);
  }
  void add_IsUnderLine(int32_t IsUnderLine) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISUNDERLINE, IsUnderLine, 0);
  }
  void add_LineVerSpace(int32_t LineVerSpace) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_LINEVERSPACE, LineVerSpace, 0);
  }
  void add_IsAllSurfaces(int32_t IsAllSurfaces) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISALLSURFACES, IsAllSurfaces, 0);
  }
  void add_Angle(double Angle) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_ANGLE, Angle, 0.0);
  }
  void add_DatumType(int32_t DatumType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DATUMTYPE, DatumType, 0);
  }
  void add_DatumTargetType(int32_t DatumTargetType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DATUMTARGETTYPE, DatumTargetType, 0);
  }
  void add_DimTextPos(int32_t DimTextPos) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMTEXTPOS, DimTextPos, 0);
  }
  void add_ArrowPos(int32_t ArrowPos) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ARROWPOS, ArrowPos, 0);
  }
  void add_TolType(int32_t TolType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_TOLTYPE, TolType, 0);
  }
  void add_ValPrecision(int32_t ValPrecision) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_VALPRECISION, ValPrecision, 0);
  }
  void add_TolPrecision(int32_t TolPrecision) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_TOLPRECISION, TolPrecision, 0);
  }
  void add_IsReference(int32_t IsReference) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISREFERENCE, IsReference, 0);
  }
  void add_DetailLabelFlag(int32_t DetailLabelFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DETAILLABELFLAG, DetailLabelFlag, 0);
  }
  void add_SeperateFlag(int32_t SeperateFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_SEPERATEFLAG, SeperateFlag, 0);
  }
  void add_ViewIndex(flatbuffers::Offset<flatbuffers::String> ViewIndex) {
    fbb_.AddOffset(DimensionDataMessage::VT_VIEWINDEX, ViewIndex);
  }
  void add_RowIndex(int32_t RowIndex) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ROWINDEX, RowIndex, 0);
  }
  void add_ColIndex(int32_t ColIndex) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_COLINDEX, ColIndex, 0);
  }
  void add_AttributeDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AttributeDataValue>>> AttributeDatas) {
    fbb_.AddOffset(DimensionDataMessage::VT_ATTRIBUTEDATAS, AttributeDatas);
  }
  void add_TextDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>>> TextDatas) {
    fbb_.AddOffset(DimensionDataMessage::VT_TEXTDATAS, TextDatas);
  }
  void add_IsDocFont(int32_t IsDocFont) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISDOCFONT, IsDocFont, 0);
  }
  void add_IsManual(int32_t IsManual) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISMANUAL, IsManual, 0);
  }
  void add_ManualValue(flatbuffers::Offset<flatbuffers::String> ManualValue) {
    fbb_.AddOffset(DimensionDataMessage::VT_MANUALVALUE, ManualValue);
  }
  void add_FirstArcFlag(int32_t FirstArcFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FIRSTARCFLAG, FirstArcFlag, 0);
  }
  void add_SecondArcFlag(int32_t SecondArcFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_SECONDARCFLAG, SecondArcFlag, 0);
  }
  void add_RadiusOrDiameter(int32_t RadiusOrDiameter) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_RADIUSORDIAMETER, RadiusOrDiameter, 0);
  }
  void add_IsThreadDim(int32_t IsThreadDim) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISTHREADDIM, IsThreadDim, 0);
  }
  void add_DimMode(int32_t DimMode) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMMODE, DimMode, 0);
  }
  void add_RelationType(int32_t RelationType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_RELATIONTYPE, RelationType, 0);
  }
  void add_OriginId(int32_t OriginId) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ORIGINID, OriginId, 0);
  }
  void add_FirstGeomId(int32_t FirstGeomId) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FIRSTGEOMID, FirstGeomId, 0);
  }
  void add_FirstGeomPnt(flatbuffers::Offset<flatbuffers::Vector<double>> FirstGeomPnt) {
    fbb_.AddOffset(DimensionDataMessage::VT_FIRSTGEOMPNT, FirstGeomPnt);
  }
  void add_IsAlignDimChain(int32_t IsAlignDimChain) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISALIGNDIMCHAIN, IsAlignDimChain, 0);
  }
  void add_DimChainSideLineVis(int32_t DimChainSideLineVis) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMCHAINSIDELINEVIS, DimChainSideLineVis, 0);
  }
  void add_DimChainSideLineJog(int32_t DimChainSideLineJog) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMCHAINSIDELINEJOG, DimChainSideLineJog, 0);
  }
  void add_ReferenceAndInspection1(int32_t ReferenceAndInspection1) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_REFERENCEANDINSPECTION1, ReferenceAndInspection1, 0);
  }
  void add_ReferenceAndInspection2(int32_t ReferenceAndInspection2) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_REFERENCEANDINSPECTION2, ReferenceAndInspection2, 0);
  }
  void add_FitTolCategory(int32_t FitTolCategory) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FITTOLCATEGORY, FitTolCategory, 0);
  }
  void add_FitTolShowType(int32_t FitTolShowType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FITTOLSHOWTYPE, FitTolShowType, 0);
  }
  void add_AutoCalcTolVariable(int32_t AutoCalcTolVariable) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_AUTOCALCTOLVARIABLE, AutoCalcTolVariable, 0);
  }
  void add_ArcDimStyle(int32_t ArcDimStyle) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ARCDIMSTYLE, ArcDimStyle, 0);
  }
  void add_ArcLeadStyle(int32_t ArcLeadStyle) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ARCLEADSTYLE, ArcLeadStyle, 0);
  }
  void add_UseDocArcLeadStyle(int32_t UseDocArcLeadStyle) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_USEDOCARCLEADSTYLE, UseDocArcLeadStyle, 0);
  }
  void add_OriginIndex(int32_t OriginIndex) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ORIGININDEX, OriginIndex, 0);
  }
  void add_IsCustomFont(int32_t IsCustomFont) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISCUSTOMFONT, IsCustomFont, 0);
  }
  void add_DIndex(flatbuffers::Offset<flatbuffers::String> DIndex) {
    fbb_.AddOffset(DimensionDataMessage::VT_DINDEX, DIndex);
  }
  void add_DiameterSymbolFlag(int32_t DiameterSymbolFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIAMETERSYMBOLFLAG, DiameterSymbolFlag, 0);
  }
  void add_BrokenLineMode(int32_t BrokenLineMode) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_BROKENLINEMODE, BrokenLineMode, 0);
  }
  void add_BrokenPnts(flatbuffers::Offset<flatbuffers::Vector<double>> BrokenPnts) {
    fbb_.AddOffset(DimensionDataMessage::VT_BROKENPNTS, BrokenPnts);
  }
  void add_DimChainType(int32_t DimChainType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMCHAINTYPE, DimChainType, 0);
  }
  void add_DimChainOriginID(int32_t DimChainOriginID) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIMCHAINORIGINID, DimChainOriginID, 0);
  }
  void add_ChamferData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ChamferDataElement>>> ChamferData) {
    fbb_.AddOffset(DimensionDataMessage::VT_CHAMFERDATA, ChamferData);
  }
  void add_TolType2(int32_t TolType2) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_TOLTYPE2, TolType2, 0);
  }
  void add_TolPrecision2(int32_t TolPrecision2) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_TOLPRECISION2, TolPrecision2, 0);
  }
  void add_ToleranceVal3(double ToleranceVal3) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_TOLERANCEVAL3, ToleranceVal3, 0.0);
  }
  void add_ToleranceVal4(double ToleranceVal4) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_TOLERANCEVAL4, ToleranceVal4, 0.0);
  }
  void add_ArcLenBoundType(int32_t ArcLenBoundType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ARCLENBOUNDTYPE, ArcLenBoundType, 0);
  }
  void add_ArcLenSymbolPos(int32_t ArcLenSymbolPos) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ARCLENSYMBOLPOS, ArcLenSymbolPos, 0);
  }
  void add_IsBendLineLabel(int32_t IsBendLineLabel) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ISBENDLINELABEL, IsBendLineLabel, 0);
  }
  void add_DisplayBendTextContent(flatbuffers::Offset<flatbuffers::String> DisplayBendTextContent) {
    fbb_.AddOffset(DimensionDataMessage::VT_DISPLAYBENDTEXTCONTENT, DisplayBendTextContent);
  }
  void add_RichTextInfo(flatbuffers::Offset<flatbuffers::String> RichTextInfo) {
    fbb_.AddOffset(DimensionDataMessage::VT_RICHTEXTINFO, RichTextInfo);
  }
  void add_BottomText(flatbuffers::Offset<flatbuffers::String> BottomText) {
    fbb_.AddOffset(DimensionDataMessage::VT_BOTTOMTEXT, BottomText);
  }
  void add_BalloonTextType(flatbuffers::Offset<flatbuffers::String> BalloonTextType) {
    fbb_.AddOffset(DimensionDataMessage::VT_BALLOONTEXTTYPE, BalloonTextType);
  }
  void add_BottomTextType(flatbuffers::Offset<flatbuffers::String> BottomTextType) {
    fbb_.AddOffset(DimensionDataMessage::VT_BOTTOMTEXTTYPE, BottomTextType);
  }
  void add_PartQuantity(flatbuffers::Offset<flatbuffers::String> PartQuantity) {
    fbb_.AddOffset(DimensionDataMessage::VT_PARTQUANTITY, PartQuantity);
  }
  void add_DenotationText(flatbuffers::Offset<flatbuffers::String> DenotationText) {
    fbb_.AddOffset(DimensionDataMessage::VT_DENOTATIONTEXT, DenotationText);
  }
  void add_ShowQuantity(int32_t ShowQuantity) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_SHOWQUANTITY, ShowQuantity, 0);
  }
  void add_UseCustomQuantity(int32_t UseCustomQuantity) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_USECUSTOMQUANTITY, UseCustomQuantity, 0);
  }
  void add_DenotationType(int32_t DenotationType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DENOTATIONTYPE, DenotationType, 0);
  }
  void add_DenotationPlacement(int32_t DenotationPlacement) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DENOTATIONPLACEMENT, DenotationPlacement, 0);
  }
  void add_DenotationDistance(double DenotationDistance) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_DENOTATIONDISTANCE, DenotationDistance, 0.0);
  }
  void add_FrameSizeType(int32_t FrameSizeType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FRAMESIZETYPE, FrameSizeType, 0);
  }
  void add_FrameSize(float FrameSize) {
    fbb_.AddElement<float>(DimensionDataMessage::VT_FRAMESIZE, FrameSize, 0.0f);
  }
  void add_HoleData(flatbuffers::Offset<FlatBufferDocSpace::HoleDataElement> HoleData) {
    fbb_.AddOffset(DimensionDataMessage::VT_HOLEDATA, HoleData);
  }
  void add_RevisionId(flatbuffers::Offset<flatbuffers::String> RevisionId) {
    fbb_.AddOffset(DimensionDataMessage::VT_REVISIONID, RevisionId);
  }
  void add_CloudMode(int32_t CloudMode) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_CLOUDMODE, CloudMode, 0);
  }
  void add_CloudMaxRadius(double CloudMaxRadius) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_CLOUDMAXRADIUS, CloudMaxRadius, 0.0);
  }
  void add_CloudPoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CloudPointData>>> CloudPoints) {
    fbb_.AddOffset(DimensionDataMessage::VT_CLOUDPOINTS, CloudPoints);
  }
  void add_FlatAngle(double FlatAngle) {
    fbb_.AddElement<double>(DimensionDataMessage::VT_FLATANGLE, FlatAngle, 0.0);
  }
  void add_TxtAlignMode(int32_t TxtAlignMode) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_TXTALIGNMODE, TxtAlignMode, 0);
  }
  void add_StackedIndex(flatbuffers::Offset<flatbuffers::String> StackedIndex) {
    fbb_.AddOffset(DimensionDataMessage::VT_STACKEDINDEX, StackedIndex);
  }
  void add_BalloonPreLine(int32_t BalloonPreLine) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_BALLOONPRELINE, BalloonPreLine, 0);
  }
  void add_StackType(int32_t StackType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_STACKTYPE, StackType, 0);
  }
  void add_StackIndex(int32_t StackIndex) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_STACKINDEX, StackIndex, 0);
  }
  void add_FixedFaceFlag(int32_t FixedFaceFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_FIXEDFACEFLAG, FixedFaceFlag, 0);
  }
  void add_HoleTagFlag(int32_t HoleTagFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_HOLETAGFLAG, HoleTagFlag, 0);
  }
  void add_HoleTableAxisData(flatbuffers::Offset<FlatBufferDocSpace::HoleTableAxis> HoleTableAxisData) {
    fbb_.AddOffset(DimensionDataMessage::VT_HOLETABLEAXISDATA, HoleTableAxisData);
  }
  void add_HoleSize(flatbuffers::Offset<FlatBufferDocSpace::HoleSizeData> HoleSize) {
    fbb_.AddOffset(DimensionDataMessage::VT_HOLESIZE, HoleSize);
  }
  void add_HolePos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HolePosData>>> HolePos) {
    fbb_.AddOffset(DimensionDataMessage::VT_HOLEPOS, HolePos);
  }
  void add_DirectionType(int32_t DirectionType) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_DIRECTIONTYPE, DirectionType, 0);
  }
  void add_LeaderLineTreeData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LeaderTreeData>>> LeaderLineTreeData) {
    fbb_.AddOffset(DimensionDataMessage::VT_LEADERLINETREEDATA, LeaderLineTreeData);
  }
  void add_ProjModeFlag(int32_t ProjModeFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_PROJMODEFLAG, ProjModeFlag, 0);
  }
  void add_AutoAdjustBoundaryPnt(int32_t AutoAdjustBoundaryPnt) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_AUTOADJUSTBOUNDARYPNT, AutoAdjustBoundaryPnt, 0);
  }
  void add_RotateViewFlag(int32_t RotateViewFlag) {
    fbb_.AddElement<int32_t>(DimensionDataMessage::VT_ROTATEVIEWFLAG, RotateViewFlag, 0);
  }
  void add_OrdinateDimLeaderPnts(flatbuffers::Offset<flatbuffers::Vector<double>> OrdinateDimLeaderPnts) {
    fbb_.AddOffset(DimensionDataMessage::VT_ORDINATEDIMLEADERPNTS, OrdinateDimLeaderPnts);
  }
  explicit DimensionDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionDataMessageBuilder &operator=(const DimensionDataMessageBuilder &);
  flatbuffers::Offset<DimensionDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionDataMessage> CreateDimensionDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::String> Value = 0,
    flatbuffers::Offset<flatbuffers::String> Text = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Direction = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Position = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> RefPlane = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> GeomPnts = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GeometriesData>>> Geometries = 0,
    int32_t Status = 0,
    double StartAngle = 0.0,
    double EndAngle = 0.0,
    flatbuffers::Offset<flatbuffers::String> ParamName = 0,
    int32_t ParamIndex = 0,
    flatbuffers::Offset<flatbuffers::String> FeatureIndex = 0,
    int32_t DimStatus = 0,
    int32_t RelView = 0,
    int32_t LeadType = 0,
    int32_t RightArrowType = 0,
    int32_t LeftArrowType = 0,
    int32_t DimLineType = 0,
    int32_t DimLineWidth = 0,
    int32_t DimColor = 0,
    int32_t FrameType = 0,
    int32_t FrameLineType = 0,
    int32_t FrameLineWidth = 0,
    flatbuffers::Offset<flatbuffers::String> FontName = 0,
    double FontSize = 0.0,
    int32_t FontGap = 0,
    int32_t FontColor = 0,
    int32_t IsItalic = 0,
    int32_t IsBold = 0,
    int32_t IsUnderLine = 0,
    int32_t LineVerSpace = 0,
    int32_t IsAllSurfaces = 0,
    double Angle = 0.0,
    int32_t DatumType = 0,
    int32_t DatumTargetType = 0,
    int32_t DimTextPos = 0,
    int32_t ArrowPos = 0,
    int32_t TolType = 0,
    int32_t ValPrecision = 0,
    int32_t TolPrecision = 0,
    int32_t IsReference = 0,
    int32_t DetailLabelFlag = 0,
    int32_t SeperateFlag = 0,
    flatbuffers::Offset<flatbuffers::String> ViewIndex = 0,
    int32_t RowIndex = 0,
    int32_t ColIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AttributeDataValue>>> AttributeDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>>> TextDatas = 0,
    int32_t IsDocFont = 0,
    int32_t IsManual = 0,
    flatbuffers::Offset<flatbuffers::String> ManualValue = 0,
    int32_t FirstArcFlag = 0,
    int32_t SecondArcFlag = 0,
    int32_t RadiusOrDiameter = 0,
    int32_t IsThreadDim = 0,
    int32_t DimMode = 0,
    int32_t RelationType = 0,
    int32_t OriginId = 0,
    int32_t FirstGeomId = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> FirstGeomPnt = 0,
    int32_t IsAlignDimChain = 0,
    int32_t DimChainSideLineVis = 0,
    int32_t DimChainSideLineJog = 0,
    int32_t ReferenceAndInspection1 = 0,
    int32_t ReferenceAndInspection2 = 0,
    int32_t FitTolCategory = 0,
    int32_t FitTolShowType = 0,
    int32_t AutoCalcTolVariable = 0,
    int32_t ArcDimStyle = 0,
    int32_t ArcLeadStyle = 0,
    int32_t UseDocArcLeadStyle = 0,
    int32_t OriginIndex = 0,
    int32_t IsCustomFont = 0,
    flatbuffers::Offset<flatbuffers::String> DIndex = 0,
    int32_t DiameterSymbolFlag = 0,
    int32_t BrokenLineMode = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> BrokenPnts = 0,
    int32_t DimChainType = 0,
    int32_t DimChainOriginID = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ChamferDataElement>>> ChamferData = 0,
    int32_t TolType2 = 0,
    int32_t TolPrecision2 = 0,
    double ToleranceVal3 = 0.0,
    double ToleranceVal4 = 0.0,
    int32_t ArcLenBoundType = 0,
    int32_t ArcLenSymbolPos = 0,
    int32_t IsBendLineLabel = 0,
    flatbuffers::Offset<flatbuffers::String> DisplayBendTextContent = 0,
    flatbuffers::Offset<flatbuffers::String> RichTextInfo = 0,
    flatbuffers::Offset<flatbuffers::String> BottomText = 0,
    flatbuffers::Offset<flatbuffers::String> BalloonTextType = 0,
    flatbuffers::Offset<flatbuffers::String> BottomTextType = 0,
    flatbuffers::Offset<flatbuffers::String> PartQuantity = 0,
    flatbuffers::Offset<flatbuffers::String> DenotationText = 0,
    int32_t ShowQuantity = 0,
    int32_t UseCustomQuantity = 0,
    int32_t DenotationType = 0,
    int32_t DenotationPlacement = 0,
    double DenotationDistance = 0.0,
    int32_t FrameSizeType = 0,
    float FrameSize = 0.0f,
    flatbuffers::Offset<FlatBufferDocSpace::HoleDataElement> HoleData = 0,
    flatbuffers::Offset<flatbuffers::String> RevisionId = 0,
    int32_t CloudMode = 0,
    double CloudMaxRadius = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CloudPointData>>> CloudPoints = 0,
    double FlatAngle = 0.0,
    int32_t TxtAlignMode = 0,
    flatbuffers::Offset<flatbuffers::String> StackedIndex = 0,
    int32_t BalloonPreLine = 0,
    int32_t StackType = 0,
    int32_t StackIndex = 0,
    int32_t FixedFaceFlag = 0,
    int32_t HoleTagFlag = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HoleTableAxis> HoleTableAxisData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HoleSizeData> HoleSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HolePosData>>> HolePos = 0,
    int32_t DirectionType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LeaderTreeData>>> LeaderLineTreeData = 0,
    int32_t ProjModeFlag = 0,
    int32_t AutoAdjustBoundaryPnt = 0,
    int32_t RotateViewFlag = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> OrdinateDimLeaderPnts = 0) {
  DimensionDataMessageBuilder builder_(_fbb);
  builder_.add_FlatAngle(FlatAngle);
  builder_.add_CloudMaxRadius(CloudMaxRadius);
  builder_.add_DenotationDistance(DenotationDistance);
  builder_.add_ToleranceVal4(ToleranceVal4);
  builder_.add_ToleranceVal3(ToleranceVal3);
  builder_.add_Angle(Angle);
  builder_.add_FontSize(FontSize);
  builder_.add_EndAngle(EndAngle);
  builder_.add_StartAngle(StartAngle);
  builder_.add_OrdinateDimLeaderPnts(OrdinateDimLeaderPnts);
  builder_.add_RotateViewFlag(RotateViewFlag);
  builder_.add_AutoAdjustBoundaryPnt(AutoAdjustBoundaryPnt);
  builder_.add_ProjModeFlag(ProjModeFlag);
  builder_.add_LeaderLineTreeData(LeaderLineTreeData);
  builder_.add_DirectionType(DirectionType);
  builder_.add_HolePos(HolePos);
  builder_.add_HoleSize(HoleSize);
  builder_.add_HoleTableAxisData(HoleTableAxisData);
  builder_.add_HoleTagFlag(HoleTagFlag);
  builder_.add_FixedFaceFlag(FixedFaceFlag);
  builder_.add_StackIndex(StackIndex);
  builder_.add_StackType(StackType);
  builder_.add_BalloonPreLine(BalloonPreLine);
  builder_.add_StackedIndex(StackedIndex);
  builder_.add_TxtAlignMode(TxtAlignMode);
  builder_.add_CloudPoints(CloudPoints);
  builder_.add_CloudMode(CloudMode);
  builder_.add_RevisionId(RevisionId);
  builder_.add_HoleData(HoleData);
  builder_.add_FrameSize(FrameSize);
  builder_.add_FrameSizeType(FrameSizeType);
  builder_.add_DenotationPlacement(DenotationPlacement);
  builder_.add_DenotationType(DenotationType);
  builder_.add_UseCustomQuantity(UseCustomQuantity);
  builder_.add_ShowQuantity(ShowQuantity);
  builder_.add_DenotationText(DenotationText);
  builder_.add_PartQuantity(PartQuantity);
  builder_.add_BottomTextType(BottomTextType);
  builder_.add_BalloonTextType(BalloonTextType);
  builder_.add_BottomText(BottomText);
  builder_.add_RichTextInfo(RichTextInfo);
  builder_.add_DisplayBendTextContent(DisplayBendTextContent);
  builder_.add_IsBendLineLabel(IsBendLineLabel);
  builder_.add_ArcLenSymbolPos(ArcLenSymbolPos);
  builder_.add_ArcLenBoundType(ArcLenBoundType);
  builder_.add_TolPrecision2(TolPrecision2);
  builder_.add_TolType2(TolType2);
  builder_.add_ChamferData(ChamferData);
  builder_.add_DimChainOriginID(DimChainOriginID);
  builder_.add_DimChainType(DimChainType);
  builder_.add_BrokenPnts(BrokenPnts);
  builder_.add_BrokenLineMode(BrokenLineMode);
  builder_.add_DiameterSymbolFlag(DiameterSymbolFlag);
  builder_.add_DIndex(DIndex);
  builder_.add_IsCustomFont(IsCustomFont);
  builder_.add_OriginIndex(OriginIndex);
  builder_.add_UseDocArcLeadStyle(UseDocArcLeadStyle);
  builder_.add_ArcLeadStyle(ArcLeadStyle);
  builder_.add_ArcDimStyle(ArcDimStyle);
  builder_.add_AutoCalcTolVariable(AutoCalcTolVariable);
  builder_.add_FitTolShowType(FitTolShowType);
  builder_.add_FitTolCategory(FitTolCategory);
  builder_.add_ReferenceAndInspection2(ReferenceAndInspection2);
  builder_.add_ReferenceAndInspection1(ReferenceAndInspection1);
  builder_.add_DimChainSideLineJog(DimChainSideLineJog);
  builder_.add_DimChainSideLineVis(DimChainSideLineVis);
  builder_.add_IsAlignDimChain(IsAlignDimChain);
  builder_.add_FirstGeomPnt(FirstGeomPnt);
  builder_.add_FirstGeomId(FirstGeomId);
  builder_.add_OriginId(OriginId);
  builder_.add_RelationType(RelationType);
  builder_.add_DimMode(DimMode);
  builder_.add_IsThreadDim(IsThreadDim);
  builder_.add_RadiusOrDiameter(RadiusOrDiameter);
  builder_.add_SecondArcFlag(SecondArcFlag);
  builder_.add_FirstArcFlag(FirstArcFlag);
  builder_.add_ManualValue(ManualValue);
  builder_.add_IsManual(IsManual);
  builder_.add_IsDocFont(IsDocFont);
  builder_.add_TextDatas(TextDatas);
  builder_.add_AttributeDatas(AttributeDatas);
  builder_.add_ColIndex(ColIndex);
  builder_.add_RowIndex(RowIndex);
  builder_.add_ViewIndex(ViewIndex);
  builder_.add_SeperateFlag(SeperateFlag);
  builder_.add_DetailLabelFlag(DetailLabelFlag);
  builder_.add_IsReference(IsReference);
  builder_.add_TolPrecision(TolPrecision);
  builder_.add_ValPrecision(ValPrecision);
  builder_.add_TolType(TolType);
  builder_.add_ArrowPos(ArrowPos);
  builder_.add_DimTextPos(DimTextPos);
  builder_.add_DatumTargetType(DatumTargetType);
  builder_.add_DatumType(DatumType);
  builder_.add_IsAllSurfaces(IsAllSurfaces);
  builder_.add_LineVerSpace(LineVerSpace);
  builder_.add_IsUnderLine(IsUnderLine);
  builder_.add_IsBold(IsBold);
  builder_.add_IsItalic(IsItalic);
  builder_.add_FontColor(FontColor);
  builder_.add_FontGap(FontGap);
  builder_.add_FontName(FontName);
  builder_.add_FrameLineWidth(FrameLineWidth);
  builder_.add_FrameLineType(FrameLineType);
  builder_.add_FrameType(FrameType);
  builder_.add_DimColor(DimColor);
  builder_.add_DimLineWidth(DimLineWidth);
  builder_.add_DimLineType(DimLineType);
  builder_.add_LeftArrowType(LeftArrowType);
  builder_.add_RightArrowType(RightArrowType);
  builder_.add_LeadType(LeadType);
  builder_.add_RelView(RelView);
  builder_.add_DimStatus(DimStatus);
  builder_.add_FeatureIndex(FeatureIndex);
  builder_.add_ParamIndex(ParamIndex);
  builder_.add_ParamName(ParamName);
  builder_.add_Status(Status);
  builder_.add_Geometries(Geometries);
  builder_.add_CenterPnt(CenterPnt);
  builder_.add_GeomPnts(GeomPnts);
  builder_.add_RefPlane(RefPlane);
  builder_.add_Position(Position);
  builder_.add_Direction(Direction);
  builder_.add_DimVariable(DimVariable);
  builder_.add_Text(Text);
  builder_.add_Value(Value);
  builder_.add_Type(Type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DimensionDataMessage> CreateDimensionDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Type = nullptr,
    const char *Value = nullptr,
    const char *Text = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable = 0,
    const std::vector<double> *Direction = nullptr,
    const std::vector<double> *Position = nullptr,
    const std::vector<double> *RefPlane = nullptr,
    const std::vector<double> *GeomPnts = nullptr,
    const std::vector<double> *CenterPnt = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::GeometriesData>> *Geometries = nullptr,
    int32_t Status = 0,
    double StartAngle = 0.0,
    double EndAngle = 0.0,
    const char *ParamName = nullptr,
    int32_t ParamIndex = 0,
    const char *FeatureIndex = nullptr,
    int32_t DimStatus = 0,
    int32_t RelView = 0,
    int32_t LeadType = 0,
    int32_t RightArrowType = 0,
    int32_t LeftArrowType = 0,
    int32_t DimLineType = 0,
    int32_t DimLineWidth = 0,
    int32_t DimColor = 0,
    int32_t FrameType = 0,
    int32_t FrameLineType = 0,
    int32_t FrameLineWidth = 0,
    const char *FontName = nullptr,
    double FontSize = 0.0,
    int32_t FontGap = 0,
    int32_t FontColor = 0,
    int32_t IsItalic = 0,
    int32_t IsBold = 0,
    int32_t IsUnderLine = 0,
    int32_t LineVerSpace = 0,
    int32_t IsAllSurfaces = 0,
    double Angle = 0.0,
    int32_t DatumType = 0,
    int32_t DatumTargetType = 0,
    int32_t DimTextPos = 0,
    int32_t ArrowPos = 0,
    int32_t TolType = 0,
    int32_t ValPrecision = 0,
    int32_t TolPrecision = 0,
    int32_t IsReference = 0,
    int32_t DetailLabelFlag = 0,
    int32_t SeperateFlag = 0,
    const char *ViewIndex = nullptr,
    int32_t RowIndex = 0,
    int32_t ColIndex = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AttributeDataValue>> *AttributeDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>> *TextDatas = nullptr,
    int32_t IsDocFont = 0,
    int32_t IsManual = 0,
    const char *ManualValue = nullptr,
    int32_t FirstArcFlag = 0,
    int32_t SecondArcFlag = 0,
    int32_t RadiusOrDiameter = 0,
    int32_t IsThreadDim = 0,
    int32_t DimMode = 0,
    int32_t RelationType = 0,
    int32_t OriginId = 0,
    int32_t FirstGeomId = 0,
    const std::vector<double> *FirstGeomPnt = nullptr,
    int32_t IsAlignDimChain = 0,
    int32_t DimChainSideLineVis = 0,
    int32_t DimChainSideLineJog = 0,
    int32_t ReferenceAndInspection1 = 0,
    int32_t ReferenceAndInspection2 = 0,
    int32_t FitTolCategory = 0,
    int32_t FitTolShowType = 0,
    int32_t AutoCalcTolVariable = 0,
    int32_t ArcDimStyle = 0,
    int32_t ArcLeadStyle = 0,
    int32_t UseDocArcLeadStyle = 0,
    int32_t OriginIndex = 0,
    int32_t IsCustomFont = 0,
    const char *DIndex = nullptr,
    int32_t DiameterSymbolFlag = 0,
    int32_t BrokenLineMode = 0,
    const std::vector<double> *BrokenPnts = nullptr,
    int32_t DimChainType = 0,
    int32_t DimChainOriginID = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ChamferDataElement>> *ChamferData = nullptr,
    int32_t TolType2 = 0,
    int32_t TolPrecision2 = 0,
    double ToleranceVal3 = 0.0,
    double ToleranceVal4 = 0.0,
    int32_t ArcLenBoundType = 0,
    int32_t ArcLenSymbolPos = 0,
    int32_t IsBendLineLabel = 0,
    const char *DisplayBendTextContent = nullptr,
    const char *RichTextInfo = nullptr,
    const char *BottomText = nullptr,
    const char *BalloonTextType = nullptr,
    const char *BottomTextType = nullptr,
    const char *PartQuantity = nullptr,
    const char *DenotationText = nullptr,
    int32_t ShowQuantity = 0,
    int32_t UseCustomQuantity = 0,
    int32_t DenotationType = 0,
    int32_t DenotationPlacement = 0,
    double DenotationDistance = 0.0,
    int32_t FrameSizeType = 0,
    float FrameSize = 0.0f,
    flatbuffers::Offset<FlatBufferDocSpace::HoleDataElement> HoleData = 0,
    const char *RevisionId = nullptr,
    int32_t CloudMode = 0,
    double CloudMaxRadius = 0.0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CloudPointData>> *CloudPoints = nullptr,
    double FlatAngle = 0.0,
    int32_t TxtAlignMode = 0,
    const char *StackedIndex = nullptr,
    int32_t BalloonPreLine = 0,
    int32_t StackType = 0,
    int32_t StackIndex = 0,
    int32_t FixedFaceFlag = 0,
    int32_t HoleTagFlag = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HoleTableAxis> HoleTableAxisData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HoleSizeData> HoleSize = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HolePosData>> *HolePos = nullptr,
    int32_t DirectionType = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::LeaderTreeData>> *LeaderLineTreeData = nullptr,
    int32_t ProjModeFlag = 0,
    int32_t AutoAdjustBoundaryPnt = 0,
    int32_t RotateViewFlag = 0,
    const std::vector<double> *OrdinateDimLeaderPnts = nullptr) {
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  auto Text__ = Text ? _fbb.CreateString(Text) : 0;
  auto Direction__ = Direction ? _fbb.CreateVector<double>(*Direction) : 0;
  auto Position__ = Position ? _fbb.CreateVector<double>(*Position) : 0;
  auto RefPlane__ = RefPlane ? _fbb.CreateVector<double>(*RefPlane) : 0;
  auto GeomPnts__ = GeomPnts ? _fbb.CreateVector<double>(*GeomPnts) : 0;
  auto CenterPnt__ = CenterPnt ? _fbb.CreateVector<double>(*CenterPnt) : 0;
  auto Geometries__ = Geometries ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::GeometriesData>>(*Geometries) : 0;
  auto ParamName__ = ParamName ? _fbb.CreateString(ParamName) : 0;
  auto FeatureIndex__ = FeatureIndex ? _fbb.CreateString(FeatureIndex) : 0;
  auto FontName__ = FontName ? _fbb.CreateString(FontName) : 0;
  auto ViewIndex__ = ViewIndex ? _fbb.CreateString(ViewIndex) : 0;
  auto AttributeDatas__ = AttributeDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AttributeDataValue>>(*AttributeDatas) : 0;
  auto TextDatas__ = TextDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TextData>>(*TextDatas) : 0;
  auto ManualValue__ = ManualValue ? _fbb.CreateString(ManualValue) : 0;
  auto FirstGeomPnt__ = FirstGeomPnt ? _fbb.CreateVector<double>(*FirstGeomPnt) : 0;
  auto DIndex__ = DIndex ? _fbb.CreateString(DIndex) : 0;
  auto BrokenPnts__ = BrokenPnts ? _fbb.CreateVector<double>(*BrokenPnts) : 0;
  auto ChamferData__ = ChamferData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ChamferDataElement>>(*ChamferData) : 0;
  auto DisplayBendTextContent__ = DisplayBendTextContent ? _fbb.CreateString(DisplayBendTextContent) : 0;
  auto RichTextInfo__ = RichTextInfo ? _fbb.CreateString(RichTextInfo) : 0;
  auto BottomText__ = BottomText ? _fbb.CreateString(BottomText) : 0;
  auto BalloonTextType__ = BalloonTextType ? _fbb.CreateString(BalloonTextType) : 0;
  auto BottomTextType__ = BottomTextType ? _fbb.CreateString(BottomTextType) : 0;
  auto PartQuantity__ = PartQuantity ? _fbb.CreateString(PartQuantity) : 0;
  auto DenotationText__ = DenotationText ? _fbb.CreateString(DenotationText) : 0;
  auto RevisionId__ = RevisionId ? _fbb.CreateString(RevisionId) : 0;
  auto CloudPoints__ = CloudPoints ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CloudPointData>>(*CloudPoints) : 0;
  auto StackedIndex__ = StackedIndex ? _fbb.CreateString(StackedIndex) : 0;
  auto HolePos__ = HolePos ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HolePosData>>(*HolePos) : 0;
  auto LeaderLineTreeData__ = LeaderLineTreeData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::LeaderTreeData>>(*LeaderLineTreeData) : 0;
  auto OrdinateDimLeaderPnts__ = OrdinateDimLeaderPnts ? _fbb.CreateVector<double>(*OrdinateDimLeaderPnts) : 0;
  return FlatBufferDocSpace::CreateDimensionDataMessage(
      _fbb,
      Type__,
      Value__,
      Text__,
      DimVariable,
      Direction__,
      Position__,
      RefPlane__,
      GeomPnts__,
      CenterPnt__,
      Geometries__,
      Status,
      StartAngle,
      EndAngle,
      ParamName__,
      ParamIndex,
      FeatureIndex__,
      DimStatus,
      RelView,
      LeadType,
      RightArrowType,
      LeftArrowType,
      DimLineType,
      DimLineWidth,
      DimColor,
      FrameType,
      FrameLineType,
      FrameLineWidth,
      FontName__,
      FontSize,
      FontGap,
      FontColor,
      IsItalic,
      IsBold,
      IsUnderLine,
      LineVerSpace,
      IsAllSurfaces,
      Angle,
      DatumType,
      DatumTargetType,
      DimTextPos,
      ArrowPos,
      TolType,
      ValPrecision,
      TolPrecision,
      IsReference,
      DetailLabelFlag,
      SeperateFlag,
      ViewIndex__,
      RowIndex,
      ColIndex,
      AttributeDatas__,
      TextDatas__,
      IsDocFont,
      IsManual,
      ManualValue__,
      FirstArcFlag,
      SecondArcFlag,
      RadiusOrDiameter,
      IsThreadDim,
      DimMode,
      RelationType,
      OriginId,
      FirstGeomId,
      FirstGeomPnt__,
      IsAlignDimChain,
      DimChainSideLineVis,
      DimChainSideLineJog,
      ReferenceAndInspection1,
      ReferenceAndInspection2,
      FitTolCategory,
      FitTolShowType,
      AutoCalcTolVariable,
      ArcDimStyle,
      ArcLeadStyle,
      UseDocArcLeadStyle,
      OriginIndex,
      IsCustomFont,
      DIndex__,
      DiameterSymbolFlag,
      BrokenLineMode,
      BrokenPnts__,
      DimChainType,
      DimChainOriginID,
      ChamferData__,
      TolType2,
      TolPrecision2,
      ToleranceVal3,
      ToleranceVal4,
      ArcLenBoundType,
      ArcLenSymbolPos,
      IsBendLineLabel,
      DisplayBendTextContent__,
      RichTextInfo__,
      BottomText__,
      BalloonTextType__,
      BottomTextType__,
      PartQuantity__,
      DenotationText__,
      ShowQuantity,
      UseCustomQuantity,
      DenotationType,
      DenotationPlacement,
      DenotationDistance,
      FrameSizeType,
      FrameSize,
      HoleData,
      RevisionId__,
      CloudMode,
      CloudMaxRadius,
      CloudPoints__,
      FlatAngle,
      TxtAlignMode,
      StackedIndex__,
      BalloonPreLine,
      StackType,
      StackIndex,
      FixedFaceFlag,
      HoleTagFlag,
      HoleTableAxisData,
      HoleSize,
      HolePos__,
      DirectionType,
      LeaderLineTreeData__,
      ProjModeFlag,
      AutoAdjustBoundaryPnt,
      RotateViewFlag,
      OrdinateDimLeaderPnts__);
}

struct SketchPreviewData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SketchPreviewDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREVIEWDATA = 4,
    VT_TOPODATA = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *PreviewData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_PREVIEWDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *>(VT_TOPODATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PREVIEWDATA) &&
           verifier.VerifyVector(PreviewData()) &&
           verifier.VerifyVectorOfTables(PreviewData()) &&
           VerifyOffset(verifier, VT_TOPODATA) &&
           verifier.VerifyVector(TopoData()) &&
           verifier.VerifyVectorOfTables(TopoData()) &&
           verifier.EndTable();
  }
};

struct SketchPreviewDataBuilder {
  typedef SketchPreviewData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PreviewData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> PreviewData) {
    fbb_.AddOffset(SketchPreviewData::VT_PREVIEWDATA, PreviewData);
  }
  void add_TopoData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData) {
    fbb_.AddOffset(SketchPreviewData::VT_TOPODATA, TopoData);
  }
  explicit SketchPreviewDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SketchPreviewDataBuilder &operator=(const SketchPreviewDataBuilder &);
  flatbuffers::Offset<SketchPreviewData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SketchPreviewData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SketchPreviewData> CreateSketchPreviewData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> PreviewData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData = 0) {
  SketchPreviewDataBuilder builder_(_fbb);
  builder_.add_TopoData(TopoData);
  builder_.add_PreviewData(PreviewData);
  return builder_.Finish();
}

inline flatbuffers::Offset<SketchPreviewData> CreateSketchPreviewDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *PreviewData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData = nullptr) {
  auto PreviewData__ = PreviewData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*PreviewData) : 0;
  auto TopoData__ = TopoData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>(*TopoData) : 0;
  return FlatBufferDocSpace::CreateSketchPreviewData(
      _fbb,
      PreviewData__,
      TopoData__);
}

struct GapsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GapsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GAPDIS = 4,
    VT_ID1 = 6,
    VT_SNAPTYPE1 = 8,
    VT_POINT1 = 10,
    VT_ID2 = 12,
    VT_SNAPTYPE2 = 14,
    VT_POINT2 = 16
  };
  double GapDis() const {
    return GetField<double>(VT_GAPDIS, 0.0);
  }
  int32_t ID1() const {
    return GetField<int32_t>(VT_ID1, 0);
  }
  int32_t SnapType1() const {
    return GetField<int32_t>(VT_SNAPTYPE1, 0);
  }
  const flatbuffers::Vector<double> *Point1() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINT1);
  }
  int32_t ID2() const {
    return GetField<int32_t>(VT_ID2, 0);
  }
  int32_t SnapType2() const {
    return GetField<int32_t>(VT_SNAPTYPE2, 0);
  }
  const flatbuffers::Vector<double> *Point2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINT2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_GAPDIS) &&
           VerifyField<int32_t>(verifier, VT_ID1) &&
           VerifyField<int32_t>(verifier, VT_SNAPTYPE1) &&
           VerifyOffset(verifier, VT_POINT1) &&
           verifier.VerifyVector(Point1()) &&
           VerifyField<int32_t>(verifier, VT_ID2) &&
           VerifyField<int32_t>(verifier, VT_SNAPTYPE2) &&
           VerifyOffset(verifier, VT_POINT2) &&
           verifier.VerifyVector(Point2()) &&
           verifier.EndTable();
  }
};

struct GapsDataBuilder {
  typedef GapsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GapDis(double GapDis) {
    fbb_.AddElement<double>(GapsData::VT_GAPDIS, GapDis, 0.0);
  }
  void add_ID1(int32_t ID1) {
    fbb_.AddElement<int32_t>(GapsData::VT_ID1, ID1, 0);
  }
  void add_SnapType1(int32_t SnapType1) {
    fbb_.AddElement<int32_t>(GapsData::VT_SNAPTYPE1, SnapType1, 0);
  }
  void add_Point1(flatbuffers::Offset<flatbuffers::Vector<double>> Point1) {
    fbb_.AddOffset(GapsData::VT_POINT1, Point1);
  }
  void add_ID2(int32_t ID2) {
    fbb_.AddElement<int32_t>(GapsData::VT_ID2, ID2, 0);
  }
  void add_SnapType2(int32_t SnapType2) {
    fbb_.AddElement<int32_t>(GapsData::VT_SNAPTYPE2, SnapType2, 0);
  }
  void add_Point2(flatbuffers::Offset<flatbuffers::Vector<double>> Point2) {
    fbb_.AddOffset(GapsData::VT_POINT2, Point2);
  }
  explicit GapsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GapsDataBuilder &operator=(const GapsDataBuilder &);
  flatbuffers::Offset<GapsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GapsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GapsData> CreateGapsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double GapDis = 0.0,
    int32_t ID1 = 0,
    int32_t SnapType1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Point1 = 0,
    int32_t ID2 = 0,
    int32_t SnapType2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Point2 = 0) {
  GapsDataBuilder builder_(_fbb);
  builder_.add_GapDis(GapDis);
  builder_.add_Point2(Point2);
  builder_.add_SnapType2(SnapType2);
  builder_.add_ID2(ID2);
  builder_.add_Point1(Point1);
  builder_.add_SnapType1(SnapType1);
  builder_.add_ID1(ID1);
  return builder_.Finish();
}

inline flatbuffers::Offset<GapsData> CreateGapsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double GapDis = 0.0,
    int32_t ID1 = 0,
    int32_t SnapType1 = 0,
    const std::vector<double> *Point1 = nullptr,
    int32_t ID2 = 0,
    int32_t SnapType2 = 0,
    const std::vector<double> *Point2 = nullptr) {
  auto Point1__ = Point1 ? _fbb.CreateVector<double>(*Point1) : 0;
  auto Point2__ = Point2 ? _fbb.CreateVector<double>(*Point2) : 0;
  return FlatBufferDocSpace::CreateGapsData(
      _fbb,
      GapDis,
      ID1,
      SnapType1,
      Point1__,
      ID2,
      SnapType2,
      Point2__);
}

struct OverLapsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverLapsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OVERLAP = 4
  };
  const flatbuffers::Vector<int32_t> *OverLap() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OVERLAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OVERLAP) &&
           verifier.VerifyVector(OverLap()) &&
           verifier.EndTable();
  }
};

struct OverLapsDataBuilder {
  typedef OverLapsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_OverLap(flatbuffers::Offset<flatbuffers::Vector<int32_t>> OverLap) {
    fbb_.AddOffset(OverLapsData::VT_OVERLAP, OverLap);
  }
  explicit OverLapsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OverLapsDataBuilder &operator=(const OverLapsDataBuilder &);
  flatbuffers::Offset<OverLapsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverLapsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverLapsData> CreateOverLapsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> OverLap = 0) {
  OverLapsDataBuilder builder_(_fbb);
  builder_.add_OverLap(OverLap);
  return builder_.Finish();
}

inline flatbuffers::Offset<OverLapsData> CreateOverLapsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *OverLap = nullptr) {
  auto OverLap__ = OverLap ? _fbb.CreateVector<int32_t>(*OverLap) : 0;
  return FlatBufferDocSpace::CreateOverLapsData(
      _fbb,
      OverLap__);
}

struct SketchCheckData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SketchCheckDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GAPS = 4,
    VT_OVERLAPS = 6,
    VT_SHORTCURVES = 8,
    VT_STATUS = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GapsData>> *Gaps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GapsData>> *>(VT_GAPS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::OverLapsData>> *OverLaps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::OverLapsData>> *>(VT_OVERLAPS);
  }
  const flatbuffers::Vector<int32_t> *ShortCurves() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHORTCURVES);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GAPS) &&
           verifier.VerifyVector(Gaps()) &&
           verifier.VerifyVectorOfTables(Gaps()) &&
           VerifyOffset(verifier, VT_OVERLAPS) &&
           verifier.VerifyVector(OverLaps()) &&
           verifier.VerifyVectorOfTables(OverLaps()) &&
           VerifyOffset(verifier, VT_SHORTCURVES) &&
           verifier.VerifyVector(ShortCurves()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct SketchCheckDataBuilder {
  typedef SketchCheckData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Gaps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GapsData>>> Gaps) {
    fbb_.AddOffset(SketchCheckData::VT_GAPS, Gaps);
  }
  void add_OverLaps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::OverLapsData>>> OverLaps) {
    fbb_.AddOffset(SketchCheckData::VT_OVERLAPS, OverLaps);
  }
  void add_ShortCurves(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ShortCurves) {
    fbb_.AddOffset(SketchCheckData::VT_SHORTCURVES, ShortCurves);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(SketchCheckData::VT_STATUS, Status, 0);
  }
  explicit SketchCheckDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SketchCheckDataBuilder &operator=(const SketchCheckDataBuilder &);
  flatbuffers::Offset<SketchCheckData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SketchCheckData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SketchCheckData> CreateSketchCheckData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::GapsData>>> Gaps = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::OverLapsData>>> OverLaps = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ShortCurves = 0,
    int32_t Status = 0) {
  SketchCheckDataBuilder builder_(_fbb);
  builder_.add_Status(Status);
  builder_.add_ShortCurves(ShortCurves);
  builder_.add_OverLaps(OverLaps);
  builder_.add_Gaps(Gaps);
  return builder_.Finish();
}

inline flatbuffers::Offset<SketchCheckData> CreateSketchCheckDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::GapsData>> *Gaps = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::OverLapsData>> *OverLaps = nullptr,
    const std::vector<int32_t> *ShortCurves = nullptr,
    int32_t Status = 0) {
  auto Gaps__ = Gaps ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::GapsData>>(*Gaps) : 0;
  auto OverLaps__ = OverLaps ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::OverLapsData>>(*OverLaps) : 0;
  auto ShortCurves__ = ShortCurves ? _fbb.CreateVector<int32_t>(*ShortCurves) : 0;
  return FlatBufferDocSpace::CreateSketchCheckData(
      _fbb,
      Gaps__,
      OverLaps__,
      ShortCurves__,
      Status);
}

struct DefDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DefDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_O = 4,
    VT_N = 6,
    VT_X = 8,
    VT_H = 10,
    VT_W = 12,
    VT_TOP = 14,
    VT_BOTTOM = 16,
    VT_LEFT = 18,
    VT_RIGHT = 20,
    VT_SP = 22,
    VT_EP = 24,
    VT_PNT = 26,
    VT_T = 28,
    VT_ID = 30
  };
  const flatbuffers::Vector<double> *O() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_O);
  }
  const flatbuffers::Vector<double> *N() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_N);
  }
  const flatbuffers::Vector<double> *X() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_X);
  }
  double H() const {
    return GetField<double>(VT_H, 0.0);
  }
  double W() const {
    return GetField<double>(VT_W, 0.0);
  }
  double Top() const {
    return GetField<double>(VT_TOP, 0.0);
  }
  double Bottom() const {
    return GetField<double>(VT_BOTTOM, 0.0);
  }
  double Left() const {
    return GetField<double>(VT_LEFT, 0.0);
  }
  double Right() const {
    return GetField<double>(VT_RIGHT, 0.0);
  }
  const flatbuffers::Vector<double> *SP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_SP);
  }
  const flatbuffers::Vector<double> *EP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_EP);
  }
  const flatbuffers::Vector<double> *Pnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PNT);
  }
  const flatbuffers::String *T() const {
    return GetPointer<const flatbuffers::String *>(VT_T);
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_O) &&
           verifier.VerifyVector(O()) &&
           VerifyOffset(verifier, VT_N) &&
           verifier.VerifyVector(N()) &&
           VerifyOffset(verifier, VT_X) &&
           verifier.VerifyVector(X()) &&
           VerifyField<double>(verifier, VT_H) &&
           VerifyField<double>(verifier, VT_W) &&
           VerifyField<double>(verifier, VT_TOP) &&
           VerifyField<double>(verifier, VT_BOTTOM) &&
           VerifyField<double>(verifier, VT_LEFT) &&
           VerifyField<double>(verifier, VT_RIGHT) &&
           VerifyOffset(verifier, VT_SP) &&
           verifier.VerifyVector(SP()) &&
           VerifyOffset(verifier, VT_EP) &&
           verifier.VerifyVector(EP()) &&
           VerifyOffset(verifier, VT_PNT) &&
           verifier.VerifyVector(Pnt()) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyString(T()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct DefDataMessageBuilder {
  typedef DefDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_O(flatbuffers::Offset<flatbuffers::Vector<double>> O) {
    fbb_.AddOffset(DefDataMessage::VT_O, O);
  }
  void add_N(flatbuffers::Offset<flatbuffers::Vector<double>> N) {
    fbb_.AddOffset(DefDataMessage::VT_N, N);
  }
  void add_X(flatbuffers::Offset<flatbuffers::Vector<double>> X) {
    fbb_.AddOffset(DefDataMessage::VT_X, X);
  }
  void add_H(double H) {
    fbb_.AddElement<double>(DefDataMessage::VT_H, H, 0.0);
  }
  void add_W(double W) {
    fbb_.AddElement<double>(DefDataMessage::VT_W, W, 0.0);
  }
  void add_Top(double Top) {
    fbb_.AddElement<double>(DefDataMessage::VT_TOP, Top, 0.0);
  }
  void add_Bottom(double Bottom) {
    fbb_.AddElement<double>(DefDataMessage::VT_BOTTOM, Bottom, 0.0);
  }
  void add_Left(double Left) {
    fbb_.AddElement<double>(DefDataMessage::VT_LEFT, Left, 0.0);
  }
  void add_Right(double Right) {
    fbb_.AddElement<double>(DefDataMessage::VT_RIGHT, Right, 0.0);
  }
  void add_SP(flatbuffers::Offset<flatbuffers::Vector<double>> SP) {
    fbb_.AddOffset(DefDataMessage::VT_SP, SP);
  }
  void add_EP(flatbuffers::Offset<flatbuffers::Vector<double>> EP) {
    fbb_.AddOffset(DefDataMessage::VT_EP, EP);
  }
  void add_Pnt(flatbuffers::Offset<flatbuffers::Vector<double>> Pnt) {
    fbb_.AddOffset(DefDataMessage::VT_PNT, Pnt);
  }
  void add_T(flatbuffers::Offset<flatbuffers::String> T) {
    fbb_.AddOffset(DefDataMessage::VT_T, T);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(DefDataMessage::VT_ID, ID, 0);
  }
  explicit DefDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DefDataMessageBuilder &operator=(const DefDataMessageBuilder &);
  flatbuffers::Offset<DefDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DefDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<DefDataMessage> CreateDefDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> O = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> N = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> X = 0,
    double H = 0.0,
    double W = 0.0,
    double Top = 0.0,
    double Bottom = 0.0,
    double Left = 0.0,
    double Right = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> SP = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EP = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Pnt = 0,
    flatbuffers::Offset<flatbuffers::String> T = 0,
    int32_t ID = 0) {
  DefDataMessageBuilder builder_(_fbb);
  builder_.add_Right(Right);
  builder_.add_Left(Left);
  builder_.add_Bottom(Bottom);
  builder_.add_Top(Top);
  builder_.add_W(W);
  builder_.add_H(H);
  builder_.add_ID(ID);
  builder_.add_T(T);
  builder_.add_Pnt(Pnt);
  builder_.add_EP(EP);
  builder_.add_SP(SP);
  builder_.add_X(X);
  builder_.add_N(N);
  builder_.add_O(O);
  return builder_.Finish();
}

inline flatbuffers::Offset<DefDataMessage> CreateDefDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *O = nullptr,
    const std::vector<double> *N = nullptr,
    const std::vector<double> *X = nullptr,
    double H = 0.0,
    double W = 0.0,
    double Top = 0.0,
    double Bottom = 0.0,
    double Left = 0.0,
    double Right = 0.0,
    const std::vector<double> *SP = nullptr,
    const std::vector<double> *EP = nullptr,
    const std::vector<double> *Pnt = nullptr,
    const char *T = nullptr,
    int32_t ID = 0) {
  auto O__ = O ? _fbb.CreateVector<double>(*O) : 0;
  auto N__ = N ? _fbb.CreateVector<double>(*N) : 0;
  auto X__ = X ? _fbb.CreateVector<double>(*X) : 0;
  auto SP__ = SP ? _fbb.CreateVector<double>(*SP) : 0;
  auto EP__ = EP ? _fbb.CreateVector<double>(*EP) : 0;
  auto Pnt__ = Pnt ? _fbb.CreateVector<double>(*Pnt) : 0;
  auto T__ = T ? _fbb.CreateString(T) : 0;
  return FlatBufferDocSpace::CreateDefDataMessage(
      _fbb,
      O__,
      N__,
      X__,
      H,
      W,
      Top,
      Bottom,
      Left,
      Right,
      SP__,
      EP__,
      Pnt__,
      T__,
      ID);
}

struct ArsDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArsDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_O = 4,
    VT_A = 6,
    VT_F = 8,
    VT_OP = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *O() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *>(VT_O);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *A() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *>(VT_A);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *F() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *>(VT_F);
  }
  const flatbuffers::Vector<double> *OP() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_OP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_O) &&
           verifier.VerifyVector(O()) &&
           verifier.VerifyVectorOfTables(O()) &&
           VerifyOffset(verifier, VT_A) &&
           verifier.VerifyVector(A()) &&
           verifier.VerifyVectorOfTables(A()) &&
           VerifyOffset(verifier, VT_F) &&
           verifier.VerifyVector(F()) &&
           verifier.VerifyVectorOfTables(F()) &&
           VerifyOffset(verifier, VT_OP) &&
           verifier.VerifyVector(OP()) &&
           verifier.EndTable();
  }
};

struct ArsDataMessageBuilder {
  typedef ArsDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_O(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>> O) {
    fbb_.AddOffset(ArsDataMessage::VT_O, O);
  }
  void add_A(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>> A) {
    fbb_.AddOffset(ArsDataMessage::VT_A, A);
  }
  void add_F(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>> F) {
    fbb_.AddOffset(ArsDataMessage::VT_F, F);
  }
  void add_OP(flatbuffers::Offset<flatbuffers::Vector<double>> OP) {
    fbb_.AddOffset(ArsDataMessage::VT_OP, OP);
  }
  explicit ArsDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArsDataMessageBuilder &operator=(const ArsDataMessageBuilder &);
  flatbuffers::Offset<ArsDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArsDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArsDataMessage> CreateArsDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>> O = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>> A = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>> F = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> OP = 0) {
  ArsDataMessageBuilder builder_(_fbb);
  builder_.add_OP(OP);
  builder_.add_F(F);
  builder_.add_A(A);
  builder_.add_O(O);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArsDataMessage> CreateArsDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *O = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *A = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>> *F = nullptr,
    const std::vector<double> *OP = nullptr) {
  auto O__ = O ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>(*O) : 0;
  auto A__ = A ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>(*A) : 0;
  auto F__ = F ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage>>(*F) : 0;
  auto OP__ = OP ? _fbb.CreateVector<double>(*OP) : 0;
  return FlatBufferDocSpace::CreateArsDataMessage(
      _fbb,
      O__,
      A__,
      F__,
      OP__);
}

struct DatumPreviewData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DatumPreviewDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEFDATA = 4,
    VT_HANDLEDATA = 6,
    VT_TOPODATA = 8
  };
  const FlatBufferDocSpace::DefDataMessage *DefData() const {
    return GetPointer<const FlatBufferDocSpace::DefDataMessage *>(VT_DEFDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *>(VT_HANDLEDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *>(VT_TOPODATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEFDATA) &&
           verifier.VerifyTable(DefData()) &&
           VerifyOffset(verifier, VT_HANDLEDATA) &&
           verifier.VerifyVector(HandleData()) &&
           verifier.VerifyVectorOfTables(HandleData()) &&
           VerifyOffset(verifier, VT_TOPODATA) &&
           verifier.VerifyVector(TopoData()) &&
           verifier.VerifyVectorOfTables(TopoData()) &&
           verifier.EndTable();
  }
};

struct DatumPreviewDataBuilder {
  typedef DatumPreviewData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DefData(flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage> DefData) {
    fbb_.AddOffset(DatumPreviewData::VT_DEFDATA, DefData);
  }
  void add_HandleData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData) {
    fbb_.AddOffset(DatumPreviewData::VT_HANDLEDATA, HandleData);
  }
  void add_TopoData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData) {
    fbb_.AddOffset(DatumPreviewData::VT_TOPODATA, TopoData);
  }
  explicit DatumPreviewDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DatumPreviewDataBuilder &operator=(const DatumPreviewDataBuilder &);
  flatbuffers::Offset<DatumPreviewData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DatumPreviewData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DatumPreviewData> CreateDatumPreviewData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage> DefData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData = 0) {
  DatumPreviewDataBuilder builder_(_fbb);
  builder_.add_TopoData(TopoData);
  builder_.add_HandleData(HandleData);
  builder_.add_DefData(DefData);
  return builder_.Finish();
}

inline flatbuffers::Offset<DatumPreviewData> CreateDatumPreviewDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::DefDataMessage> DefData = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData = nullptr) {
  auto HandleData__ = HandleData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>(*HandleData) : 0;
  auto TopoData__ = TopoData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>(*TopoData) : 0;
  return FlatBufferDocSpace::CreateDatumPreviewData(
      _fbb,
      DefData,
      HandleData__,
      TopoData__);
}

struct ArsPreviewData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArsPreviewDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEFDATA = 4,
    VT_HANDLEDATA = 6,
    VT_TOPODATA = 8
  };
  const FlatBufferDocSpace::ArsDataMessage *DefData() const {
    return GetPointer<const FlatBufferDocSpace::ArsDataMessage *>(VT_DEFDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *>(VT_HANDLEDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *>(VT_TOPODATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEFDATA) &&
           verifier.VerifyTable(DefData()) &&
           VerifyOffset(verifier, VT_HANDLEDATA) &&
           verifier.VerifyVector(HandleData()) &&
           verifier.VerifyVectorOfTables(HandleData()) &&
           VerifyOffset(verifier, VT_TOPODATA) &&
           verifier.VerifyVector(TopoData()) &&
           verifier.VerifyVectorOfTables(TopoData()) &&
           verifier.EndTable();
  }
};

struct ArsPreviewDataBuilder {
  typedef ArsPreviewData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DefData(flatbuffers::Offset<FlatBufferDocSpace::ArsDataMessage> DefData) {
    fbb_.AddOffset(ArsPreviewData::VT_DEFDATA, DefData);
  }
  void add_HandleData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData) {
    fbb_.AddOffset(ArsPreviewData::VT_HANDLEDATA, HandleData);
  }
  void add_TopoData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData) {
    fbb_.AddOffset(ArsPreviewData::VT_TOPODATA, TopoData);
  }
  explicit ArsPreviewDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArsPreviewDataBuilder &operator=(const ArsPreviewDataBuilder &);
  flatbuffers::Offset<ArsPreviewData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArsPreviewData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArsPreviewData> CreateArsPreviewData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::ArsDataMessage> DefData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>> TopoData = 0) {
  ArsPreviewDataBuilder builder_(_fbb);
  builder_.add_TopoData(TopoData);
  builder_.add_HandleData(HandleData);
  builder_.add_DefData(DefData);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArsPreviewData> CreateArsPreviewDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::ArsDataMessage> DefData = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>> *TopoData = nullptr) {
  auto HandleData__ = HandleData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>(*HandleData) : 0;
  auto TopoData__ = TopoData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TopoDataMessage>>(*TopoData) : 0;
  return FlatBufferDocSpace::CreateArsPreviewData(
      _fbb,
      DefData,
      HandleData__,
      TopoData__);
}

struct InitOffsetCurveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitOffsetCurveDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSETONPLANE = 4,
    VT_OFFSETTYPE = 6,
    VT_DIMVARIABLE = 8,
    VT_OFFSETPNT = 10,
    VT_OFFSETTRANS = 12,
    VT_OFFSETMOVECOPY = 14
  };
  bool OffsetOnPlane() const {
    return GetField<uint8_t>(VT_OFFSETONPLANE, 0) != 0;
  }
  int32_t OffsetType() const {
    return GetField<int32_t>(VT_OFFSETTYPE, 0);
  }
  const FlatBufferDocSpace::VariableData *DimVariable() const {
    return GetPointer<const FlatBufferDocSpace::VariableData *>(VT_DIMVARIABLE);
  }
  const flatbuffers::Vector<double> *OffsetPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_OFFSETPNT);
  }
  int32_t OffsetTrans() const {
    return GetField<int32_t>(VT_OFFSETTRANS, 0);
  }
  int32_t OffsetMoveCopy() const {
    return GetField<int32_t>(VT_OFFSETMOVECOPY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OFFSETONPLANE) &&
           VerifyField<int32_t>(verifier, VT_OFFSETTYPE) &&
           VerifyOffset(verifier, VT_DIMVARIABLE) &&
           verifier.VerifyTable(DimVariable()) &&
           VerifyOffset(verifier, VT_OFFSETPNT) &&
           verifier.VerifyVector(OffsetPnt()) &&
           VerifyField<int32_t>(verifier, VT_OFFSETTRANS) &&
           VerifyField<int32_t>(verifier, VT_OFFSETMOVECOPY) &&
           verifier.EndTable();
  }
};

struct InitOffsetCurveDataBuilder {
  typedef InitOffsetCurveData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_OffsetOnPlane(bool OffsetOnPlane) {
    fbb_.AddElement<uint8_t>(InitOffsetCurveData::VT_OFFSETONPLANE, static_cast<uint8_t>(OffsetOnPlane), 0);
  }
  void add_OffsetType(int32_t OffsetType) {
    fbb_.AddElement<int32_t>(InitOffsetCurveData::VT_OFFSETTYPE, OffsetType, 0);
  }
  void add_DimVariable(flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable) {
    fbb_.AddOffset(InitOffsetCurveData::VT_DIMVARIABLE, DimVariable);
  }
  void add_OffsetPnt(flatbuffers::Offset<flatbuffers::Vector<double>> OffsetPnt) {
    fbb_.AddOffset(InitOffsetCurveData::VT_OFFSETPNT, OffsetPnt);
  }
  void add_OffsetTrans(int32_t OffsetTrans) {
    fbb_.AddElement<int32_t>(InitOffsetCurveData::VT_OFFSETTRANS, OffsetTrans, 0);
  }
  void add_OffsetMoveCopy(int32_t OffsetMoveCopy) {
    fbb_.AddElement<int32_t>(InitOffsetCurveData::VT_OFFSETMOVECOPY, OffsetMoveCopy, 0);
  }
  explicit InitOffsetCurveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitOffsetCurveDataBuilder &operator=(const InitOffsetCurveDataBuilder &);
  flatbuffers::Offset<InitOffsetCurveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitOffsetCurveData>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitOffsetCurveData> CreateInitOffsetCurveData(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool OffsetOnPlane = false,
    int32_t OffsetType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> OffsetPnt = 0,
    int32_t OffsetTrans = 0,
    int32_t OffsetMoveCopy = 0) {
  InitOffsetCurveDataBuilder builder_(_fbb);
  builder_.add_OffsetMoveCopy(OffsetMoveCopy);
  builder_.add_OffsetTrans(OffsetTrans);
  builder_.add_OffsetPnt(OffsetPnt);
  builder_.add_DimVariable(DimVariable);
  builder_.add_OffsetType(OffsetType);
  builder_.add_OffsetOnPlane(OffsetOnPlane);
  return builder_.Finish();
}

inline flatbuffers::Offset<InitOffsetCurveData> CreateInitOffsetCurveDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool OffsetOnPlane = false,
    int32_t OffsetType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::VariableData> DimVariable = 0,
    const std::vector<double> *OffsetPnt = nullptr,
    int32_t OffsetTrans = 0,
    int32_t OffsetMoveCopy = 0) {
  auto OffsetPnt__ = OffsetPnt ? _fbb.CreateVector<double>(*OffsetPnt) : 0;
  return FlatBufferDocSpace::CreateInitOffsetCurveData(
      _fbb,
      OffsetOnPlane,
      OffsetType,
      DimVariable,
      OffsetPnt__,
      OffsetTrans,
      OffsetMoveCopy);
}

struct WorkPlaneMatrixData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorkPlaneMatrixDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATRIX = 4
  };
  const flatbuffers::Vector<double> *Matrix() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MATRIX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyVector(Matrix()) &&
           verifier.EndTable();
  }
};

struct WorkPlaneMatrixDataBuilder {
  typedef WorkPlaneMatrixData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Matrix(flatbuffers::Offset<flatbuffers::Vector<double>> Matrix) {
    fbb_.AddOffset(WorkPlaneMatrixData::VT_MATRIX, Matrix);
  }
  explicit WorkPlaneMatrixDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkPlaneMatrixDataBuilder &operator=(const WorkPlaneMatrixDataBuilder &);
  flatbuffers::Offset<WorkPlaneMatrixData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkPlaneMatrixData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkPlaneMatrixData> CreateWorkPlaneMatrixData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> Matrix = 0) {
  WorkPlaneMatrixDataBuilder builder_(_fbb);
  builder_.add_Matrix(Matrix);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkPlaneMatrixData> CreateWorkPlaneMatrixDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *Matrix = nullptr) {
  auto Matrix__ = Matrix ? _fbb.CreateVector<double>(*Matrix) : 0;
  return FlatBufferDocSpace::CreateWorkPlaneMatrixData(
      _fbb,
      Matrix__);
}

struct MeasureInforData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeasureInforDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *Value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           verifier.EndTable();
  }
};

struct MeasureInforDataBuilder {
  typedef MeasureInforData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value(flatbuffers::Offset<flatbuffers::String> Value) {
    fbb_.AddOffset(MeasureInforData::VT_VALUE, Value);
  }
  explicit MeasureInforDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeasureInforDataBuilder &operator=(const MeasureInforDataBuilder &);
  flatbuffers::Offset<MeasureInforData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeasureInforData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeasureInforData> CreateMeasureInforData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Value = 0) {
  MeasureInforDataBuilder builder_(_fbb);
  builder_.add_Value(Value);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeasureInforData> CreateMeasureInforDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Value = nullptr) {
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  return FlatBufferDocSpace::CreateMeasureInforData(
      _fbb,
      Value__);
}

struct VariableDataMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VariableDataMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *Value() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(Value()) &&
           verifier.VerifyVectorOfTables(Value()) &&
           verifier.EndTable();
  }
};

struct VariableDataMessageBuilder {
  typedef VariableDataMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> Value) {
    fbb_.AddOffset(VariableDataMessage::VT_VALUE, Value);
  }
  explicit VariableDataMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VariableDataMessageBuilder &operator=(const VariableDataMessageBuilder &);
  flatbuffers::Offset<VariableDataMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VariableDataMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<VariableDataMessage> CreateVariableDataMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> Value = 0) {
  VariableDataMessageBuilder builder_(_fbb);
  builder_.add_Value(Value);
  return builder_.Finish();
}

inline flatbuffers::Offset<VariableDataMessage> CreateVariableDataMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *Value = nullptr) {
  auto Value__ = Value ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*Value) : 0;
  return FlatBufferDocSpace::CreateVariableDataMessage(
      _fbb,
      Value__);
}

struct DimensionDataInforMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimensionDataInforMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMENSIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Dimensions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_DIMENSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMENSIONS) &&
           verifier.VerifyVector(Dimensions()) &&
           verifier.VerifyVectorOfTables(Dimensions()) &&
           verifier.EndTable();
  }
};

struct DimensionDataInforMessageBuilder {
  typedef DimensionDataInforMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Dimensions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Dimensions) {
    fbb_.AddOffset(DimensionDataInforMessage::VT_DIMENSIONS, Dimensions);
  }
  explicit DimensionDataInforMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionDataInforMessageBuilder &operator=(const DimensionDataInforMessageBuilder &);
  flatbuffers::Offset<DimensionDataInforMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionDataInforMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionDataInforMessage> CreateDimensionDataInforMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Dimensions = 0) {
  DimensionDataInforMessageBuilder builder_(_fbb);
  builder_.add_Dimensions(Dimensions);
  return builder_.Finish();
}

inline flatbuffers::Offset<DimensionDataInforMessage> CreateDimensionDataInforMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Dimensions = nullptr) {
  auto Dimensions__ = Dimensions ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*Dimensions) : 0;
  return FlatBufferDocSpace::CreateDimensionDataInforMessage(
      _fbb,
      Dimensions__);
}

struct ErrorStringData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorStringDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HANDLEDATA = 4,
    VT_PARAMDATA = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *>(VT_HANDLEDATA);
  }
  const flatbuffers::String *ParamData() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HANDLEDATA) &&
           verifier.VerifyVector(HandleData()) &&
           verifier.VerifyVectorOfTables(HandleData()) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyString(ParamData()) &&
           verifier.EndTable();
  }
};

struct ErrorStringDataBuilder {
  typedef ErrorStringData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HandleData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData) {
    fbb_.AddOffset(ErrorStringData::VT_HANDLEDATA, HandleData);
  }
  void add_ParamData(flatbuffers::Offset<flatbuffers::String> ParamData) {
    fbb_.AddOffset(ErrorStringData::VT_PARAMDATA, ParamData);
  }
  explicit ErrorStringDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorStringDataBuilder &operator=(const ErrorStringDataBuilder &);
  flatbuffers::Offset<ErrorStringData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorStringData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorStringData> CreateErrorStringData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>> HandleData = 0,
    flatbuffers::Offset<flatbuffers::String> ParamData = 0) {
  ErrorStringDataBuilder builder_(_fbb);
  builder_.add_ParamData(ParamData);
  builder_.add_HandleData(HandleData);
  return builder_.Finish();
}

inline flatbuffers::Offset<ErrorStringData> CreateErrorStringDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>> *HandleData = nullptr,
    const char *ParamData = nullptr) {
  auto HandleData__ = HandleData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HandleDataMessage>>(*HandleData) : 0;
  auto ParamData__ = ParamData ? _fbb.CreateString(ParamData) : 0;
  return FlatBufferDocSpace::CreateErrorStringData(
      _fbb,
      HandleData__,
      ParamData__);
}

struct MassPropertyData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MassPropertyDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BARYCENTER = 4,
    VT_AREA = 6,
    VT_VOLUME = 8,
    VT_MASS = 10,
    VT_DENSITY = 12,
    VT_OT = 14,
    VT_BT = 16,
    VT_T1 = 18,
    VT_T2 = 20,
    VT_COVERMASSFLAG = 22,
    VT_COVERCENTROIDFLAG = 24,
    VT_COVERCOORDINATEID = 26,
    VT_COVERCENTROIDPT = 28
  };
  const flatbuffers::Vector<double> *BaryCenter() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_BARYCENTER);
  }
  double Area() const {
    return GetField<double>(VT_AREA, 0.0);
  }
  double Volume() const {
    return GetField<double>(VT_VOLUME, 0.0);
  }
  double Mass() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  const flatbuffers::Vector<double> *Density() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DENSITY);
  }
  const FlatBufferDocSpace::MatrixData *OT() const {
    return GetPointer<const FlatBufferDocSpace::MatrixData *>(VT_OT);
  }
  const FlatBufferDocSpace::MatrixData *BT() const {
    return GetPointer<const FlatBufferDocSpace::MatrixData *>(VT_BT);
  }
  const FlatBufferDocSpace::MatrixData *T1() const {
    return GetPointer<const FlatBufferDocSpace::MatrixData *>(VT_T1);
  }
  const flatbuffers::Vector<double> *T2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_T2);
  }
  bool CoverMassFlag() const {
    return GetField<uint8_t>(VT_COVERMASSFLAG, 0) != 0;
  }
  bool CoverCentroidFlag() const {
    return GetField<uint8_t>(VT_COVERCENTROIDFLAG, 0) != 0;
  }
  int32_t CoverCoordinateId() const {
    return GetField<int32_t>(VT_COVERCOORDINATEID, 0);
  }
  const flatbuffers::Vector<double> *CoverCentroidPt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVERCENTROIDPT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BARYCENTER) &&
           verifier.VerifyVector(BaryCenter()) &&
           VerifyField<double>(verifier, VT_AREA) &&
           VerifyField<double>(verifier, VT_VOLUME) &&
           VerifyField<double>(verifier, VT_MASS) &&
           VerifyOffset(verifier, VT_DENSITY) &&
           verifier.VerifyVector(Density()) &&
           VerifyOffset(verifier, VT_OT) &&
           verifier.VerifyTable(OT()) &&
           VerifyOffset(verifier, VT_BT) &&
           verifier.VerifyTable(BT()) &&
           VerifyOffset(verifier, VT_T1) &&
           verifier.VerifyTable(T1()) &&
           VerifyOffset(verifier, VT_T2) &&
           verifier.VerifyVector(T2()) &&
           VerifyField<uint8_t>(verifier, VT_COVERMASSFLAG) &&
           VerifyField<uint8_t>(verifier, VT_COVERCENTROIDFLAG) &&
           VerifyField<int32_t>(verifier, VT_COVERCOORDINATEID) &&
           VerifyOffset(verifier, VT_COVERCENTROIDPT) &&
           verifier.VerifyVector(CoverCentroidPt()) &&
           verifier.EndTable();
  }
};

struct MassPropertyDataBuilder {
  typedef MassPropertyData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_BaryCenter(flatbuffers::Offset<flatbuffers::Vector<double>> BaryCenter) {
    fbb_.AddOffset(MassPropertyData::VT_BARYCENTER, BaryCenter);
  }
  void add_Area(double Area) {
    fbb_.AddElement<double>(MassPropertyData::VT_AREA, Area, 0.0);
  }
  void add_Volume(double Volume) {
    fbb_.AddElement<double>(MassPropertyData::VT_VOLUME, Volume, 0.0);
  }
  void add_Mass(double Mass) {
    fbb_.AddElement<double>(MassPropertyData::VT_MASS, Mass, 0.0);
  }
  void add_Density(flatbuffers::Offset<flatbuffers::Vector<double>> Density) {
    fbb_.AddOffset(MassPropertyData::VT_DENSITY, Density);
  }
  void add_OT(flatbuffers::Offset<FlatBufferDocSpace::MatrixData> OT) {
    fbb_.AddOffset(MassPropertyData::VT_OT, OT);
  }
  void add_BT(flatbuffers::Offset<FlatBufferDocSpace::MatrixData> BT) {
    fbb_.AddOffset(MassPropertyData::VT_BT, BT);
  }
  void add_T1(flatbuffers::Offset<FlatBufferDocSpace::MatrixData> T1) {
    fbb_.AddOffset(MassPropertyData::VT_T1, T1);
  }
  void add_T2(flatbuffers::Offset<flatbuffers::Vector<double>> T2) {
    fbb_.AddOffset(MassPropertyData::VT_T2, T2);
  }
  void add_CoverMassFlag(bool CoverMassFlag) {
    fbb_.AddElement<uint8_t>(MassPropertyData::VT_COVERMASSFLAG, static_cast<uint8_t>(CoverMassFlag), 0);
  }
  void add_CoverCentroidFlag(bool CoverCentroidFlag) {
    fbb_.AddElement<uint8_t>(MassPropertyData::VT_COVERCENTROIDFLAG, static_cast<uint8_t>(CoverCentroidFlag), 0);
  }
  void add_CoverCoordinateId(int32_t CoverCoordinateId) {
    fbb_.AddElement<int32_t>(MassPropertyData::VT_COVERCOORDINATEID, CoverCoordinateId, 0);
  }
  void add_CoverCentroidPt(flatbuffers::Offset<flatbuffers::Vector<double>> CoverCentroidPt) {
    fbb_.AddOffset(MassPropertyData::VT_COVERCENTROIDPT, CoverCentroidPt);
  }
  explicit MassPropertyDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MassPropertyDataBuilder &operator=(const MassPropertyDataBuilder &);
  flatbuffers::Offset<MassPropertyData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MassPropertyData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MassPropertyData> CreateMassPropertyData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> BaryCenter = 0,
    double Area = 0.0,
    double Volume = 0.0,
    double Mass = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Density = 0,
    flatbuffers::Offset<FlatBufferDocSpace::MatrixData> OT = 0,
    flatbuffers::Offset<FlatBufferDocSpace::MatrixData> BT = 0,
    flatbuffers::Offset<FlatBufferDocSpace::MatrixData> T1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> T2 = 0,
    bool CoverMassFlag = false,
    bool CoverCentroidFlag = false,
    int32_t CoverCoordinateId = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CoverCentroidPt = 0) {
  MassPropertyDataBuilder builder_(_fbb);
  builder_.add_Mass(Mass);
  builder_.add_Volume(Volume);
  builder_.add_Area(Area);
  builder_.add_CoverCentroidPt(CoverCentroidPt);
  builder_.add_CoverCoordinateId(CoverCoordinateId);
  builder_.add_T2(T2);
  builder_.add_T1(T1);
  builder_.add_BT(BT);
  builder_.add_OT(OT);
  builder_.add_Density(Density);
  builder_.add_BaryCenter(BaryCenter);
  builder_.add_CoverCentroidFlag(CoverCentroidFlag);
  builder_.add_CoverMassFlag(CoverMassFlag);
  return builder_.Finish();
}

inline flatbuffers::Offset<MassPropertyData> CreateMassPropertyDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *BaryCenter = nullptr,
    double Area = 0.0,
    double Volume = 0.0,
    double Mass = 0.0,
    const std::vector<double> *Density = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::MatrixData> OT = 0,
    flatbuffers::Offset<FlatBufferDocSpace::MatrixData> BT = 0,
    flatbuffers::Offset<FlatBufferDocSpace::MatrixData> T1 = 0,
    const std::vector<double> *T2 = nullptr,
    bool CoverMassFlag = false,
    bool CoverCentroidFlag = false,
    int32_t CoverCoordinateId = 0,
    const std::vector<double> *CoverCentroidPt = nullptr) {
  auto BaryCenter__ = BaryCenter ? _fbb.CreateVector<double>(*BaryCenter) : 0;
  auto Density__ = Density ? _fbb.CreateVector<double>(*Density) : 0;
  auto T2__ = T2 ? _fbb.CreateVector<double>(*T2) : 0;
  auto CoverCentroidPt__ = CoverCentroidPt ? _fbb.CreateVector<double>(*CoverCentroidPt) : 0;
  return FlatBufferDocSpace::CreateMassPropertyData(
      _fbb,
      BaryCenter__,
      Area,
      Volume,
      Mass,
      Density__,
      OT,
      BT,
      T1,
      T2__,
      CoverMassFlag,
      CoverCentroidFlag,
      CoverCoordinateId,
      CoverCentroidPt__);
}

struct IntegerValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t Value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct IntegerValueBuilder {
  typedef IntegerValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value(int32_t Value) {
    fbb_.AddElement<int32_t>(IntegerValue::VT_VALUE, Value, 0);
  }
  explicit IntegerValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntegerValueBuilder &operator=(const IntegerValueBuilder &);
  flatbuffers::Offset<IntegerValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntegerValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntegerValue> CreateIntegerValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Value = 0) {
  IntegerValueBuilder builder_(_fbb);
  builder_.add_Value(Value);
  return builder_.Finish();
}

struct SaveFileData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveFileDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *Value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           verifier.EndTable();
  }
};

struct SaveFileDataBuilder {
  typedef SaveFileData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value(flatbuffers::Offset<flatbuffers::String> Value) {
    fbb_.AddOffset(SaveFileData::VT_VALUE, Value);
  }
  explicit SaveFileDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SaveFileDataBuilder &operator=(const SaveFileDataBuilder &);
  flatbuffers::Offset<SaveFileData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveFileData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveFileData> CreateSaveFileData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Value = 0) {
  SaveFileDataBuilder builder_(_fbb);
  builder_.add_Value(Value);
  return builder_.Finish();
}

inline flatbuffers::Offset<SaveFileData> CreateSaveFileDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Value = nullptr) {
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  return FlatBufferDocSpace::CreateSaveFileData(
      _fbb,
      Value__);
}

struct SaveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAVEFILES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SaveFileData>> *SaveFiles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SaveFileData>> *>(VT_SAVEFILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SAVEFILES) &&
           verifier.VerifyVector(SaveFiles()) &&
           verifier.VerifyVectorOfTables(SaveFiles()) &&
           verifier.EndTable();
  }
};

struct SaveDataBuilder {
  typedef SaveData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SaveFiles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SaveFileData>>> SaveFiles) {
    fbb_.AddOffset(SaveData::VT_SAVEFILES, SaveFiles);
  }
  explicit SaveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SaveDataBuilder &operator=(const SaveDataBuilder &);
  flatbuffers::Offset<SaveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveData> CreateSaveData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SaveFileData>>> SaveFiles = 0) {
  SaveDataBuilder builder_(_fbb);
  builder_.add_SaveFiles(SaveFiles);
  return builder_.Finish();
}

inline flatbuffers::Offset<SaveData> CreateSaveDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SaveFileData>> *SaveFiles = nullptr) {
  auto SaveFiles__ = SaveFiles ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SaveFileData>>(*SaveFiles) : 0;
  return FlatBufferDocSpace::CreateSaveData(
      _fbb,
      SaveFiles__);
}

struct IdData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IdDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *Value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           verifier.EndTable();
  }
};

struct IdDataBuilder {
  typedef IdData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value(flatbuffers::Offset<flatbuffers::String> Value) {
    fbb_.AddOffset(IdData::VT_VALUE, Value);
  }
  explicit IdDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IdDataBuilder &operator=(const IdDataBuilder &);
  flatbuffers::Offset<IdData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IdData>(end);
    return o;
  }
};

inline flatbuffers::Offset<IdData> CreateIdData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Value = 0) {
  IdDataBuilder builder_(_fbb);
  builder_.add_Value(Value);
  return builder_.Finish();
}

inline flatbuffers::Offset<IdData> CreateIdDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Value = nullptr) {
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  return FlatBufferDocSpace::CreateIdData(
      _fbb,
      Value__);
}

struct CurveCurvature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurveCurvatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_COMPID = 6,
    VT_POINTS = 8,
    VT_POINTEXTS = 10,
    VT_MAGNITUDE = 12
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *CompId() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPID);
  }
  const flatbuffers::Vector<double> *Points() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINTS);
  }
  const flatbuffers::Vector<double> *PointExts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINTEXTS);
  }
  const flatbuffers::Vector<double> *Magnitude() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAGNITUDE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_COMPID) &&
           verifier.VerifyString(CompId()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(Points()) &&
           VerifyOffset(verifier, VT_POINTEXTS) &&
           verifier.VerifyVector(PointExts()) &&
           VerifyOffset(verifier, VT_MAGNITUDE) &&
           verifier.VerifyVector(Magnitude()) &&
           verifier.EndTable();
  }
};

struct CurveCurvatureBuilder {
  typedef CurveCurvature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(CurveCurvature::VT_ID, Id, 0);
  }
  void add_CompId(flatbuffers::Offset<flatbuffers::String> CompId) {
    fbb_.AddOffset(CurveCurvature::VT_COMPID, CompId);
  }
  void add_Points(flatbuffers::Offset<flatbuffers::Vector<double>> Points) {
    fbb_.AddOffset(CurveCurvature::VT_POINTS, Points);
  }
  void add_PointExts(flatbuffers::Offset<flatbuffers::Vector<double>> PointExts) {
    fbb_.AddOffset(CurveCurvature::VT_POINTEXTS, PointExts);
  }
  void add_Magnitude(flatbuffers::Offset<flatbuffers::Vector<double>> Magnitude) {
    fbb_.AddOffset(CurveCurvature::VT_MAGNITUDE, Magnitude);
  }
  explicit CurveCurvatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurveCurvatureBuilder &operator=(const CurveCurvatureBuilder &);
  flatbuffers::Offset<CurveCurvature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurveCurvature>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurveCurvature> CreateCurveCurvature(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    flatbuffers::Offset<flatbuffers::String> CompId = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Points = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> PointExts = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Magnitude = 0) {
  CurveCurvatureBuilder builder_(_fbb);
  builder_.add_Magnitude(Magnitude);
  builder_.add_PointExts(PointExts);
  builder_.add_Points(Points);
  builder_.add_CompId(CompId);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline flatbuffers::Offset<CurveCurvature> CreateCurveCurvatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    const char *CompId = nullptr,
    const std::vector<double> *Points = nullptr,
    const std::vector<double> *PointExts = nullptr,
    const std::vector<double> *Magnitude = nullptr) {
  auto CompId__ = CompId ? _fbb.CreateString(CompId) : 0;
  auto Points__ = Points ? _fbb.CreateVector<double>(*Points) : 0;
  auto PointExts__ = PointExts ? _fbb.CreateVector<double>(*PointExts) : 0;
  auto Magnitude__ = Magnitude ? _fbb.CreateVector<double>(*Magnitude) : 0;
  return FlatBufferDocSpace::CreateCurveCurvature(
      _fbb,
      Id,
      CompId__,
      Points__,
      PointExts__,
      Magnitude__);
}

struct CurvatureData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurvatureDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURVECURVATURES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CurveCurvature>> *CurveCurvatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CurveCurvature>> *>(VT_CURVECURVATURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURVECURVATURES) &&
           verifier.VerifyVector(CurveCurvatures()) &&
           verifier.VerifyVectorOfTables(CurveCurvatures()) &&
           verifier.EndTable();
  }
};

struct CurvatureDataBuilder {
  typedef CurvatureData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CurveCurvatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CurveCurvature>>> CurveCurvatures) {
    fbb_.AddOffset(CurvatureData::VT_CURVECURVATURES, CurveCurvatures);
  }
  explicit CurvatureDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurvatureDataBuilder &operator=(const CurvatureDataBuilder &);
  flatbuffers::Offset<CurvatureData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurvatureData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurvatureData> CreateCurvatureData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CurveCurvature>>> CurveCurvatures = 0) {
  CurvatureDataBuilder builder_(_fbb);
  builder_.add_CurveCurvatures(CurveCurvatures);
  return builder_.Finish();
}

inline flatbuffers::Offset<CurvatureData> CreateCurvatureDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CurveCurvature>> *CurveCurvatures = nullptr) {
  auto CurveCurvatures__ = CurveCurvatures ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CurveCurvature>>(*CurveCurvatures) : 0;
  return FlatBufferDocSpace::CreateCurvatureData(
      _fbb,
      CurveCurvatures__);
}

struct SurfaceCurvature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SurfaceCurvatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_COMPID = 6,
    VT_POINTS = 8,
    VT_TRIANGLES = 10,
    VT_MINCURCATURE = 12,
    VT_MAXCURCATURE = 14,
    VT_MEANCURCATURE = 16,
    VT_GAUSSCURCATURE = 18
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *CompId() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPID);
  }
  const flatbuffers::Vector<double> *Points() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINTS);
  }
  const flatbuffers::Vector<int32_t> *Triangles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TRIANGLES);
  }
  const flatbuffers::Vector<double> *MinCurcature() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MINCURCATURE);
  }
  const flatbuffers::Vector<double> *MaxCurcature() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MAXCURCATURE);
  }
  const flatbuffers::Vector<double> *MeanCurcature() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MEANCURCATURE);
  }
  const flatbuffers::Vector<double> *GaussCurcature() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_GAUSSCURCATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_COMPID) &&
           verifier.VerifyString(CompId()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(Points()) &&
           VerifyOffset(verifier, VT_TRIANGLES) &&
           verifier.VerifyVector(Triangles()) &&
           VerifyOffset(verifier, VT_MINCURCATURE) &&
           verifier.VerifyVector(MinCurcature()) &&
           VerifyOffset(verifier, VT_MAXCURCATURE) &&
           verifier.VerifyVector(MaxCurcature()) &&
           VerifyOffset(verifier, VT_MEANCURCATURE) &&
           verifier.VerifyVector(MeanCurcature()) &&
           VerifyOffset(verifier, VT_GAUSSCURCATURE) &&
           verifier.VerifyVector(GaussCurcature()) &&
           verifier.EndTable();
  }
};

struct SurfaceCurvatureBuilder {
  typedef SurfaceCurvature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(SurfaceCurvature::VT_ID, Id, 0);
  }
  void add_CompId(flatbuffers::Offset<flatbuffers::String> CompId) {
    fbb_.AddOffset(SurfaceCurvature::VT_COMPID, CompId);
  }
  void add_Points(flatbuffers::Offset<flatbuffers::Vector<double>> Points) {
    fbb_.AddOffset(SurfaceCurvature::VT_POINTS, Points);
  }
  void add_Triangles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Triangles) {
    fbb_.AddOffset(SurfaceCurvature::VT_TRIANGLES, Triangles);
  }
  void add_MinCurcature(flatbuffers::Offset<flatbuffers::Vector<double>> MinCurcature) {
    fbb_.AddOffset(SurfaceCurvature::VT_MINCURCATURE, MinCurcature);
  }
  void add_MaxCurcature(flatbuffers::Offset<flatbuffers::Vector<double>> MaxCurcature) {
    fbb_.AddOffset(SurfaceCurvature::VT_MAXCURCATURE, MaxCurcature);
  }
  void add_MeanCurcature(flatbuffers::Offset<flatbuffers::Vector<double>> MeanCurcature) {
    fbb_.AddOffset(SurfaceCurvature::VT_MEANCURCATURE, MeanCurcature);
  }
  void add_GaussCurcature(flatbuffers::Offset<flatbuffers::Vector<double>> GaussCurcature) {
    fbb_.AddOffset(SurfaceCurvature::VT_GAUSSCURCATURE, GaussCurcature);
  }
  explicit SurfaceCurvatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SurfaceCurvatureBuilder &operator=(const SurfaceCurvatureBuilder &);
  flatbuffers::Offset<SurfaceCurvature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SurfaceCurvature>(end);
    return o;
  }
};

inline flatbuffers::Offset<SurfaceCurvature> CreateSurfaceCurvature(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    flatbuffers::Offset<flatbuffers::String> CompId = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Points = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Triangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MinCurcature = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MaxCurcature = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> MeanCurcature = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> GaussCurcature = 0) {
  SurfaceCurvatureBuilder builder_(_fbb);
  builder_.add_GaussCurcature(GaussCurcature);
  builder_.add_MeanCurcature(MeanCurcature);
  builder_.add_MaxCurcature(MaxCurcature);
  builder_.add_MinCurcature(MinCurcature);
  builder_.add_Triangles(Triangles);
  builder_.add_Points(Points);
  builder_.add_CompId(CompId);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SurfaceCurvature> CreateSurfaceCurvatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    const char *CompId = nullptr,
    const std::vector<double> *Points = nullptr,
    const std::vector<int32_t> *Triangles = nullptr,
    const std::vector<double> *MinCurcature = nullptr,
    const std::vector<double> *MaxCurcature = nullptr,
    const std::vector<double> *MeanCurcature = nullptr,
    const std::vector<double> *GaussCurcature = nullptr) {
  auto CompId__ = CompId ? _fbb.CreateString(CompId) : 0;
  auto Points__ = Points ? _fbb.CreateVector<double>(*Points) : 0;
  auto Triangles__ = Triangles ? _fbb.CreateVector<int32_t>(*Triangles) : 0;
  auto MinCurcature__ = MinCurcature ? _fbb.CreateVector<double>(*MinCurcature) : 0;
  auto MaxCurcature__ = MaxCurcature ? _fbb.CreateVector<double>(*MaxCurcature) : 0;
  auto MeanCurcature__ = MeanCurcature ? _fbb.CreateVector<double>(*MeanCurcature) : 0;
  auto GaussCurcature__ = GaussCurcature ? _fbb.CreateVector<double>(*GaussCurcature) : 0;
  return FlatBufferDocSpace::CreateSurfaceCurvature(
      _fbb,
      Id,
      CompId__,
      Points__,
      Triangles__,
      MinCurcature__,
      MaxCurcature__,
      MeanCurcature__,
      GaussCurcature__);
}

struct SurfaceCurvatureData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SurfaceCurvatureDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SURFACECURVATURES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SurfaceCurvature>> *SurfaceCurvatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SurfaceCurvature>> *>(VT_SURFACECURVATURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SURFACECURVATURES) &&
           verifier.VerifyVector(SurfaceCurvatures()) &&
           verifier.VerifyVectorOfTables(SurfaceCurvatures()) &&
           verifier.EndTable();
  }
};

struct SurfaceCurvatureDataBuilder {
  typedef SurfaceCurvatureData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SurfaceCurvatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SurfaceCurvature>>> SurfaceCurvatures) {
    fbb_.AddOffset(SurfaceCurvatureData::VT_SURFACECURVATURES, SurfaceCurvatures);
  }
  explicit SurfaceCurvatureDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SurfaceCurvatureDataBuilder &operator=(const SurfaceCurvatureDataBuilder &);
  flatbuffers::Offset<SurfaceCurvatureData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SurfaceCurvatureData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SurfaceCurvatureData> CreateSurfaceCurvatureData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SurfaceCurvature>>> SurfaceCurvatures = 0) {
  SurfaceCurvatureDataBuilder builder_(_fbb);
  builder_.add_SurfaceCurvatures(SurfaceCurvatures);
  return builder_.Finish();
}

inline flatbuffers::Offset<SurfaceCurvatureData> CreateSurfaceCurvatureDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SurfaceCurvature>> *SurfaceCurvatures = nullptr) {
  auto SurfaceCurvatures__ = SurfaceCurvatures ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SurfaceCurvature>>(*SurfaceCurvatures) : 0;
  return FlatBufferDocSpace::CreateSurfaceCurvatureData(
      _fbb,
      SurfaceCurvatures__);
}

struct DraftAnalysis FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DraftAnalysisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_POINTS = 8,
    VT_TRIANGLES = 10,
    VT_COSVALUES = 12
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<double> *Points() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINTS);
  }
  const flatbuffers::Vector<int32_t> *Triangles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TRIANGLES);
  }
  const flatbuffers::Vector<double> *CosValues() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COSVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(Points()) &&
           VerifyOffset(verifier, VT_TRIANGLES) &&
           verifier.VerifyVector(Triangles()) &&
           VerifyOffset(verifier, VT_COSVALUES) &&
           verifier.VerifyVector(CosValues()) &&
           verifier.EndTable();
  }
};

struct DraftAnalysisBuilder {
  typedef DraftAnalysis Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(DraftAnalysis::VT_ID, Id, 0);
  }
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(DraftAnalysis::VT_TYPE, Type, 0);
  }
  void add_Points(flatbuffers::Offset<flatbuffers::Vector<double>> Points) {
    fbb_.AddOffset(DraftAnalysis::VT_POINTS, Points);
  }
  void add_Triangles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Triangles) {
    fbb_.AddOffset(DraftAnalysis::VT_TRIANGLES, Triangles);
  }
  void add_CosValues(flatbuffers::Offset<flatbuffers::Vector<double>> CosValues) {
    fbb_.AddOffset(DraftAnalysis::VT_COSVALUES, CosValues);
  }
  explicit DraftAnalysisBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DraftAnalysisBuilder &operator=(const DraftAnalysisBuilder &);
  flatbuffers::Offset<DraftAnalysis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DraftAnalysis>(end);
    return o;
  }
};

inline flatbuffers::Offset<DraftAnalysis> CreateDraftAnalysis(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    int32_t Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Points = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Triangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CosValues = 0) {
  DraftAnalysisBuilder builder_(_fbb);
  builder_.add_CosValues(CosValues);
  builder_.add_Triangles(Triangles);
  builder_.add_Points(Points);
  builder_.add_Type(Type);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DraftAnalysis> CreateDraftAnalysisDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    int32_t Type = 0,
    const std::vector<double> *Points = nullptr,
    const std::vector<int32_t> *Triangles = nullptr,
    const std::vector<double> *CosValues = nullptr) {
  auto Points__ = Points ? _fbb.CreateVector<double>(*Points) : 0;
  auto Triangles__ = Triangles ? _fbb.CreateVector<int32_t>(*Triangles) : 0;
  auto CosValues__ = CosValues ? _fbb.CreateVector<double>(*CosValues) : 0;
  return FlatBufferDocSpace::CreateDraftAnalysis(
      _fbb,
      Id,
      Type,
      Points__,
      Triangles__,
      CosValues__);
}

struct DraftAnalysisData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DraftAnalysisDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DRAFTANALYSISFACES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DraftAnalysis>> *DraftAnalysisFaces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DraftAnalysis>> *>(VT_DRAFTANALYSISFACES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DRAFTANALYSISFACES) &&
           verifier.VerifyVector(DraftAnalysisFaces()) &&
           verifier.VerifyVectorOfTables(DraftAnalysisFaces()) &&
           verifier.EndTable();
  }
};

struct DraftAnalysisDataBuilder {
  typedef DraftAnalysisData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DraftAnalysisFaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DraftAnalysis>>> DraftAnalysisFaces) {
    fbb_.AddOffset(DraftAnalysisData::VT_DRAFTANALYSISFACES, DraftAnalysisFaces);
  }
  explicit DraftAnalysisDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DraftAnalysisDataBuilder &operator=(const DraftAnalysisDataBuilder &);
  flatbuffers::Offset<DraftAnalysisData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DraftAnalysisData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DraftAnalysisData> CreateDraftAnalysisData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DraftAnalysis>>> DraftAnalysisFaces = 0) {
  DraftAnalysisDataBuilder builder_(_fbb);
  builder_.add_DraftAnalysisFaces(DraftAnalysisFaces);
  return builder_.Finish();
}

inline flatbuffers::Offset<DraftAnalysisData> CreateDraftAnalysisDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DraftAnalysis>> *DraftAnalysisFaces = nullptr) {
  auto DraftAnalysisFaces__ = DraftAnalysisFaces ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DraftAnalysis>>(*DraftAnalysisFaces) : 0;
  return FlatBufferDocSpace::CreateDraftAnalysisData(
      _fbb,
      DraftAnalysisFaces__);
}

struct ThicknessData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ThicknessDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FACEID = 4,
    VT_VERTICES = 6,
    VT_INDICES = 8,
    VT_TRITHICKNESS = 10,
    VT_PNTTHICKNESS = 12
  };
  int32_t FaceId() const {
    return GetField<int32_t>(VT_FACEID, 0);
  }
  const flatbuffers::Vector<double> *Vertices() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VERTICES);
  }
  const flatbuffers::Vector<int32_t> *Indices() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INDICES);
  }
  const flatbuffers::Vector<double> *TriThickness() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_TRITHICKNESS);
  }
  const flatbuffers::Vector<double> *PntThickness() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PNTTHICKNESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FACEID) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyVector(Vertices()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(Indices()) &&
           VerifyOffset(verifier, VT_TRITHICKNESS) &&
           verifier.VerifyVector(TriThickness()) &&
           VerifyOffset(verifier, VT_PNTTHICKNESS) &&
           verifier.VerifyVector(PntThickness()) &&
           verifier.EndTable();
  }
};

struct ThicknessDataBuilder {
  typedef ThicknessData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FaceId(int32_t FaceId) {
    fbb_.AddElement<int32_t>(ThicknessData::VT_FACEID, FaceId, 0);
  }
  void add_Vertices(flatbuffers::Offset<flatbuffers::Vector<double>> Vertices) {
    fbb_.AddOffset(ThicknessData::VT_VERTICES, Vertices);
  }
  void add_Indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Indices) {
    fbb_.AddOffset(ThicknessData::VT_INDICES, Indices);
  }
  void add_TriThickness(flatbuffers::Offset<flatbuffers::Vector<double>> TriThickness) {
    fbb_.AddOffset(ThicknessData::VT_TRITHICKNESS, TriThickness);
  }
  void add_PntThickness(flatbuffers::Offset<flatbuffers::Vector<double>> PntThickness) {
    fbb_.AddOffset(ThicknessData::VT_PNTTHICKNESS, PntThickness);
  }
  explicit ThicknessDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ThicknessDataBuilder &operator=(const ThicknessDataBuilder &);
  flatbuffers::Offset<ThicknessData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ThicknessData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ThicknessData> CreateThicknessData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t FaceId = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Vertices = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> TriThickness = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> PntThickness = 0) {
  ThicknessDataBuilder builder_(_fbb);
  builder_.add_PntThickness(PntThickness);
  builder_.add_TriThickness(TriThickness);
  builder_.add_Indices(Indices);
  builder_.add_Vertices(Vertices);
  builder_.add_FaceId(FaceId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ThicknessData> CreateThicknessDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t FaceId = 0,
    const std::vector<double> *Vertices = nullptr,
    const std::vector<int32_t> *Indices = nullptr,
    const std::vector<double> *TriThickness = nullptr,
    const std::vector<double> *PntThickness = nullptr) {
  auto Vertices__ = Vertices ? _fbb.CreateVector<double>(*Vertices) : 0;
  auto Indices__ = Indices ? _fbb.CreateVector<int32_t>(*Indices) : 0;
  auto TriThickness__ = TriThickness ? _fbb.CreateVector<double>(*TriThickness) : 0;
  auto PntThickness__ = PntThickness ? _fbb.CreateVector<double>(*PntThickness) : 0;
  return FlatBufferDocSpace::CreateThicknessData(
      _fbb,
      FaceId,
      Vertices__,
      Indices__,
      TriThickness__,
      PntThickness__);
}

struct ThicknessAnalysisData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ThicknessAnalysisDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THICKNESSDATAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ThicknessData>> *ThicknessDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ThicknessData>> *>(VT_THICKNESSDATAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THICKNESSDATAS) &&
           verifier.VerifyVector(ThicknessDatas()) &&
           verifier.VerifyVectorOfTables(ThicknessDatas()) &&
           verifier.EndTable();
  }
};

struct ThicknessAnalysisDataBuilder {
  typedef ThicknessAnalysisData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ThicknessDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ThicknessData>>> ThicknessDatas) {
    fbb_.AddOffset(ThicknessAnalysisData::VT_THICKNESSDATAS, ThicknessDatas);
  }
  explicit ThicknessAnalysisDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ThicknessAnalysisDataBuilder &operator=(const ThicknessAnalysisDataBuilder &);
  flatbuffers::Offset<ThicknessAnalysisData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ThicknessAnalysisData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ThicknessAnalysisData> CreateThicknessAnalysisData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ThicknessData>>> ThicknessDatas = 0) {
  ThicknessAnalysisDataBuilder builder_(_fbb);
  builder_.add_ThicknessDatas(ThicknessDatas);
  return builder_.Finish();
}

inline flatbuffers::Offset<ThicknessAnalysisData> CreateThicknessAnalysisDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ThicknessData>> *ThicknessDatas = nullptr) {
  auto ThicknessDatas__ = ThicknessDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ThicknessData>>(*ThicknessDatas) : 0;
  return FlatBufferDocSpace::CreateThicknessAnalysisData(
      _fbb,
      ThicknessDatas__);
}

struct CheckGap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CheckGapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCEID1 = 4,
    VT_INSTANCEID2 = 6,
    VT_POINT1 = 8,
    VT_POINT2 = 10,
    VT_DISTANCE = 12
  };
  const flatbuffers::String *InstanceId1() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID1);
  }
  const flatbuffers::String *InstanceId2() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID2);
  }
  const flatbuffers::Vector<double> *Point1() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINT1);
  }
  const flatbuffers::Vector<double> *Point2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINT2);
  }
  double Distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCEID1) &&
           verifier.VerifyString(InstanceId1()) &&
           VerifyOffset(verifier, VT_INSTANCEID2) &&
           verifier.VerifyString(InstanceId2()) &&
           VerifyOffset(verifier, VT_POINT1) &&
           verifier.VerifyVector(Point1()) &&
           VerifyOffset(verifier, VT_POINT2) &&
           verifier.VerifyVector(Point2()) &&
           VerifyField<double>(verifier, VT_DISTANCE) &&
           verifier.EndTable();
  }
};

struct CheckGapBuilder {
  typedef CheckGap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_InstanceId1(flatbuffers::Offset<flatbuffers::String> InstanceId1) {
    fbb_.AddOffset(CheckGap::VT_INSTANCEID1, InstanceId1);
  }
  void add_InstanceId2(flatbuffers::Offset<flatbuffers::String> InstanceId2) {
    fbb_.AddOffset(CheckGap::VT_INSTANCEID2, InstanceId2);
  }
  void add_Point1(flatbuffers::Offset<flatbuffers::Vector<double>> Point1) {
    fbb_.AddOffset(CheckGap::VT_POINT1, Point1);
  }
  void add_Point2(flatbuffers::Offset<flatbuffers::Vector<double>> Point2) {
    fbb_.AddOffset(CheckGap::VT_POINT2, Point2);
  }
  void add_Distance(double Distance) {
    fbb_.AddElement<double>(CheckGap::VT_DISTANCE, Distance, 0.0);
  }
  explicit CheckGapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CheckGapBuilder &operator=(const CheckGapBuilder &);
  flatbuffers::Offset<CheckGap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CheckGap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CheckGap> CreateCheckGap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> InstanceId1 = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Point1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Point2 = 0,
    double Distance = 0.0) {
  CheckGapBuilder builder_(_fbb);
  builder_.add_Distance(Distance);
  builder_.add_Point2(Point2);
  builder_.add_Point1(Point1);
  builder_.add_InstanceId2(InstanceId2);
  builder_.add_InstanceId1(InstanceId1);
  return builder_.Finish();
}

inline flatbuffers::Offset<CheckGap> CreateCheckGapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *InstanceId1 = nullptr,
    const char *InstanceId2 = nullptr,
    const std::vector<double> *Point1 = nullptr,
    const std::vector<double> *Point2 = nullptr,
    double Distance = 0.0) {
  auto InstanceId1__ = InstanceId1 ? _fbb.CreateString(InstanceId1) : 0;
  auto InstanceId2__ = InstanceId2 ? _fbb.CreateString(InstanceId2) : 0;
  auto Point1__ = Point1 ? _fbb.CreateVector<double>(*Point1) : 0;
  auto Point2__ = Point2 ? _fbb.CreateVector<double>(*Point2) : 0;
  return FlatBufferDocSpace::CreateCheckGap(
      _fbb,
      InstanceId1__,
      InstanceId2__,
      Point1__,
      Point2__,
      Distance);
}

struct CheckGapData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CheckGapDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUP = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CheckGap>> *Group() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CheckGap>> *>(VT_GROUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUP) &&
           verifier.VerifyVector(Group()) &&
           verifier.VerifyVectorOfTables(Group()) &&
           verifier.EndTable();
  }
};

struct CheckGapDataBuilder {
  typedef CheckGapData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Group(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CheckGap>>> Group) {
    fbb_.AddOffset(CheckGapData::VT_GROUP, Group);
  }
  explicit CheckGapDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CheckGapDataBuilder &operator=(const CheckGapDataBuilder &);
  flatbuffers::Offset<CheckGapData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CheckGapData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CheckGapData> CreateCheckGapData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CheckGap>>> Group = 0) {
  CheckGapDataBuilder builder_(_fbb);
  builder_.add_Group(Group);
  return builder_.Finish();
}

inline flatbuffers::Offset<CheckGapData> CreateCheckGapDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CheckGap>> *Group = nullptr) {
  auto Group__ = Group ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CheckGap>>(*Group) : 0;
  return FlatBufferDocSpace::CreateCheckGapData(
      _fbb,
      Group__);
}

struct TotalMassData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TotalMassDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MASS = 4,
    VT_UNCALNUMS = 6
  };
  double Mass() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  int32_t UnCalNums() const {
    return GetField<int32_t>(VT_UNCALNUMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MASS) &&
           VerifyField<int32_t>(verifier, VT_UNCALNUMS) &&
           verifier.EndTable();
  }
};

struct TotalMassDataBuilder {
  typedef TotalMassData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Mass(double Mass) {
    fbb_.AddElement<double>(TotalMassData::VT_MASS, Mass, 0.0);
  }
  void add_UnCalNums(int32_t UnCalNums) {
    fbb_.AddElement<int32_t>(TotalMassData::VT_UNCALNUMS, UnCalNums, 0);
  }
  explicit TotalMassDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TotalMassDataBuilder &operator=(const TotalMassDataBuilder &);
  flatbuffers::Offset<TotalMassData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TotalMassData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TotalMassData> CreateTotalMassData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double Mass = 0.0,
    int32_t UnCalNums = 0) {
  TotalMassDataBuilder builder_(_fbb);
  builder_.add_Mass(Mass);
  builder_.add_UnCalNums(UnCalNums);
  return builder_.Finish();
}

struct CheckVariableData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CheckVariableDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARNAMES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *VarNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VARNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARNAMES) &&
           verifier.VerifyVector(VarNames()) &&
           verifier.VerifyVectorOfStrings(VarNames()) &&
           verifier.EndTable();
  }
};

struct CheckVariableDataBuilder {
  typedef CheckVariableData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_VarNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> VarNames) {
    fbb_.AddOffset(CheckVariableData::VT_VARNAMES, VarNames);
  }
  explicit CheckVariableDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CheckVariableDataBuilder &operator=(const CheckVariableDataBuilder &);
  flatbuffers::Offset<CheckVariableData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CheckVariableData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CheckVariableData> CreateCheckVariableData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> VarNames = 0) {
  CheckVariableDataBuilder builder_(_fbb);
  builder_.add_VarNames(VarNames);
  return builder_.Finish();
}

inline flatbuffers::Offset<CheckVariableData> CreateCheckVariableDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *VarNames = nullptr) {
  auto VarNames__ = VarNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*VarNames) : 0;
  return FlatBufferDocSpace::CreateCheckVariableData(
      _fbb,
      VarNames__);
}

struct TubeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TubeDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TUBEINDEX = 4,
    VT_TUBENAME = 6,
    VT_PROTONAME = 8,
    VT_PROTOTYPE = 10,
    VT_AXISRAD = 12,
    VT_THICKNESS = 14,
    VT_OUTDIAM = 16,
    VT_DEVANG = 18,
    VT_CENTERPNT = 20,
    VT_ENDPNTS = 22
  };
  const flatbuffers::String *TubeIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_TUBEINDEX);
  }
  const flatbuffers::String *TubeName() const {
    return GetPointer<const flatbuffers::String *>(VT_TUBENAME);
  }
  const flatbuffers::String *ProtoName() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTONAME);
  }
  const flatbuffers::String *ProtoType() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOTYPE);
  }
  double AxisRad() const {
    return GetField<double>(VT_AXISRAD, 0.0);
  }
  double ThickNess() const {
    return GetField<double>(VT_THICKNESS, 0.0);
  }
  double OutDiam() const {
    return GetField<double>(VT_OUTDIAM, 0.0);
  }
  double DevAng() const {
    return GetField<double>(VT_DEVANG, 0.0);
  }
  const flatbuffers::Vector<double> *CenterPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CENTERPNT);
  }
  const flatbuffers::Vector<double> *EndPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDPNTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TUBEINDEX) &&
           verifier.VerifyString(TubeIndex()) &&
           VerifyOffset(verifier, VT_TUBENAME) &&
           verifier.VerifyString(TubeName()) &&
           VerifyOffset(verifier, VT_PROTONAME) &&
           verifier.VerifyString(ProtoName()) &&
           VerifyOffset(verifier, VT_PROTOTYPE) &&
           verifier.VerifyString(ProtoType()) &&
           VerifyField<double>(verifier, VT_AXISRAD) &&
           VerifyField<double>(verifier, VT_THICKNESS) &&
           VerifyField<double>(verifier, VT_OUTDIAM) &&
           VerifyField<double>(verifier, VT_DEVANG) &&
           VerifyOffset(verifier, VT_CENTERPNT) &&
           verifier.VerifyVector(CenterPnt()) &&
           VerifyOffset(verifier, VT_ENDPNTS) &&
           verifier.VerifyVector(EndPnts()) &&
           verifier.EndTable();
  }
};

struct TubeDataBuilder {
  typedef TubeData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TubeIndex(flatbuffers::Offset<flatbuffers::String> TubeIndex) {
    fbb_.AddOffset(TubeData::VT_TUBEINDEX, TubeIndex);
  }
  void add_TubeName(flatbuffers::Offset<flatbuffers::String> TubeName) {
    fbb_.AddOffset(TubeData::VT_TUBENAME, TubeName);
  }
  void add_ProtoName(flatbuffers::Offset<flatbuffers::String> ProtoName) {
    fbb_.AddOffset(TubeData::VT_PROTONAME, ProtoName);
  }
  void add_ProtoType(flatbuffers::Offset<flatbuffers::String> ProtoType) {
    fbb_.AddOffset(TubeData::VT_PROTOTYPE, ProtoType);
  }
  void add_AxisRad(double AxisRad) {
    fbb_.AddElement<double>(TubeData::VT_AXISRAD, AxisRad, 0.0);
  }
  void add_ThickNess(double ThickNess) {
    fbb_.AddElement<double>(TubeData::VT_THICKNESS, ThickNess, 0.0);
  }
  void add_OutDiam(double OutDiam) {
    fbb_.AddElement<double>(TubeData::VT_OUTDIAM, OutDiam, 0.0);
  }
  void add_DevAng(double DevAng) {
    fbb_.AddElement<double>(TubeData::VT_DEVANG, DevAng, 0.0);
  }
  void add_CenterPnt(flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt) {
    fbb_.AddOffset(TubeData::VT_CENTERPNT, CenterPnt);
  }
  void add_EndPnts(flatbuffers::Offset<flatbuffers::Vector<double>> EndPnts) {
    fbb_.AddOffset(TubeData::VT_ENDPNTS, EndPnts);
  }
  explicit TubeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TubeDataBuilder &operator=(const TubeDataBuilder &);
  flatbuffers::Offset<TubeData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TubeData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TubeData> CreateTubeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> TubeIndex = 0,
    flatbuffers::Offset<flatbuffers::String> TubeName = 0,
    flatbuffers::Offset<flatbuffers::String> ProtoName = 0,
    flatbuffers::Offset<flatbuffers::String> ProtoType = 0,
    double AxisRad = 0.0,
    double ThickNess = 0.0,
    double OutDiam = 0.0,
    double DevAng = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndPnts = 0) {
  TubeDataBuilder builder_(_fbb);
  builder_.add_DevAng(DevAng);
  builder_.add_OutDiam(OutDiam);
  builder_.add_ThickNess(ThickNess);
  builder_.add_AxisRad(AxisRad);
  builder_.add_EndPnts(EndPnts);
  builder_.add_CenterPnt(CenterPnt);
  builder_.add_ProtoType(ProtoType);
  builder_.add_ProtoName(ProtoName);
  builder_.add_TubeName(TubeName);
  builder_.add_TubeIndex(TubeIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<TubeData> CreateTubeDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *TubeIndex = nullptr,
    const char *TubeName = nullptr,
    const char *ProtoName = nullptr,
    const char *ProtoType = nullptr,
    double AxisRad = 0.0,
    double ThickNess = 0.0,
    double OutDiam = 0.0,
    double DevAng = 0.0,
    const std::vector<double> *CenterPnt = nullptr,
    const std::vector<double> *EndPnts = nullptr) {
  auto TubeIndex__ = TubeIndex ? _fbb.CreateString(TubeIndex) : 0;
  auto TubeName__ = TubeName ? _fbb.CreateString(TubeName) : 0;
  auto ProtoName__ = ProtoName ? _fbb.CreateString(ProtoName) : 0;
  auto ProtoType__ = ProtoType ? _fbb.CreateString(ProtoType) : 0;
  auto CenterPnt__ = CenterPnt ? _fbb.CreateVector<double>(*CenterPnt) : 0;
  auto EndPnts__ = EndPnts ? _fbb.CreateVector<double>(*EndPnts) : 0;
  return FlatBufferDocSpace::CreateTubeData(
      _fbb,
      TubeIndex__,
      TubeName__,
      ProtoName__,
      ProtoType__,
      AxisRad,
      ThickNess,
      OutDiam,
      DevAng,
      CenterPnt__,
      EndPnts__);
}

struct PipeDocData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PipeDocDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PIPEDOCINDEX = 4,
    VT_PIPELINE = 6
  };
  const flatbuffers::String *PipeDocIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_PIPEDOCINDEX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TubeData>> *PipeLine() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TubeData>> *>(VT_PIPELINE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PIPEDOCINDEX) &&
           verifier.VerifyString(PipeDocIndex()) &&
           VerifyOffset(verifier, VT_PIPELINE) &&
           verifier.VerifyVector(PipeLine()) &&
           verifier.VerifyVectorOfTables(PipeLine()) &&
           verifier.EndTable();
  }
};

struct PipeDocDataBuilder {
  typedef PipeDocData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PipeDocIndex(flatbuffers::Offset<flatbuffers::String> PipeDocIndex) {
    fbb_.AddOffset(PipeDocData::VT_PIPEDOCINDEX, PipeDocIndex);
  }
  void add_PipeLine(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TubeData>>> PipeLine) {
    fbb_.AddOffset(PipeDocData::VT_PIPELINE, PipeLine);
  }
  explicit PipeDocDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PipeDocDataBuilder &operator=(const PipeDocDataBuilder &);
  flatbuffers::Offset<PipeDocData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PipeDocData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PipeDocData> CreatePipeDocData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> PipeDocIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TubeData>>> PipeLine = 0) {
  PipeDocDataBuilder builder_(_fbb);
  builder_.add_PipeLine(PipeLine);
  builder_.add_PipeDocIndex(PipeDocIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<PipeDocData> CreatePipeDocDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *PipeDocIndex = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TubeData>> *PipeLine = nullptr) {
  auto PipeDocIndex__ = PipeDocIndex ? _fbb.CreateString(PipeDocIndex) : 0;
  auto PipeLine__ = PipeLine ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TubeData>>(*PipeLine) : 0;
  return FlatBufferDocSpace::CreatePipeDocData(
      _fbb,
      PipeDocIndex__,
      PipeLine__);
}

struct InstanceSuccessData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceSuccessDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOCID = 4,
    VT_VERSIONID = 6
  };
  const flatbuffers::String *DocId() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCID);
  }
  const flatbuffers::String *VersionId() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSIONID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOCID) &&
           verifier.VerifyString(DocId()) &&
           VerifyOffset(verifier, VT_VERSIONID) &&
           verifier.VerifyString(VersionId()) &&
           verifier.EndTable();
  }
};

struct InstanceSuccessDataBuilder {
  typedef InstanceSuccessData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DocId(flatbuffers::Offset<flatbuffers::String> DocId) {
    fbb_.AddOffset(InstanceSuccessData::VT_DOCID, DocId);
  }
  void add_VersionId(flatbuffers::Offset<flatbuffers::String> VersionId) {
    fbb_.AddOffset(InstanceSuccessData::VT_VERSIONID, VersionId);
  }
  explicit InstanceSuccessDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstanceSuccessDataBuilder &operator=(const InstanceSuccessDataBuilder &);
  flatbuffers::Offset<InstanceSuccessData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceSuccessData>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceSuccessData> CreateInstanceSuccessData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> DocId = 0,
    flatbuffers::Offset<flatbuffers::String> VersionId = 0) {
  InstanceSuccessDataBuilder builder_(_fbb);
  builder_.add_VersionId(VersionId);
  builder_.add_DocId(DocId);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstanceSuccessData> CreateInstanceSuccessDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *DocId = nullptr,
    const char *VersionId = nullptr) {
  auto DocId__ = DocId ? _fbb.CreateString(DocId) : 0;
  auto VersionId__ = VersionId ? _fbb.CreateString(VersionId) : 0;
  return FlatBufferDocSpace::CreateInstanceSuccessData(
      _fbb,
      DocId__,
      VersionId__);
}

struct InstanceFailData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceFailDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NUMBER = 6
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t Number() const {
    return GetField<int32_t>(VT_NUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_NUMBER) &&
           verifier.EndTable();
  }
};

struct InstanceFailDataBuilder {
  typedef InstanceFailData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(InstanceFailData::VT_NAME, Name);
  }
  void add_Number(int32_t Number) {
    fbb_.AddElement<int32_t>(InstanceFailData::VT_NUMBER, Number, 0);
  }
  explicit InstanceFailDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstanceFailDataBuilder &operator=(const InstanceFailDataBuilder &);
  flatbuffers::Offset<InstanceFailData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceFailData>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceFailData> CreateInstanceFailData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t Number = 0) {
  InstanceFailDataBuilder builder_(_fbb);
  builder_.add_Number(Number);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstanceFailData> CreateInstanceFailDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    int32_t Number = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  return FlatBufferDocSpace::CreateInstanceFailData(
      _fbb,
      Name__,
      Number);
}

struct InstanceInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESSINFOS = 4,
    VT_FAILINFOS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceSuccessData>> *SuccessInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceSuccessData>> *>(VT_SUCCESSINFOS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceFailData>> *FailInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceFailData>> *>(VT_FAILINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SUCCESSINFOS) &&
           verifier.VerifyVector(SuccessInfos()) &&
           verifier.VerifyVectorOfTables(SuccessInfos()) &&
           VerifyOffset(verifier, VT_FAILINFOS) &&
           verifier.VerifyVector(FailInfos()) &&
           verifier.VerifyVectorOfTables(FailInfos()) &&
           verifier.EndTable();
  }
};

struct InstanceInfoDataBuilder {
  typedef InstanceInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SuccessInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceSuccessData>>> SuccessInfos) {
    fbb_.AddOffset(InstanceInfoData::VT_SUCCESSINFOS, SuccessInfos);
  }
  void add_FailInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceFailData>>> FailInfos) {
    fbb_.AddOffset(InstanceInfoData::VT_FAILINFOS, FailInfos);
  }
  explicit InstanceInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstanceInfoDataBuilder &operator=(const InstanceInfoDataBuilder &);
  flatbuffers::Offset<InstanceInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceInfoData> CreateInstanceInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceSuccessData>>> SuccessInfos = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceFailData>>> FailInfos = 0) {
  InstanceInfoDataBuilder builder_(_fbb);
  builder_.add_FailInfos(FailInfos);
  builder_.add_SuccessInfos(SuccessInfos);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstanceInfoData> CreateInstanceInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceSuccessData>> *SuccessInfos = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::InstanceFailData>> *FailInfos = nullptr) {
  auto SuccessInfos__ = SuccessInfos ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::InstanceSuccessData>>(*SuccessInfos) : 0;
  auto FailInfos__ = FailInfos ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::InstanceFailData>>(*FailInfos) : 0;
  return FlatBufferDocSpace::CreateInstanceInfoData(
      _fbb,
      SuccessInfos__,
      FailInfos__);
}

struct ResultSolvePlane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultSolvePlaneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ELEMENTTYPE = 6,
    VT_EIDS = 8,
    VT_VIDS = 10,
    VT_VPOSITIONS = 12,
    VT_VDISPLACEMENTS = 14,
    VT_VSTRESS = 16,
    VT_MAXNODEDISPLACEMENT = 18,
    VT_MAXNODESTRESS = 20,
    VT_MINNODEDISPLACEMENT = 22,
    VT_MINNODESTRESS = 24,
    VT_INDICES = 26,
    VT_VSTRAIN = 28,
    VT_MAXNODESTRAIN = 30,
    VT_MINNODESTRAIN = 32
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t ElementType() const {
    return GetField<int32_t>(VT_ELEMENTTYPE, 0);
  }
  const flatbuffers::Vector<int32_t> *EIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EIDS);
  }
  const flatbuffers::Vector<int32_t> *VIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VIDS);
  }
  const flatbuffers::Vector<float> *VPositions() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VPOSITIONS);
  }
  const flatbuffers::Vector<float> *VDisplacements() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VDISPLACEMENTS);
  }
  const flatbuffers::Vector<float> *VStress() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VSTRESS);
  }
  float MaxNodeDisplacement() const {
    return GetField<float>(VT_MAXNODEDISPLACEMENT, 0.0f);
  }
  float MaxNodeStress() const {
    return GetField<float>(VT_MAXNODESTRESS, 0.0f);
  }
  float MinNodeDisplacement() const {
    return GetField<float>(VT_MINNODEDISPLACEMENT, 0.0f);
  }
  float MinNodeStress() const {
    return GetField<float>(VT_MINNODESTRESS, 0.0f);
  }
  const flatbuffers::Vector<int32_t> *Indices() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INDICES);
  }
  const flatbuffers::Vector<float> *VStrain() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VSTRAIN);
  }
  float MaxNodeStrain() const {
    return GetField<float>(VT_MAXNODESTRAIN, 0.0f);
  }
  float MinNodeStrain() const {
    return GetField<float>(VT_MINNODESTRAIN, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTTYPE) &&
           VerifyOffset(verifier, VT_EIDS) &&
           verifier.VerifyVector(EIds()) &&
           VerifyOffset(verifier, VT_VIDS) &&
           verifier.VerifyVector(VIds()) &&
           VerifyOffset(verifier, VT_VPOSITIONS) &&
           verifier.VerifyVector(VPositions()) &&
           VerifyOffset(verifier, VT_VDISPLACEMENTS) &&
           verifier.VerifyVector(VDisplacements()) &&
           VerifyOffset(verifier, VT_VSTRESS) &&
           verifier.VerifyVector(VStress()) &&
           VerifyField<float>(verifier, VT_MAXNODEDISPLACEMENT) &&
           VerifyField<float>(verifier, VT_MAXNODESTRESS) &&
           VerifyField<float>(verifier, VT_MINNODEDISPLACEMENT) &&
           VerifyField<float>(verifier, VT_MINNODESTRESS) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(Indices()) &&
           VerifyOffset(verifier, VT_VSTRAIN) &&
           verifier.VerifyVector(VStrain()) &&
           VerifyField<float>(verifier, VT_MAXNODESTRAIN) &&
           VerifyField<float>(verifier, VT_MINNODESTRAIN) &&
           verifier.EndTable();
  }
};

struct ResultSolvePlaneBuilder {
  typedef ResultSolvePlane Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(ResultSolvePlane::VT_ID, Id, 0);
  }
  void add_ElementType(int32_t ElementType) {
    fbb_.AddElement<int32_t>(ResultSolvePlane::VT_ELEMENTTYPE, ElementType, 0);
  }
  void add_EIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> EIds) {
    fbb_.AddOffset(ResultSolvePlane::VT_EIDS, EIds);
  }
  void add_VIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> VIds) {
    fbb_.AddOffset(ResultSolvePlane::VT_VIDS, VIds);
  }
  void add_VPositions(flatbuffers::Offset<flatbuffers::Vector<float>> VPositions) {
    fbb_.AddOffset(ResultSolvePlane::VT_VPOSITIONS, VPositions);
  }
  void add_VDisplacements(flatbuffers::Offset<flatbuffers::Vector<float>> VDisplacements) {
    fbb_.AddOffset(ResultSolvePlane::VT_VDISPLACEMENTS, VDisplacements);
  }
  void add_VStress(flatbuffers::Offset<flatbuffers::Vector<float>> VStress) {
    fbb_.AddOffset(ResultSolvePlane::VT_VSTRESS, VStress);
  }
  void add_MaxNodeDisplacement(float MaxNodeDisplacement) {
    fbb_.AddElement<float>(ResultSolvePlane::VT_MAXNODEDISPLACEMENT, MaxNodeDisplacement, 0.0f);
  }
  void add_MaxNodeStress(float MaxNodeStress) {
    fbb_.AddElement<float>(ResultSolvePlane::VT_MAXNODESTRESS, MaxNodeStress, 0.0f);
  }
  void add_MinNodeDisplacement(float MinNodeDisplacement) {
    fbb_.AddElement<float>(ResultSolvePlane::VT_MINNODEDISPLACEMENT, MinNodeDisplacement, 0.0f);
  }
  void add_MinNodeStress(float MinNodeStress) {
    fbb_.AddElement<float>(ResultSolvePlane::VT_MINNODESTRESS, MinNodeStress, 0.0f);
  }
  void add_Indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Indices) {
    fbb_.AddOffset(ResultSolvePlane::VT_INDICES, Indices);
  }
  void add_VStrain(flatbuffers::Offset<flatbuffers::Vector<float>> VStrain) {
    fbb_.AddOffset(ResultSolvePlane::VT_VSTRAIN, VStrain);
  }
  void add_MaxNodeStrain(float MaxNodeStrain) {
    fbb_.AddElement<float>(ResultSolvePlane::VT_MAXNODESTRAIN, MaxNodeStrain, 0.0f);
  }
  void add_MinNodeStrain(float MinNodeStrain) {
    fbb_.AddElement<float>(ResultSolvePlane::VT_MINNODESTRAIN, MinNodeStrain, 0.0f);
  }
  explicit ResultSolvePlaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResultSolvePlaneBuilder &operator=(const ResultSolvePlaneBuilder &);
  flatbuffers::Offset<ResultSolvePlane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResultSolvePlane>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResultSolvePlane> CreateResultSolvePlane(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    int32_t ElementType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> EIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> VIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> VPositions = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> VDisplacements = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> VStress = 0,
    float MaxNodeDisplacement = 0.0f,
    float MaxNodeStress = 0.0f,
    float MinNodeDisplacement = 0.0f,
    float MinNodeStress = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> VStrain = 0,
    float MaxNodeStrain = 0.0f,
    float MinNodeStrain = 0.0f) {
  ResultSolvePlaneBuilder builder_(_fbb);
  builder_.add_MinNodeStrain(MinNodeStrain);
  builder_.add_MaxNodeStrain(MaxNodeStrain);
  builder_.add_VStrain(VStrain);
  builder_.add_Indices(Indices);
  builder_.add_MinNodeStress(MinNodeStress);
  builder_.add_MinNodeDisplacement(MinNodeDisplacement);
  builder_.add_MaxNodeStress(MaxNodeStress);
  builder_.add_MaxNodeDisplacement(MaxNodeDisplacement);
  builder_.add_VStress(VStress);
  builder_.add_VDisplacements(VDisplacements);
  builder_.add_VPositions(VPositions);
  builder_.add_VIds(VIds);
  builder_.add_EIds(EIds);
  builder_.add_ElementType(ElementType);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResultSolvePlane> CreateResultSolvePlaneDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    int32_t ElementType = 0,
    const std::vector<int32_t> *EIds = nullptr,
    const std::vector<int32_t> *VIds = nullptr,
    const std::vector<float> *VPositions = nullptr,
    const std::vector<float> *VDisplacements = nullptr,
    const std::vector<float> *VStress = nullptr,
    float MaxNodeDisplacement = 0.0f,
    float MaxNodeStress = 0.0f,
    float MinNodeDisplacement = 0.0f,
    float MinNodeStress = 0.0f,
    const std::vector<int32_t> *Indices = nullptr,
    const std::vector<float> *VStrain = nullptr,
    float MaxNodeStrain = 0.0f,
    float MinNodeStrain = 0.0f) {
  auto EIds__ = EIds ? _fbb.CreateVector<int32_t>(*EIds) : 0;
  auto VIds__ = VIds ? _fbb.CreateVector<int32_t>(*VIds) : 0;
  auto VPositions__ = VPositions ? _fbb.CreateVector<float>(*VPositions) : 0;
  auto VDisplacements__ = VDisplacements ? _fbb.CreateVector<float>(*VDisplacements) : 0;
  auto VStress__ = VStress ? _fbb.CreateVector<float>(*VStress) : 0;
  auto Indices__ = Indices ? _fbb.CreateVector<int32_t>(*Indices) : 0;
  auto VStrain__ = VStrain ? _fbb.CreateVector<float>(*VStrain) : 0;
  return FlatBufferDocSpace::CreateResultSolvePlane(
      _fbb,
      Id,
      ElementType,
      EIds__,
      VIds__,
      VPositions__,
      VDisplacements__,
      VStress__,
      MaxNodeDisplacement,
      MaxNodeStress,
      MinNodeDisplacement,
      MinNodeStress,
      Indices__,
      VStrain__,
      MaxNodeStrain,
      MinNodeStrain);
}

struct StudySolveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StudySolveDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STUDYID = 4,
    VT_TYPE = 6,
    VT_PLANES = 8,
    VT_STATUS = 10,
    VT_PERCENT = 12,
    VT_ISCHECK = 14
  };
  int32_t StudyId() const {
    return GetField<int32_t>(VT_STUDYID, 0);
  }
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ResultSolvePlane>> *Planes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ResultSolvePlane>> *>(VT_PLANES);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  double Percent() const {
    return GetField<double>(VT_PERCENT, 0.0);
  }
  int32_t IsCheck() const {
    return GetField<int32_t>(VT_ISCHECK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STUDYID) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_PLANES) &&
           verifier.VerifyVector(Planes()) &&
           verifier.VerifyVectorOfTables(Planes()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<double>(verifier, VT_PERCENT) &&
           VerifyField<int32_t>(verifier, VT_ISCHECK) &&
           verifier.EndTable();
  }
};

struct StudySolveDataBuilder {
  typedef StudySolveData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_StudyId(int32_t StudyId) {
    fbb_.AddElement<int32_t>(StudySolveData::VT_STUDYID, StudyId, 0);
  }
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(StudySolveData::VT_TYPE, Type);
  }
  void add_Planes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ResultSolvePlane>>> Planes) {
    fbb_.AddOffset(StudySolveData::VT_PLANES, Planes);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(StudySolveData::VT_STATUS, Status, 0);
  }
  void add_Percent(double Percent) {
    fbb_.AddElement<double>(StudySolveData::VT_PERCENT, Percent, 0.0);
  }
  void add_IsCheck(int32_t IsCheck) {
    fbb_.AddElement<int32_t>(StudySolveData::VT_ISCHECK, IsCheck, 0);
  }
  explicit StudySolveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StudySolveDataBuilder &operator=(const StudySolveDataBuilder &);
  flatbuffers::Offset<StudySolveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StudySolveData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StudySolveData> CreateStudySolveData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t StudyId = 0,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ResultSolvePlane>>> Planes = 0,
    int32_t Status = 0,
    double Percent = 0.0,
    int32_t IsCheck = 0) {
  StudySolveDataBuilder builder_(_fbb);
  builder_.add_Percent(Percent);
  builder_.add_IsCheck(IsCheck);
  builder_.add_Status(Status);
  builder_.add_Planes(Planes);
  builder_.add_Type(Type);
  builder_.add_StudyId(StudyId);
  return builder_.Finish();
}

inline flatbuffers::Offset<StudySolveData> CreateStudySolveDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t StudyId = 0,
    const char *Type = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ResultSolvePlane>> *Planes = nullptr,
    int32_t Status = 0,
    double Percent = 0.0,
    int32_t IsCheck = 0) {
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto Planes__ = Planes ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ResultSolvePlane>>(*Planes) : 0;
  return FlatBufferDocSpace::CreateStudySolveData(
      _fbb,
      StudyId,
      Type__,
      Planes__,
      Status,
      Percent,
      IsCheck);
}

struct StudyReportData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StudyReportDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STUDYFID = 4,
    VT_REPORTDATA = 6
  };
  int32_t StudyFId() const {
    return GetField<int32_t>(VT_STUDYFID, 0);
  }
  const flatbuffers::String *ReportData() const {
    return GetPointer<const flatbuffers::String *>(VT_REPORTDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STUDYFID) &&
           VerifyOffset(verifier, VT_REPORTDATA) &&
           verifier.VerifyString(ReportData()) &&
           verifier.EndTable();
  }
};

struct StudyReportDataBuilder {
  typedef StudyReportData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_StudyFId(int32_t StudyFId) {
    fbb_.AddElement<int32_t>(StudyReportData::VT_STUDYFID, StudyFId, 0);
  }
  void add_ReportData(flatbuffers::Offset<flatbuffers::String> ReportData) {
    fbb_.AddOffset(StudyReportData::VT_REPORTDATA, ReportData);
  }
  explicit StudyReportDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StudyReportDataBuilder &operator=(const StudyReportDataBuilder &);
  flatbuffers::Offset<StudyReportData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StudyReportData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StudyReportData> CreateStudyReportData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t StudyFId = 0,
    flatbuffers::Offset<flatbuffers::String> ReportData = 0) {
  StudyReportDataBuilder builder_(_fbb);
  builder_.add_ReportData(ReportData);
  builder_.add_StudyFId(StudyFId);
  return builder_.Finish();
}

inline flatbuffers::Offset<StudyReportData> CreateStudyReportDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t StudyFId = 0,
    const char *ReportData = nullptr) {
  auto ReportData__ = ReportData ? _fbb.CreateString(ReportData) : 0;
  return FlatBufferDocSpace::CreateStudyReportData(
      _fbb,
      StudyFId,
      ReportData__);
}

struct BoundingBoxData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoundingBoxDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_P4 = 10,
    VT_P5 = 12,
    VT_P6 = 14,
    VT_P7 = 16,
    VT_P8 = 18,
    VT_H = 20,
    VT_L = 22,
    VT_W = 24,
    VT_V = 26
  };
  const flatbuffers::Vector<double> *P1() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P1);
  }
  const flatbuffers::Vector<double> *P2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P2);
  }
  const flatbuffers::Vector<double> *P3() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P3);
  }
  const flatbuffers::Vector<double> *P4() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P4);
  }
  const flatbuffers::Vector<double> *P5() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P5);
  }
  const flatbuffers::Vector<double> *P6() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P6);
  }
  const flatbuffers::Vector<double> *P7() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P7);
  }
  const flatbuffers::Vector<double> *P8() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P8);
  }
  double H() const {
    return GetField<double>(VT_H, 0.0);
  }
  double L() const {
    return GetField<double>(VT_L, 0.0);
  }
  double W() const {
    return GetField<double>(VT_W, 0.0);
  }
  double V() const {
    return GetField<double>(VT_V, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_P1) &&
           verifier.VerifyVector(P1()) &&
           VerifyOffset(verifier, VT_P2) &&
           verifier.VerifyVector(P2()) &&
           VerifyOffset(verifier, VT_P3) &&
           verifier.VerifyVector(P3()) &&
           VerifyOffset(verifier, VT_P4) &&
           verifier.VerifyVector(P4()) &&
           VerifyOffset(verifier, VT_P5) &&
           verifier.VerifyVector(P5()) &&
           VerifyOffset(verifier, VT_P6) &&
           verifier.VerifyVector(P6()) &&
           VerifyOffset(verifier, VT_P7) &&
           verifier.VerifyVector(P7()) &&
           VerifyOffset(verifier, VT_P8) &&
           verifier.VerifyVector(P8()) &&
           VerifyField<double>(verifier, VT_H) &&
           VerifyField<double>(verifier, VT_L) &&
           VerifyField<double>(verifier, VT_W) &&
           VerifyField<double>(verifier, VT_V) &&
           verifier.EndTable();
  }
};

struct BoundingBoxDataBuilder {
  typedef BoundingBoxData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_P1(flatbuffers::Offset<flatbuffers::Vector<double>> P1) {
    fbb_.AddOffset(BoundingBoxData::VT_P1, P1);
  }
  void add_P2(flatbuffers::Offset<flatbuffers::Vector<double>> P2) {
    fbb_.AddOffset(BoundingBoxData::VT_P2, P2);
  }
  void add_P3(flatbuffers::Offset<flatbuffers::Vector<double>> P3) {
    fbb_.AddOffset(BoundingBoxData::VT_P3, P3);
  }
  void add_P4(flatbuffers::Offset<flatbuffers::Vector<double>> P4) {
    fbb_.AddOffset(BoundingBoxData::VT_P4, P4);
  }
  void add_P5(flatbuffers::Offset<flatbuffers::Vector<double>> P5) {
    fbb_.AddOffset(BoundingBoxData::VT_P5, P5);
  }
  void add_P6(flatbuffers::Offset<flatbuffers::Vector<double>> P6) {
    fbb_.AddOffset(BoundingBoxData::VT_P6, P6);
  }
  void add_P7(flatbuffers::Offset<flatbuffers::Vector<double>> P7) {
    fbb_.AddOffset(BoundingBoxData::VT_P7, P7);
  }
  void add_P8(flatbuffers::Offset<flatbuffers::Vector<double>> P8) {
    fbb_.AddOffset(BoundingBoxData::VT_P8, P8);
  }
  void add_H(double H) {
    fbb_.AddElement<double>(BoundingBoxData::VT_H, H, 0.0);
  }
  void add_L(double L) {
    fbb_.AddElement<double>(BoundingBoxData::VT_L, L, 0.0);
  }
  void add_W(double W) {
    fbb_.AddElement<double>(BoundingBoxData::VT_W, W, 0.0);
  }
  void add_V(double V) {
    fbb_.AddElement<double>(BoundingBoxData::VT_V, V, 0.0);
  }
  explicit BoundingBoxDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoundingBoxDataBuilder &operator=(const BoundingBoxDataBuilder &);
  flatbuffers::Offset<BoundingBoxData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoundingBoxData>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoundingBoxData> CreateBoundingBoxData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> P1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> P2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> P3 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> P4 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> P5 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> P6 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> P7 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> P8 = 0,
    double H = 0.0,
    double L = 0.0,
    double W = 0.0,
    double V = 0.0) {
  BoundingBoxDataBuilder builder_(_fbb);
  builder_.add_V(V);
  builder_.add_W(W);
  builder_.add_L(L);
  builder_.add_H(H);
  builder_.add_P8(P8);
  builder_.add_P7(P7);
  builder_.add_P6(P6);
  builder_.add_P5(P5);
  builder_.add_P4(P4);
  builder_.add_P3(P3);
  builder_.add_P2(P2);
  builder_.add_P1(P1);
  return builder_.Finish();
}

inline flatbuffers::Offset<BoundingBoxData> CreateBoundingBoxDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *P1 = nullptr,
    const std::vector<double> *P2 = nullptr,
    const std::vector<double> *P3 = nullptr,
    const std::vector<double> *P4 = nullptr,
    const std::vector<double> *P5 = nullptr,
    const std::vector<double> *P6 = nullptr,
    const std::vector<double> *P7 = nullptr,
    const std::vector<double> *P8 = nullptr,
    double H = 0.0,
    double L = 0.0,
    double W = 0.0,
    double V = 0.0) {
  auto P1__ = P1 ? _fbb.CreateVector<double>(*P1) : 0;
  auto P2__ = P2 ? _fbb.CreateVector<double>(*P2) : 0;
  auto P3__ = P3 ? _fbb.CreateVector<double>(*P3) : 0;
  auto P4__ = P4 ? _fbb.CreateVector<double>(*P4) : 0;
  auto P5__ = P5 ? _fbb.CreateVector<double>(*P5) : 0;
  auto P6__ = P6 ? _fbb.CreateVector<double>(*P6) : 0;
  auto P7__ = P7 ? _fbb.CreateVector<double>(*P7) : 0;
  auto P8__ = P8 ? _fbb.CreateVector<double>(*P8) : 0;
  return FlatBufferDocSpace::CreateBoundingBoxData(
      _fbb,
      P1__,
      P2__,
      P3__,
      P4__,
      P5__,
      P6__,
      P7__,
      P8__,
      H,
      L,
      W,
      V);
}

struct TextureInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_D = 4,
    VT_FACEWIDTH = 6,
    VT_FACEHEIGHT = 8,
    VT_RADIUS = 10,
    VT_MATRIX = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>> *D() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>> *>(VT_D);
  }
  double FaceWidth() const {
    return GetField<double>(VT_FACEWIDTH, 0.0);
  }
  double FaceHeight() const {
    return GetField<double>(VT_FACEHEIGHT, 0.0);
  }
  double Radius() const {
    return GetField<double>(VT_RADIUS, 0.0);
  }
  const flatbuffers::Vector<double> *Matrix() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_MATRIX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyVector(D()) &&
           verifier.VerifyVectorOfTables(D()) &&
           VerifyField<double>(verifier, VT_FACEWIDTH) &&
           VerifyField<double>(verifier, VT_FACEHEIGHT) &&
           VerifyField<double>(verifier, VT_RADIUS) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyVector(Matrix()) &&
           verifier.EndTable();
  }
};

struct TextureInfoDataBuilder {
  typedef TextureInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_D(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>>> D) {
    fbb_.AddOffset(TextureInfoData::VT_D, D);
  }
  void add_FaceWidth(double FaceWidth) {
    fbb_.AddElement<double>(TextureInfoData::VT_FACEWIDTH, FaceWidth, 0.0);
  }
  void add_FaceHeight(double FaceHeight) {
    fbb_.AddElement<double>(TextureInfoData::VT_FACEHEIGHT, FaceHeight, 0.0);
  }
  void add_Radius(double Radius) {
    fbb_.AddElement<double>(TextureInfoData::VT_RADIUS, Radius, 0.0);
  }
  void add_Matrix(flatbuffers::Offset<flatbuffers::Vector<double>> Matrix) {
    fbb_.AddOffset(TextureInfoData::VT_MATRIX, Matrix);
  }
  explicit TextureInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureInfoDataBuilder &operator=(const TextureInfoDataBuilder &);
  flatbuffers::Offset<TextureInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureInfoData> CreateTextureInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>>> D = 0,
    double FaceWidth = 0.0,
    double FaceHeight = 0.0,
    double Radius = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> Matrix = 0) {
  TextureInfoDataBuilder builder_(_fbb);
  builder_.add_Radius(Radius);
  builder_.add_FaceHeight(FaceHeight);
  builder_.add_FaceWidth(FaceWidth);
  builder_.add_Matrix(Matrix);
  builder_.add_D(D);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextureInfoData> CreateTextureInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>> *D = nullptr,
    double FaceWidth = 0.0,
    double FaceHeight = 0.0,
    double Radius = 0.0,
    const std::vector<double> *Matrix = nullptr) {
  auto D__ = D ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DiscreteInforData>>(*D) : 0;
  auto Matrix__ = Matrix ? _fbb.CreateVector<double>(*Matrix) : 0;
  return FlatBufferDocSpace::CreateTextureInfoData(
      _fbb,
      D__,
      FaceWidth,
      FaceHeight,
      Radius,
      Matrix__);
}

struct SerializeInitData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerializeInitDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIALIZEINIT_TYPE = 4,
    VT_SERIALIZEINIT = 6,
    VT_PARAMDATA = 8
  };
  FlatBufferDocSpace::InitDataMessage SerializeInit_type() const {
    return static_cast<FlatBufferDocSpace::InitDataMessage>(GetField<uint8_t>(VT_SERIALIZEINIT_TYPE, 0));
  }
  const void *SerializeInit() const {
    return GetPointer<const void *>(VT_SERIALIZEINIT);
  }
  template<typename T> const T *SerializeInit_as() const;
  const FlatBufferDocSpace::InitDataForPart *SerializeInit_as_InitDataForPart() const {
    return SerializeInit_type() == FlatBufferDocSpace::InitDataMessage_InitDataForPart ? static_cast<const FlatBufferDocSpace::InitDataForPart *>(SerializeInit()) : nullptr;
  }
  const FlatBufferDocSpace::InitDataForAssembly *SerializeInit_as_InitDataForAssembly() const {
    return SerializeInit_type() == FlatBufferDocSpace::InitDataMessage_InitDataForAssembly ? static_cast<const FlatBufferDocSpace::InitDataForAssembly *>(SerializeInit()) : nullptr;
  }
  const flatbuffers::String *ParamData() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SERIALIZEINIT_TYPE) &&
           VerifyOffset(verifier, VT_SERIALIZEINIT) &&
           VerifyInitDataMessage(verifier, SerializeInit(), SerializeInit_type()) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyString(ParamData()) &&
           verifier.EndTable();
  }
};

template<> inline const FlatBufferDocSpace::InitDataForPart *SerializeInitData::SerializeInit_as<FlatBufferDocSpace::InitDataForPart>() const {
  return SerializeInit_as_InitDataForPart();
}

template<> inline const FlatBufferDocSpace::InitDataForAssembly *SerializeInitData::SerializeInit_as<FlatBufferDocSpace::InitDataForAssembly>() const {
  return SerializeInit_as_InitDataForAssembly();
}

struct SerializeInitDataBuilder {
  typedef SerializeInitData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SerializeInit_type(FlatBufferDocSpace::InitDataMessage SerializeInit_type) {
    fbb_.AddElement<uint8_t>(SerializeInitData::VT_SERIALIZEINIT_TYPE, static_cast<uint8_t>(SerializeInit_type), 0);
  }
  void add_SerializeInit(flatbuffers::Offset<void> SerializeInit) {
    fbb_.AddOffset(SerializeInitData::VT_SERIALIZEINIT, SerializeInit);
  }
  void add_ParamData(flatbuffers::Offset<flatbuffers::String> ParamData) {
    fbb_.AddOffset(SerializeInitData::VT_PARAMDATA, ParamData);
  }
  explicit SerializeInitDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SerializeInitDataBuilder &operator=(const SerializeInitDataBuilder &);
  flatbuffers::Offset<SerializeInitData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerializeInitData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerializeInitData> CreateSerializeInitData(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::InitDataMessage SerializeInit_type = FlatBufferDocSpace::InitDataMessage_NONE,
    flatbuffers::Offset<void> SerializeInit = 0,
    flatbuffers::Offset<flatbuffers::String> ParamData = 0) {
  SerializeInitDataBuilder builder_(_fbb);
  builder_.add_ParamData(ParamData);
  builder_.add_SerializeInit(SerializeInit);
  builder_.add_SerializeInit_type(SerializeInit_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerializeInitData> CreateSerializeInitDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::InitDataMessage SerializeInit_type = FlatBufferDocSpace::InitDataMessage_NONE,
    flatbuffers::Offset<void> SerializeInit = 0,
    const char *ParamData = nullptr) {
  auto ParamData__ = ParamData ? _fbb.CreateString(ParamData) : 0;
  return FlatBufferDocSpace::CreateSerializeInitData(
      _fbb,
      SerializeInit_type,
      SerializeInit,
      ParamData__);
}

struct DrawingPreviewData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DrawingPreviewDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREVIEWELEMENT = 4,
    VT_PREVIEWTABLE = 6,
    VT_PREVIEWVIEW = 8,
    VT_PREVIEWLINE = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *PreviewElement() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_PREVIEWELEMENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *PreviewTable() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_PREVIEWTABLE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *PreviewView() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *>(VT_PREVIEWVIEW);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LineDataElement>> *PreviewLine() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LineDataElement>> *>(VT_PREVIEWLINE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PREVIEWELEMENT) &&
           verifier.VerifyVector(PreviewElement()) &&
           verifier.VerifyVectorOfTables(PreviewElement()) &&
           VerifyOffset(verifier, VT_PREVIEWTABLE) &&
           verifier.VerifyVector(PreviewTable()) &&
           verifier.VerifyVectorOfTables(PreviewTable()) &&
           VerifyOffset(verifier, VT_PREVIEWVIEW) &&
           verifier.VerifyVector(PreviewView()) &&
           verifier.VerifyVectorOfTables(PreviewView()) &&
           VerifyOffset(verifier, VT_PREVIEWLINE) &&
           verifier.VerifyVector(PreviewLine()) &&
           verifier.VerifyVectorOfTables(PreviewLine()) &&
           verifier.EndTable();
  }
};

struct DrawingPreviewDataBuilder {
  typedef DrawingPreviewData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PreviewElement(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> PreviewElement) {
    fbb_.AddOffset(DrawingPreviewData::VT_PREVIEWELEMENT, PreviewElement);
  }
  void add_PreviewTable(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> PreviewTable) {
    fbb_.AddOffset(DrawingPreviewData::VT_PREVIEWTABLE, PreviewTable);
  }
  void add_PreviewView(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>> PreviewView) {
    fbb_.AddOffset(DrawingPreviewData::VT_PREVIEWVIEW, PreviewView);
  }
  void add_PreviewLine(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LineDataElement>>> PreviewLine) {
    fbb_.AddOffset(DrawingPreviewData::VT_PREVIEWLINE, PreviewLine);
  }
  explicit DrawingPreviewDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DrawingPreviewDataBuilder &operator=(const DrawingPreviewDataBuilder &);
  flatbuffers::Offset<DrawingPreviewData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DrawingPreviewData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DrawingPreviewData> CreateDrawingPreviewData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> PreviewElement = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> PreviewTable = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>> PreviewView = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LineDataElement>>> PreviewLine = 0) {
  DrawingPreviewDataBuilder builder_(_fbb);
  builder_.add_PreviewLine(PreviewLine);
  builder_.add_PreviewView(PreviewView);
  builder_.add_PreviewTable(PreviewTable);
  builder_.add_PreviewElement(PreviewElement);
  return builder_.Finish();
}

inline flatbuffers::Offset<DrawingPreviewData> CreateDrawingPreviewDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *PreviewElement = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *PreviewTable = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *PreviewView = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::LineDataElement>> *PreviewLine = nullptr) {
  auto PreviewElement__ = PreviewElement ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*PreviewElement) : 0;
  auto PreviewTable__ = PreviewTable ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*PreviewTable) : 0;
  auto PreviewView__ = PreviewView ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>(*PreviewView) : 0;
  auto PreviewLine__ = PreviewLine ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::LineDataElement>>(*PreviewLine) : 0;
  return FlatBufferDocSpace::CreateDrawingPreviewData(
      _fbb,
      PreviewElement__,
      PreviewTable__,
      PreviewView__,
      PreviewLine__);
}

struct SelectLine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectLineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTA = 4,
    VT_RADIUS = 6,
    VT_ANGLE = 8
  };
  const flatbuffers::Vector<double> *PointA() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINTA);
  }
  double Radius() const {
    return GetField<double>(VT_RADIUS, 0.0);
  }
  double Angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTA) &&
           verifier.VerifyVector(PointA()) &&
           VerifyField<double>(verifier, VT_RADIUS) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           verifier.EndTable();
  }
};

struct SelectLineBuilder {
  typedef SelectLine Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PointA(flatbuffers::Offset<flatbuffers::Vector<double>> PointA) {
    fbb_.AddOffset(SelectLine::VT_POINTA, PointA);
  }
  void add_Radius(double Radius) {
    fbb_.AddElement<double>(SelectLine::VT_RADIUS, Radius, 0.0);
  }
  void add_Angle(double Angle) {
    fbb_.AddElement<double>(SelectLine::VT_ANGLE, Angle, 0.0);
  }
  explicit SelectLineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectLineBuilder &operator=(const SelectLineBuilder &);
  flatbuffers::Offset<SelectLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectLine>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectLine> CreateSelectLine(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> PointA = 0,
    double Radius = 0.0,
    double Angle = 0.0) {
  SelectLineBuilder builder_(_fbb);
  builder_.add_Angle(Angle);
  builder_.add_Radius(Radius);
  builder_.add_PointA(PointA);
  return builder_.Finish();
}

inline flatbuffers::Offset<SelectLine> CreateSelectLineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *PointA = nullptr,
    double Radius = 0.0,
    double Angle = 0.0) {
  auto PointA__ = PointA ? _fbb.CreateVector<double>(*PointA) : 0;
  return FlatBufferDocSpace::CreateSelectLine(
      _fbb,
      PointA__,
      Radius,
      Angle);
}

struct SectionElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SectionElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARENTVIEWINDEX = 4,
    VT_SECTIONVIEWINDEX = 6,
    VT_ARROWLINETYPE = 8,
    VT_SELECTLINES = 10,
    VT_SECTIONLINEPOS = 12,
    VT_SECTIONLINEWIDTHS = 14,
    VT_SECTIONLINETYPES = 16,
    VT_TEXTNAME1 = 18,
    VT_TEXTNAME2 = 20,
    VT_TEXTPOSITION1 = 22,
    VT_TEXTPOSITION2 = 24,
    VT_ARROWPOSITION1 = 26,
    VT_ARROWPOSITION2 = 28,
    VT_ARROWLINE1 = 30,
    VT_ARROWLINE2 = 32,
    VT_FONTNAME = 34,
    VT_FONTSIZE = 36,
    VT_ISITALIC = 38,
    VT_ISBOLD = 40,
    VT_ISDOCFONT = 42,
    VT_ISCUSTOMFONT = 44
  };
  const flatbuffers::String *ParentViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_PARENTVIEWINDEX);
  }
  const flatbuffers::String *SectionViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_SECTIONVIEWINDEX);
  }
  int32_t ArrowLineType() const {
    return GetField<int32_t>(VT_ARROWLINETYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SelectLine>> *SelectLines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SelectLine>> *>(VT_SELECTLINES);
  }
  const flatbuffers::Vector<double> *SectionLinePos() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_SECTIONLINEPOS);
  }
  const flatbuffers::Vector<int32_t> *SectionLineWidths() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SECTIONLINEWIDTHS);
  }
  const flatbuffers::Vector<int32_t> *SectionLineTypes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SECTIONLINETYPES);
  }
  const flatbuffers::String *TextName1() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTNAME1);
  }
  const flatbuffers::String *TextName2() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTNAME2);
  }
  const flatbuffers::Vector<double> *TextPosition1() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_TEXTPOSITION1);
  }
  const flatbuffers::Vector<double> *TextPosition2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_TEXTPOSITION2);
  }
  const flatbuffers::Vector<double> *ArrowPosition1() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ARROWPOSITION1);
  }
  const flatbuffers::Vector<double> *ArrowPosition2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ARROWPOSITION2);
  }
  const flatbuffers::Vector<double> *ArrowLine1() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ARROWLINE1);
  }
  const flatbuffers::Vector<double> *ArrowLine2() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ARROWLINE2);
  }
  const flatbuffers::String *FontName() const {
    return GetPointer<const flatbuffers::String *>(VT_FONTNAME);
  }
  double FontSize() const {
    return GetField<double>(VT_FONTSIZE, 0.0);
  }
  int32_t IsItalic() const {
    return GetField<int32_t>(VT_ISITALIC, 0);
  }
  int32_t IsBold() const {
    return GetField<int32_t>(VT_ISBOLD, 0);
  }
  int32_t IsDocFont() const {
    return GetField<int32_t>(VT_ISDOCFONT, 0);
  }
  int32_t IsCustomFont() const {
    return GetField<int32_t>(VT_ISCUSTOMFONT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARENTVIEWINDEX) &&
           verifier.VerifyString(ParentViewIndex()) &&
           VerifyOffset(verifier, VT_SECTIONVIEWINDEX) &&
           verifier.VerifyString(SectionViewIndex()) &&
           VerifyField<int32_t>(verifier, VT_ARROWLINETYPE) &&
           VerifyOffset(verifier, VT_SELECTLINES) &&
           verifier.VerifyVector(SelectLines()) &&
           verifier.VerifyVectorOfTables(SelectLines()) &&
           VerifyOffset(verifier, VT_SECTIONLINEPOS) &&
           verifier.VerifyVector(SectionLinePos()) &&
           VerifyOffset(verifier, VT_SECTIONLINEWIDTHS) &&
           verifier.VerifyVector(SectionLineWidths()) &&
           VerifyOffset(verifier, VT_SECTIONLINETYPES) &&
           verifier.VerifyVector(SectionLineTypes()) &&
           VerifyOffset(verifier, VT_TEXTNAME1) &&
           verifier.VerifyString(TextName1()) &&
           VerifyOffset(verifier, VT_TEXTNAME2) &&
           verifier.VerifyString(TextName2()) &&
           VerifyOffset(verifier, VT_TEXTPOSITION1) &&
           verifier.VerifyVector(TextPosition1()) &&
           VerifyOffset(verifier, VT_TEXTPOSITION2) &&
           verifier.VerifyVector(TextPosition2()) &&
           VerifyOffset(verifier, VT_ARROWPOSITION1) &&
           verifier.VerifyVector(ArrowPosition1()) &&
           VerifyOffset(verifier, VT_ARROWPOSITION2) &&
           verifier.VerifyVector(ArrowPosition2()) &&
           VerifyOffset(verifier, VT_ARROWLINE1) &&
           verifier.VerifyVector(ArrowLine1()) &&
           VerifyOffset(verifier, VT_ARROWLINE2) &&
           verifier.VerifyVector(ArrowLine2()) &&
           VerifyOffset(verifier, VT_FONTNAME) &&
           verifier.VerifyString(FontName()) &&
           VerifyField<double>(verifier, VT_FONTSIZE) &&
           VerifyField<int32_t>(verifier, VT_ISITALIC) &&
           VerifyField<int32_t>(verifier, VT_ISBOLD) &&
           VerifyField<int32_t>(verifier, VT_ISDOCFONT) &&
           VerifyField<int32_t>(verifier, VT_ISCUSTOMFONT) &&
           verifier.EndTable();
  }
};

struct SectionElementBuilder {
  typedef SectionElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ParentViewIndex(flatbuffers::Offset<flatbuffers::String> ParentViewIndex) {
    fbb_.AddOffset(SectionElement::VT_PARENTVIEWINDEX, ParentViewIndex);
  }
  void add_SectionViewIndex(flatbuffers::Offset<flatbuffers::String> SectionViewIndex) {
    fbb_.AddOffset(SectionElement::VT_SECTIONVIEWINDEX, SectionViewIndex);
  }
  void add_ArrowLineType(int32_t ArrowLineType) {
    fbb_.AddElement<int32_t>(SectionElement::VT_ARROWLINETYPE, ArrowLineType, 0);
  }
  void add_SelectLines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SelectLine>>> SelectLines) {
    fbb_.AddOffset(SectionElement::VT_SELECTLINES, SelectLines);
  }
  void add_SectionLinePos(flatbuffers::Offset<flatbuffers::Vector<double>> SectionLinePos) {
    fbb_.AddOffset(SectionElement::VT_SECTIONLINEPOS, SectionLinePos);
  }
  void add_SectionLineWidths(flatbuffers::Offset<flatbuffers::Vector<int32_t>> SectionLineWidths) {
    fbb_.AddOffset(SectionElement::VT_SECTIONLINEWIDTHS, SectionLineWidths);
  }
  void add_SectionLineTypes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> SectionLineTypes) {
    fbb_.AddOffset(SectionElement::VT_SECTIONLINETYPES, SectionLineTypes);
  }
  void add_TextName1(flatbuffers::Offset<flatbuffers::String> TextName1) {
    fbb_.AddOffset(SectionElement::VT_TEXTNAME1, TextName1);
  }
  void add_TextName2(flatbuffers::Offset<flatbuffers::String> TextName2) {
    fbb_.AddOffset(SectionElement::VT_TEXTNAME2, TextName2);
  }
  void add_TextPosition1(flatbuffers::Offset<flatbuffers::Vector<double>> TextPosition1) {
    fbb_.AddOffset(SectionElement::VT_TEXTPOSITION1, TextPosition1);
  }
  void add_TextPosition2(flatbuffers::Offset<flatbuffers::Vector<double>> TextPosition2) {
    fbb_.AddOffset(SectionElement::VT_TEXTPOSITION2, TextPosition2);
  }
  void add_ArrowPosition1(flatbuffers::Offset<flatbuffers::Vector<double>> ArrowPosition1) {
    fbb_.AddOffset(SectionElement::VT_ARROWPOSITION1, ArrowPosition1);
  }
  void add_ArrowPosition2(flatbuffers::Offset<flatbuffers::Vector<double>> ArrowPosition2) {
    fbb_.AddOffset(SectionElement::VT_ARROWPOSITION2, ArrowPosition2);
  }
  void add_ArrowLine1(flatbuffers::Offset<flatbuffers::Vector<double>> ArrowLine1) {
    fbb_.AddOffset(SectionElement::VT_ARROWLINE1, ArrowLine1);
  }
  void add_ArrowLine2(flatbuffers::Offset<flatbuffers::Vector<double>> ArrowLine2) {
    fbb_.AddOffset(SectionElement::VT_ARROWLINE2, ArrowLine2);
  }
  void add_FontName(flatbuffers::Offset<flatbuffers::String> FontName) {
    fbb_.AddOffset(SectionElement::VT_FONTNAME, FontName);
  }
  void add_FontSize(double FontSize) {
    fbb_.AddElement<double>(SectionElement::VT_FONTSIZE, FontSize, 0.0);
  }
  void add_IsItalic(int32_t IsItalic) {
    fbb_.AddElement<int32_t>(SectionElement::VT_ISITALIC, IsItalic, 0);
  }
  void add_IsBold(int32_t IsBold) {
    fbb_.AddElement<int32_t>(SectionElement::VT_ISBOLD, IsBold, 0);
  }
  void add_IsDocFont(int32_t IsDocFont) {
    fbb_.AddElement<int32_t>(SectionElement::VT_ISDOCFONT, IsDocFont, 0);
  }
  void add_IsCustomFont(int32_t IsCustomFont) {
    fbb_.AddElement<int32_t>(SectionElement::VT_ISCUSTOMFONT, IsCustomFont, 0);
  }
  explicit SectionElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SectionElementBuilder &operator=(const SectionElementBuilder &);
  flatbuffers::Offset<SectionElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SectionElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<SectionElement> CreateSectionElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ParentViewIndex = 0,
    flatbuffers::Offset<flatbuffers::String> SectionViewIndex = 0,
    int32_t ArrowLineType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SelectLine>>> SelectLines = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> SectionLinePos = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> SectionLineWidths = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> SectionLineTypes = 0,
    flatbuffers::Offset<flatbuffers::String> TextName1 = 0,
    flatbuffers::Offset<flatbuffers::String> TextName2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> TextPosition1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> TextPosition2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ArrowPosition1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ArrowPosition2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ArrowLine1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ArrowLine2 = 0,
    flatbuffers::Offset<flatbuffers::String> FontName = 0,
    double FontSize = 0.0,
    int32_t IsItalic = 0,
    int32_t IsBold = 0,
    int32_t IsDocFont = 0,
    int32_t IsCustomFont = 0) {
  SectionElementBuilder builder_(_fbb);
  builder_.add_FontSize(FontSize);
  builder_.add_IsCustomFont(IsCustomFont);
  builder_.add_IsDocFont(IsDocFont);
  builder_.add_IsBold(IsBold);
  builder_.add_IsItalic(IsItalic);
  builder_.add_FontName(FontName);
  builder_.add_ArrowLine2(ArrowLine2);
  builder_.add_ArrowLine1(ArrowLine1);
  builder_.add_ArrowPosition2(ArrowPosition2);
  builder_.add_ArrowPosition1(ArrowPosition1);
  builder_.add_TextPosition2(TextPosition2);
  builder_.add_TextPosition1(TextPosition1);
  builder_.add_TextName2(TextName2);
  builder_.add_TextName1(TextName1);
  builder_.add_SectionLineTypes(SectionLineTypes);
  builder_.add_SectionLineWidths(SectionLineWidths);
  builder_.add_SectionLinePos(SectionLinePos);
  builder_.add_SelectLines(SelectLines);
  builder_.add_ArrowLineType(ArrowLineType);
  builder_.add_SectionViewIndex(SectionViewIndex);
  builder_.add_ParentViewIndex(ParentViewIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<SectionElement> CreateSectionElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ParentViewIndex = nullptr,
    const char *SectionViewIndex = nullptr,
    int32_t ArrowLineType = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SelectLine>> *SelectLines = nullptr,
    const std::vector<double> *SectionLinePos = nullptr,
    const std::vector<int32_t> *SectionLineWidths = nullptr,
    const std::vector<int32_t> *SectionLineTypes = nullptr,
    const char *TextName1 = nullptr,
    const char *TextName2 = nullptr,
    const std::vector<double> *TextPosition1 = nullptr,
    const std::vector<double> *TextPosition2 = nullptr,
    const std::vector<double> *ArrowPosition1 = nullptr,
    const std::vector<double> *ArrowPosition2 = nullptr,
    const std::vector<double> *ArrowLine1 = nullptr,
    const std::vector<double> *ArrowLine2 = nullptr,
    const char *FontName = nullptr,
    double FontSize = 0.0,
    int32_t IsItalic = 0,
    int32_t IsBold = 0,
    int32_t IsDocFont = 0,
    int32_t IsCustomFont = 0) {
  auto ParentViewIndex__ = ParentViewIndex ? _fbb.CreateString(ParentViewIndex) : 0;
  auto SectionViewIndex__ = SectionViewIndex ? _fbb.CreateString(SectionViewIndex) : 0;
  auto SelectLines__ = SelectLines ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SelectLine>>(*SelectLines) : 0;
  auto SectionLinePos__ = SectionLinePos ? _fbb.CreateVector<double>(*SectionLinePos) : 0;
  auto SectionLineWidths__ = SectionLineWidths ? _fbb.CreateVector<int32_t>(*SectionLineWidths) : 0;
  auto SectionLineTypes__ = SectionLineTypes ? _fbb.CreateVector<int32_t>(*SectionLineTypes) : 0;
  auto TextName1__ = TextName1 ? _fbb.CreateString(TextName1) : 0;
  auto TextName2__ = TextName2 ? _fbb.CreateString(TextName2) : 0;
  auto TextPosition1__ = TextPosition1 ? _fbb.CreateVector<double>(*TextPosition1) : 0;
  auto TextPosition2__ = TextPosition2 ? _fbb.CreateVector<double>(*TextPosition2) : 0;
  auto ArrowPosition1__ = ArrowPosition1 ? _fbb.CreateVector<double>(*ArrowPosition1) : 0;
  auto ArrowPosition2__ = ArrowPosition2 ? _fbb.CreateVector<double>(*ArrowPosition2) : 0;
  auto ArrowLine1__ = ArrowLine1 ? _fbb.CreateVector<double>(*ArrowLine1) : 0;
  auto ArrowLine2__ = ArrowLine2 ? _fbb.CreateVector<double>(*ArrowLine2) : 0;
  auto FontName__ = FontName ? _fbb.CreateString(FontName) : 0;
  return FlatBufferDocSpace::CreateSectionElement(
      _fbb,
      ParentViewIndex__,
      SectionViewIndex__,
      ArrowLineType,
      SelectLines__,
      SectionLinePos__,
      SectionLineWidths__,
      SectionLineTypes__,
      TextName1__,
      TextName2__,
      TextPosition1__,
      TextPosition2__,
      ArrowPosition1__,
      ArrowPosition2__,
      ArrowLine1__,
      ArrowLine2__,
      FontName__,
      FontSize,
      IsItalic,
      IsBold,
      IsDocFont,
      IsCustomFont);
}

struct DraftSymbolEelement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DraftSymbolEelementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VIEWINDEX = 4,
    VT_AUXILIARYVIEWINDEX = 6,
    VT_ARROWID = 8,
    VT_ARROWTEXT = 10,
    VT_ARROWPOS = 12,
    VT_ARROWDIR = 14,
    VT_TEXTPOSITION = 16,
    VT_ISBOLD = 18,
    VT_ISITALIC = 20,
    VT_FONTNAME = 22,
    VT_FONTSIZE = 24,
    VT_ISDOCFONT = 26,
    VT_ISCUSTOMFONT = 28
  };
  const flatbuffers::String *ViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWINDEX);
  }
  const flatbuffers::String *AuxiliaryViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_AUXILIARYVIEWINDEX);
  }
  int32_t ArrowID() const {
    return GetField<int32_t>(VT_ARROWID, 0);
  }
  const flatbuffers::String *ArrowText() const {
    return GetPointer<const flatbuffers::String *>(VT_ARROWTEXT);
  }
  const flatbuffers::Vector<float> *ArrowPos() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ARROWPOS);
  }
  const flatbuffers::Vector<float> *ArrowDir() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ARROWDIR);
  }
  const flatbuffers::Vector<double> *TextPosition() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_TEXTPOSITION);
  }
  bool IsBold() const {
    return GetField<uint8_t>(VT_ISBOLD, 0) != 0;
  }
  bool IsItalic() const {
    return GetField<uint8_t>(VT_ISITALIC, 0) != 0;
  }
  const flatbuffers::String *FontName() const {
    return GetPointer<const flatbuffers::String *>(VT_FONTNAME);
  }
  double FontSize() const {
    return GetField<double>(VT_FONTSIZE, 0.0);
  }
  int32_t IsDocFont() const {
    return GetField<int32_t>(VT_ISDOCFONT, 0);
  }
  int32_t IsCustomFont() const {
    return GetField<int32_t>(VT_ISCUSTOMFONT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VIEWINDEX) &&
           verifier.VerifyString(ViewIndex()) &&
           VerifyOffset(verifier, VT_AUXILIARYVIEWINDEX) &&
           verifier.VerifyString(AuxiliaryViewIndex()) &&
           VerifyField<int32_t>(verifier, VT_ARROWID) &&
           VerifyOffset(verifier, VT_ARROWTEXT) &&
           verifier.VerifyString(ArrowText()) &&
           VerifyOffset(verifier, VT_ARROWPOS) &&
           verifier.VerifyVector(ArrowPos()) &&
           VerifyOffset(verifier, VT_ARROWDIR) &&
           verifier.VerifyVector(ArrowDir()) &&
           VerifyOffset(verifier, VT_TEXTPOSITION) &&
           verifier.VerifyVector(TextPosition()) &&
           VerifyField<uint8_t>(verifier, VT_ISBOLD) &&
           VerifyField<uint8_t>(verifier, VT_ISITALIC) &&
           VerifyOffset(verifier, VT_FONTNAME) &&
           verifier.VerifyString(FontName()) &&
           VerifyField<double>(verifier, VT_FONTSIZE) &&
           VerifyField<int32_t>(verifier, VT_ISDOCFONT) &&
           VerifyField<int32_t>(verifier, VT_ISCUSTOMFONT) &&
           verifier.EndTable();
  }
};

struct DraftSymbolEelementBuilder {
  typedef DraftSymbolEelement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ViewIndex(flatbuffers::Offset<flatbuffers::String> ViewIndex) {
    fbb_.AddOffset(DraftSymbolEelement::VT_VIEWINDEX, ViewIndex);
  }
  void add_AuxiliaryViewIndex(flatbuffers::Offset<flatbuffers::String> AuxiliaryViewIndex) {
    fbb_.AddOffset(DraftSymbolEelement::VT_AUXILIARYVIEWINDEX, AuxiliaryViewIndex);
  }
  void add_ArrowID(int32_t ArrowID) {
    fbb_.AddElement<int32_t>(DraftSymbolEelement::VT_ARROWID, ArrowID, 0);
  }
  void add_ArrowText(flatbuffers::Offset<flatbuffers::String> ArrowText) {
    fbb_.AddOffset(DraftSymbolEelement::VT_ARROWTEXT, ArrowText);
  }
  void add_ArrowPos(flatbuffers::Offset<flatbuffers::Vector<float>> ArrowPos) {
    fbb_.AddOffset(DraftSymbolEelement::VT_ARROWPOS, ArrowPos);
  }
  void add_ArrowDir(flatbuffers::Offset<flatbuffers::Vector<float>> ArrowDir) {
    fbb_.AddOffset(DraftSymbolEelement::VT_ARROWDIR, ArrowDir);
  }
  void add_TextPosition(flatbuffers::Offset<flatbuffers::Vector<double>> TextPosition) {
    fbb_.AddOffset(DraftSymbolEelement::VT_TEXTPOSITION, TextPosition);
  }
  void add_IsBold(bool IsBold) {
    fbb_.AddElement<uint8_t>(DraftSymbolEelement::VT_ISBOLD, static_cast<uint8_t>(IsBold), 0);
  }
  void add_IsItalic(bool IsItalic) {
    fbb_.AddElement<uint8_t>(DraftSymbolEelement::VT_ISITALIC, static_cast<uint8_t>(IsItalic), 0);
  }
  void add_FontName(flatbuffers::Offset<flatbuffers::String> FontName) {
    fbb_.AddOffset(DraftSymbolEelement::VT_FONTNAME, FontName);
  }
  void add_FontSize(double FontSize) {
    fbb_.AddElement<double>(DraftSymbolEelement::VT_FONTSIZE, FontSize, 0.0);
  }
  void add_IsDocFont(int32_t IsDocFont) {
    fbb_.AddElement<int32_t>(DraftSymbolEelement::VT_ISDOCFONT, IsDocFont, 0);
  }
  void add_IsCustomFont(int32_t IsCustomFont) {
    fbb_.AddElement<int32_t>(DraftSymbolEelement::VT_ISCUSTOMFONT, IsCustomFont, 0);
  }
  explicit DraftSymbolEelementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DraftSymbolEelementBuilder &operator=(const DraftSymbolEelementBuilder &);
  flatbuffers::Offset<DraftSymbolEelement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DraftSymbolEelement>(end);
    return o;
  }
};

inline flatbuffers::Offset<DraftSymbolEelement> CreateDraftSymbolEelement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ViewIndex = 0,
    flatbuffers::Offset<flatbuffers::String> AuxiliaryViewIndex = 0,
    int32_t ArrowID = 0,
    flatbuffers::Offset<flatbuffers::String> ArrowText = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> ArrowPos = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> ArrowDir = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> TextPosition = 0,
    bool IsBold = false,
    bool IsItalic = false,
    flatbuffers::Offset<flatbuffers::String> FontName = 0,
    double FontSize = 0.0,
    int32_t IsDocFont = 0,
    int32_t IsCustomFont = 0) {
  DraftSymbolEelementBuilder builder_(_fbb);
  builder_.add_FontSize(FontSize);
  builder_.add_IsCustomFont(IsCustomFont);
  builder_.add_IsDocFont(IsDocFont);
  builder_.add_FontName(FontName);
  builder_.add_TextPosition(TextPosition);
  builder_.add_ArrowDir(ArrowDir);
  builder_.add_ArrowPos(ArrowPos);
  builder_.add_ArrowText(ArrowText);
  builder_.add_ArrowID(ArrowID);
  builder_.add_AuxiliaryViewIndex(AuxiliaryViewIndex);
  builder_.add_ViewIndex(ViewIndex);
  builder_.add_IsItalic(IsItalic);
  builder_.add_IsBold(IsBold);
  return builder_.Finish();
}

inline flatbuffers::Offset<DraftSymbolEelement> CreateDraftSymbolEelementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ViewIndex = nullptr,
    const char *AuxiliaryViewIndex = nullptr,
    int32_t ArrowID = 0,
    const char *ArrowText = nullptr,
    const std::vector<float> *ArrowPos = nullptr,
    const std::vector<float> *ArrowDir = nullptr,
    const std::vector<double> *TextPosition = nullptr,
    bool IsBold = false,
    bool IsItalic = false,
    const char *FontName = nullptr,
    double FontSize = 0.0,
    int32_t IsDocFont = 0,
    int32_t IsCustomFont = 0) {
  auto ViewIndex__ = ViewIndex ? _fbb.CreateString(ViewIndex) : 0;
  auto AuxiliaryViewIndex__ = AuxiliaryViewIndex ? _fbb.CreateString(AuxiliaryViewIndex) : 0;
  auto ArrowText__ = ArrowText ? _fbb.CreateString(ArrowText) : 0;
  auto ArrowPos__ = ArrowPos ? _fbb.CreateVector<float>(*ArrowPos) : 0;
  auto ArrowDir__ = ArrowDir ? _fbb.CreateVector<float>(*ArrowDir) : 0;
  auto TextPosition__ = TextPosition ? _fbb.CreateVector<double>(*TextPosition) : 0;
  auto FontName__ = FontName ? _fbb.CreateString(FontName) : 0;
  return FlatBufferDocSpace::CreateDraftSymbolEelement(
      _fbb,
      ViewIndex__,
      AuxiliaryViewIndex__,
      ArrowID,
      ArrowText__,
      ArrowPos__,
      ArrowDir__,
      TextPosition__,
      IsBold,
      IsItalic,
      FontName__,
      FontSize,
      IsDocFont,
      IsCustomFont);
}

struct TableTextData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableTextDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const FlatBufferDocSpace::ElementData *Value() const {
    return GetPointer<const FlatBufferDocSpace::ElementData *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(Value()) &&
           verifier.EndTable();
  }
};

struct TableTextDataBuilder {
  typedef TableTextData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Value(flatbuffers::Offset<FlatBufferDocSpace::ElementData> Value) {
    fbb_.AddOffset(TableTextData::VT_VALUE, Value);
  }
  explicit TableTextDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableTextDataBuilder &operator=(const TableTextDataBuilder &);
  flatbuffers::Offset<TableTextData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableTextData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableTextData> CreateTableTextData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::ElementData> Value = 0) {
  TableTextDataBuilder builder_(_fbb);
  builder_.add_Value(Value);
  return builder_.Finish();
}

struct CellInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROW = 4,
    VT_COL = 6,
    VT_FONTSIZE = 8,
    VT_CONTENT = 10
  };
  int32_t Row() const {
    return GetField<int32_t>(VT_ROW, 0);
  }
  int32_t Col() const {
    return GetField<int32_t>(VT_COL, 0);
  }
  double FontSize() const {
    return GetField<double>(VT_FONTSIZE, 0.0);
  }
  const flatbuffers::String *Content() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROW) &&
           VerifyField<int32_t>(verifier, VT_COL) &&
           VerifyField<double>(verifier, VT_FONTSIZE) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(Content()) &&
           verifier.EndTable();
  }
};

struct CellInfoDataBuilder {
  typedef CellInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Row(int32_t Row) {
    fbb_.AddElement<int32_t>(CellInfoData::VT_ROW, Row, 0);
  }
  void add_Col(int32_t Col) {
    fbb_.AddElement<int32_t>(CellInfoData::VT_COL, Col, 0);
  }
  void add_FontSize(double FontSize) {
    fbb_.AddElement<double>(CellInfoData::VT_FONTSIZE, FontSize, 0.0);
  }
  void add_Content(flatbuffers::Offset<flatbuffers::String> Content) {
    fbb_.AddOffset(CellInfoData::VT_CONTENT, Content);
  }
  explicit CellInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellInfoDataBuilder &operator=(const CellInfoDataBuilder &);
  flatbuffers::Offset<CellInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellInfoData> CreateCellInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Row = 0,
    int32_t Col = 0,
    double FontSize = 0.0,
    flatbuffers::Offset<flatbuffers::String> Content = 0) {
  CellInfoDataBuilder builder_(_fbb);
  builder_.add_FontSize(FontSize);
  builder_.add_Content(Content);
  builder_.add_Col(Col);
  builder_.add_Row(Row);
  return builder_.Finish();
}

inline flatbuffers::Offset<CellInfoData> CreateCellInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Row = 0,
    int32_t Col = 0,
    double FontSize = 0.0,
    const char *Content = nullptr) {
  auto Content__ = Content ? _fbb.CreateString(Content) : 0;
  return FlatBufferDocSpace::CreateCellInfoData(
      _fbb,
      Row,
      Col,
      FontSize,
      Content__);
}

struct DelDrawingElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DelDrawingElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VIEWINDEX = 4,
    VT_ID = 6
  };
  const flatbuffers::String *ViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWINDEX);
  }
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VIEWINDEX) &&
           verifier.VerifyString(ViewIndex()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct DelDrawingElementBuilder {
  typedef DelDrawingElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ViewIndex(flatbuffers::Offset<flatbuffers::String> ViewIndex) {
    fbb_.AddOffset(DelDrawingElement::VT_VIEWINDEX, ViewIndex);
  }
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(DelDrawingElement::VT_ID, Id, 0);
  }
  explicit DelDrawingElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DelDrawingElementBuilder &operator=(const DelDrawingElementBuilder &);
  flatbuffers::Offset<DelDrawingElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DelDrawingElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<DelDrawingElement> CreateDelDrawingElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ViewIndex = 0,
    int32_t Id = 0) {
  DelDrawingElementBuilder builder_(_fbb);
  builder_.add_Id(Id);
  builder_.add_ViewIndex(ViewIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<DelDrawingElement> CreateDelDrawingElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ViewIndex = nullptr,
    int32_t Id = 0) {
  auto ViewIndex__ = ViewIndex ? _fbb.CreateString(ViewIndex) : 0;
  return FlatBufferDocSpace::CreateDelDrawingElement(
      _fbb,
      ViewIndex__,
      Id);
}

struct LinePnt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinePntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STARTPNT = 4,
    VT_ENDPNT = 6
  };
  const flatbuffers::Vector<double> *StartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_STARTPNT);
  }
  const flatbuffers::Vector<double> *EndPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ENDPNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STARTPNT) &&
           verifier.VerifyVector(StartPnt()) &&
           VerifyOffset(verifier, VT_ENDPNT) &&
           verifier.VerifyVector(EndPnt()) &&
           verifier.EndTable();
  }
};

struct LinePntBuilder {
  typedef LinePnt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_StartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt) {
    fbb_.AddOffset(LinePnt::VT_STARTPNT, StartPnt);
  }
  void add_EndPnt(flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt) {
    fbb_.AddOffset(LinePnt::VT_ENDPNT, EndPnt);
  }
  explicit LinePntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LinePntBuilder &operator=(const LinePntBuilder &);
  flatbuffers::Offset<LinePnt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinePnt>(end);
    return o;
  }
};

inline flatbuffers::Offset<LinePnt> CreateLinePnt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> StartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> EndPnt = 0) {
  LinePntBuilder builder_(_fbb);
  builder_.add_EndPnt(EndPnt);
  builder_.add_StartPnt(StartPnt);
  return builder_.Finish();
}

inline flatbuffers::Offset<LinePnt> CreateLinePntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *StartPnt = nullptr,
    const std::vector<double> *EndPnt = nullptr) {
  auto StartPnt__ = StartPnt ? _fbb.CreateVector<double>(*StartPnt) : 0;
  auto EndPnt__ = EndPnt ? _fbb.CreateVector<double>(*EndPnt) : 0;
  return FlatBufferDocSpace::CreateLinePnt(
      _fbb,
      StartPnt__,
      EndPnt__);
}

struct AddBreakPts FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddBreakPtsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINEPNTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LinePnt>> *LinePnts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LinePnt>> *>(VT_LINEPNTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LINEPNTS) &&
           verifier.VerifyVector(LinePnts()) &&
           verifier.VerifyVectorOfTables(LinePnts()) &&
           verifier.EndTable();
  }
};

struct AddBreakPtsBuilder {
  typedef AddBreakPts Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_LinePnts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LinePnt>>> LinePnts) {
    fbb_.AddOffset(AddBreakPts::VT_LINEPNTS, LinePnts);
  }
  explicit AddBreakPtsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBreakPtsBuilder &operator=(const AddBreakPtsBuilder &);
  flatbuffers::Offset<AddBreakPts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddBreakPts>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddBreakPts> CreateAddBreakPts(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LinePnt>>> LinePnts = 0) {
  AddBreakPtsBuilder builder_(_fbb);
  builder_.add_LinePnts(LinePnts);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddBreakPts> CreateAddBreakPtsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::LinePnt>> *LinePnts = nullptr) {
  auto LinePnts__ = LinePnts ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::LinePnt>>(*LinePnts) : 0;
  return FlatBufferDocSpace::CreateAddBreakPts(
      _fbb,
      LinePnts__);
}

struct SketchData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SketchDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUPNAME = 4,
    VT_GROUPID = 6,
    VT_SKETCHID = 8,
    VT_VISIBLE = 10,
    VT_PROJECTGEOMETRY = 12,
    VT_INSTANCEINDEX = 14,
    VT_IS3DSKETCH = 16
  };
  const flatbuffers::String *GroupName() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUPNAME);
  }
  int32_t GroupID() const {
    return GetField<int32_t>(VT_GROUPID, 0);
  }
  int32_t SketchID() const {
    return GetField<int32_t>(VT_SKETCHID, 0);
  }
  int32_t Visible() const {
    return GetField<int32_t>(VT_VISIBLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ProjectGeometry() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_PROJECTGEOMETRY);
  }
  const flatbuffers::String *InstanceIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEINDEX);
  }
  int32_t Is3DSketch() const {
    return GetField<int32_t>(VT_IS3DSKETCH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUPNAME) &&
           verifier.VerifyString(GroupName()) &&
           VerifyField<int32_t>(verifier, VT_GROUPID) &&
           VerifyField<int32_t>(verifier, VT_SKETCHID) &&
           VerifyField<int32_t>(verifier, VT_VISIBLE) &&
           VerifyOffset(verifier, VT_PROJECTGEOMETRY) &&
           verifier.VerifyVector(ProjectGeometry()) &&
           verifier.VerifyVectorOfTables(ProjectGeometry()) &&
           VerifyOffset(verifier, VT_INSTANCEINDEX) &&
           verifier.VerifyString(InstanceIndex()) &&
           VerifyField<int32_t>(verifier, VT_IS3DSKETCH) &&
           verifier.EndTable();
  }
};

struct SketchDataBuilder {
  typedef SketchData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GroupName(flatbuffers::Offset<flatbuffers::String> GroupName) {
    fbb_.AddOffset(SketchData::VT_GROUPNAME, GroupName);
  }
  void add_GroupID(int32_t GroupID) {
    fbb_.AddElement<int32_t>(SketchData::VT_GROUPID, GroupID, 0);
  }
  void add_SketchID(int32_t SketchID) {
    fbb_.AddElement<int32_t>(SketchData::VT_SKETCHID, SketchID, 0);
  }
  void add_Visible(int32_t Visible) {
    fbb_.AddElement<int32_t>(SketchData::VT_VISIBLE, Visible, 0);
  }
  void add_ProjectGeometry(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ProjectGeometry) {
    fbb_.AddOffset(SketchData::VT_PROJECTGEOMETRY, ProjectGeometry);
  }
  void add_InstanceIndex(flatbuffers::Offset<flatbuffers::String> InstanceIndex) {
    fbb_.AddOffset(SketchData::VT_INSTANCEINDEX, InstanceIndex);
  }
  void add_Is3DSketch(int32_t Is3DSketch) {
    fbb_.AddElement<int32_t>(SketchData::VT_IS3DSKETCH, Is3DSketch, 0);
  }
  explicit SketchDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SketchDataBuilder &operator=(const SketchDataBuilder &);
  flatbuffers::Offset<SketchData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SketchData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SketchData> CreateSketchData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> GroupName = 0,
    int32_t GroupID = 0,
    int32_t SketchID = 0,
    int32_t Visible = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ProjectGeometry = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceIndex = 0,
    int32_t Is3DSketch = 0) {
  SketchDataBuilder builder_(_fbb);
  builder_.add_Is3DSketch(Is3DSketch);
  builder_.add_InstanceIndex(InstanceIndex);
  builder_.add_ProjectGeometry(ProjectGeometry);
  builder_.add_Visible(Visible);
  builder_.add_SketchID(SketchID);
  builder_.add_GroupID(GroupID);
  builder_.add_GroupName(GroupName);
  return builder_.Finish();
}

inline flatbuffers::Offset<SketchData> CreateSketchDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *GroupName = nullptr,
    int32_t GroupID = 0,
    int32_t SketchID = 0,
    int32_t Visible = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ProjectGeometry = nullptr,
    const char *InstanceIndex = nullptr,
    int32_t Is3DSketch = 0) {
  auto GroupName__ = GroupName ? _fbb.CreateString(GroupName) : 0;
  auto ProjectGeometry__ = ProjectGeometry ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*ProjectGeometry) : 0;
  auto InstanceIndex__ = InstanceIndex ? _fbb.CreateString(InstanceIndex) : 0;
  return FlatBufferDocSpace::CreateSketchData(
      _fbb,
      GroupName__,
      GroupID,
      SketchID,
      Visible,
      ProjectGeometry__,
      InstanceIndex__,
      Is3DSketch);
}

struct BrokenSecElements FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BrokenSecElementsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BREAKSECINDEX = 4,
    VT_DEPTH = 6,
    VT_RELCVID = 8,
    VT_RELVIEW = 10,
    VT_REFPOINT = 12,
    VT_LOOPCV = 14,
    VT_NOTCUTALLINSTANCE = 16,
    VT_NOTCUTINSTANCEINDEXLIST = 18,
    VT_BREAKSECINDEXNAME = 20
  };
  int32_t BreakSecIndex() const {
    return GetField<int32_t>(VT_BREAKSECINDEX, 0);
  }
  double Depth() const {
    return GetField<double>(VT_DEPTH, 0.0);
  }
  int32_t RelCvID() const {
    return GetField<int32_t>(VT_RELCVID, 0);
  }
  const flatbuffers::String *RelView() const {
    return GetPointer<const flatbuffers::String *>(VT_RELVIEW);
  }
  const flatbuffers::Vector<double> *RefPoint() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_REFPOINT);
  }
  const flatbuffers::Vector<int32_t> *LoopCv() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LOOPCV);
  }
  bool NotCutAllInstance() const {
    return GetField<uint8_t>(VT_NOTCUTALLINSTANCE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *NotCutInstanceIndexList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NOTCUTINSTANCEINDEXLIST);
  }
  const flatbuffers::String *BreakSecIndexName() const {
    return GetPointer<const flatbuffers::String *>(VT_BREAKSECINDEXNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BREAKSECINDEX) &&
           VerifyField<double>(verifier, VT_DEPTH) &&
           VerifyField<int32_t>(verifier, VT_RELCVID) &&
           VerifyOffset(verifier, VT_RELVIEW) &&
           verifier.VerifyString(RelView()) &&
           VerifyOffset(verifier, VT_REFPOINT) &&
           verifier.VerifyVector(RefPoint()) &&
           VerifyOffset(verifier, VT_LOOPCV) &&
           verifier.VerifyVector(LoopCv()) &&
           VerifyField<uint8_t>(verifier, VT_NOTCUTALLINSTANCE) &&
           VerifyOffset(verifier, VT_NOTCUTINSTANCEINDEXLIST) &&
           verifier.VerifyVector(NotCutInstanceIndexList()) &&
           verifier.VerifyVectorOfStrings(NotCutInstanceIndexList()) &&
           VerifyOffset(verifier, VT_BREAKSECINDEXNAME) &&
           verifier.VerifyString(BreakSecIndexName()) &&
           verifier.EndTable();
  }
};

struct BrokenSecElementsBuilder {
  typedef BrokenSecElements Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_BreakSecIndex(int32_t BreakSecIndex) {
    fbb_.AddElement<int32_t>(BrokenSecElements::VT_BREAKSECINDEX, BreakSecIndex, 0);
  }
  void add_Depth(double Depth) {
    fbb_.AddElement<double>(BrokenSecElements::VT_DEPTH, Depth, 0.0);
  }
  void add_RelCvID(int32_t RelCvID) {
    fbb_.AddElement<int32_t>(BrokenSecElements::VT_RELCVID, RelCvID, 0);
  }
  void add_RelView(flatbuffers::Offset<flatbuffers::String> RelView) {
    fbb_.AddOffset(BrokenSecElements::VT_RELVIEW, RelView);
  }
  void add_RefPoint(flatbuffers::Offset<flatbuffers::Vector<double>> RefPoint) {
    fbb_.AddOffset(BrokenSecElements::VT_REFPOINT, RefPoint);
  }
  void add_LoopCv(flatbuffers::Offset<flatbuffers::Vector<int32_t>> LoopCv) {
    fbb_.AddOffset(BrokenSecElements::VT_LOOPCV, LoopCv);
  }
  void add_NotCutAllInstance(bool NotCutAllInstance) {
    fbb_.AddElement<uint8_t>(BrokenSecElements::VT_NOTCUTALLINSTANCE, static_cast<uint8_t>(NotCutAllInstance), 0);
  }
  void add_NotCutInstanceIndexList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> NotCutInstanceIndexList) {
    fbb_.AddOffset(BrokenSecElements::VT_NOTCUTINSTANCEINDEXLIST, NotCutInstanceIndexList);
  }
  void add_BreakSecIndexName(flatbuffers::Offset<flatbuffers::String> BreakSecIndexName) {
    fbb_.AddOffset(BrokenSecElements::VT_BREAKSECINDEXNAME, BreakSecIndexName);
  }
  explicit BrokenSecElementsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrokenSecElementsBuilder &operator=(const BrokenSecElementsBuilder &);
  flatbuffers::Offset<BrokenSecElements> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrokenSecElements>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrokenSecElements> CreateBrokenSecElements(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t BreakSecIndex = 0,
    double Depth = 0.0,
    int32_t RelCvID = 0,
    flatbuffers::Offset<flatbuffers::String> RelView = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> RefPoint = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> LoopCv = 0,
    bool NotCutAllInstance = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> NotCutInstanceIndexList = 0,
    flatbuffers::Offset<flatbuffers::String> BreakSecIndexName = 0) {
  BrokenSecElementsBuilder builder_(_fbb);
  builder_.add_Depth(Depth);
  builder_.add_BreakSecIndexName(BreakSecIndexName);
  builder_.add_NotCutInstanceIndexList(NotCutInstanceIndexList);
  builder_.add_LoopCv(LoopCv);
  builder_.add_RefPoint(RefPoint);
  builder_.add_RelView(RelView);
  builder_.add_RelCvID(RelCvID);
  builder_.add_BreakSecIndex(BreakSecIndex);
  builder_.add_NotCutAllInstance(NotCutAllInstance);
  return builder_.Finish();
}

inline flatbuffers::Offset<BrokenSecElements> CreateBrokenSecElementsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t BreakSecIndex = 0,
    double Depth = 0.0,
    int32_t RelCvID = 0,
    const char *RelView = nullptr,
    const std::vector<double> *RefPoint = nullptr,
    const std::vector<int32_t> *LoopCv = nullptr,
    bool NotCutAllInstance = false,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *NotCutInstanceIndexList = nullptr,
    const char *BreakSecIndexName = nullptr) {
  auto RelView__ = RelView ? _fbb.CreateString(RelView) : 0;
  auto RefPoint__ = RefPoint ? _fbb.CreateVector<double>(*RefPoint) : 0;
  auto LoopCv__ = LoopCv ? _fbb.CreateVector<int32_t>(*LoopCv) : 0;
  auto NotCutInstanceIndexList__ = NotCutInstanceIndexList ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*NotCutInstanceIndexList) : 0;
  auto BreakSecIndexName__ = BreakSecIndexName ? _fbb.CreateString(BreakSecIndexName) : 0;
  return FlatBufferDocSpace::CreateBrokenSecElements(
      _fbb,
      BreakSecIndex,
      Depth,
      RelCvID,
      RelView__,
      RefPoint__,
      LoopCv__,
      NotCutAllInstance,
      NotCutInstanceIndexList__,
      BreakSecIndexName__);
}

struct HatchEdgeElementsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HatchEdgeElementsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDELEMENT = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *AddElement() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_ADDELEMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDELEMENT) &&
           verifier.VerifyVector(AddElement()) &&
           verifier.VerifyVectorOfTables(AddElement()) &&
           verifier.EndTable();
  }
};

struct HatchEdgeElementsDataBuilder {
  typedef HatchEdgeElementsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AddElement(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> AddElement) {
    fbb_.AddOffset(HatchEdgeElementsData::VT_ADDELEMENT, AddElement);
  }
  explicit HatchEdgeElementsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HatchEdgeElementsDataBuilder &operator=(const HatchEdgeElementsDataBuilder &);
  flatbuffers::Offset<HatchEdgeElementsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HatchEdgeElementsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<HatchEdgeElementsData> CreateHatchEdgeElementsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> AddElement = 0) {
  HatchEdgeElementsDataBuilder builder_(_fbb);
  builder_.add_AddElement(AddElement);
  return builder_.Finish();
}

inline flatbuffers::Offset<HatchEdgeElementsData> CreateHatchEdgeElementsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *AddElement = nullptr) {
  auto AddElement__ = AddElement ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*AddElement) : 0;
  return FlatBufferDocSpace::CreateHatchEdgeElementsData(
      _fbb,
      AddElement__);
}

struct HatchInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HatchInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HATCHSTYLE = 4,
    VT_SCALE = 6,
    VT_ANGLE = 8,
    VT_FILLTYPE = 10,
    VT_REGIONTYPE = 12,
    VT_ISMATERIAL = 14,
    VT_INSTANCEID = 16
  };
  const flatbuffers::String *HatchStyle() const {
    return GetPointer<const flatbuffers::String *>(VT_HATCHSTYLE);
  }
  float Scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float Angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  int32_t FillType() const {
    return GetField<int32_t>(VT_FILLTYPE, 0);
  }
  int32_t RegionType() const {
    return GetField<int32_t>(VT_REGIONTYPE, 0);
  }
  int32_t IsMaterial() const {
    return GetField<int32_t>(VT_ISMATERIAL, 0);
  }
  const flatbuffers::String *InstanceId() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HATCHSTYLE) &&
           verifier.VerifyString(HatchStyle()) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_FILLTYPE) &&
           VerifyField<int32_t>(verifier, VT_REGIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_ISMATERIAL) &&
           VerifyOffset(verifier, VT_INSTANCEID) &&
           verifier.VerifyString(InstanceId()) &&
           verifier.EndTable();
  }
};

struct HatchInfoDataBuilder {
  typedef HatchInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HatchStyle(flatbuffers::Offset<flatbuffers::String> HatchStyle) {
    fbb_.AddOffset(HatchInfoData::VT_HATCHSTYLE, HatchStyle);
  }
  void add_Scale(float Scale) {
    fbb_.AddElement<float>(HatchInfoData::VT_SCALE, Scale, 0.0f);
  }
  void add_Angle(float Angle) {
    fbb_.AddElement<float>(HatchInfoData::VT_ANGLE, Angle, 0.0f);
  }
  void add_FillType(int32_t FillType) {
    fbb_.AddElement<int32_t>(HatchInfoData::VT_FILLTYPE, FillType, 0);
  }
  void add_RegionType(int32_t RegionType) {
    fbb_.AddElement<int32_t>(HatchInfoData::VT_REGIONTYPE, RegionType, 0);
  }
  void add_IsMaterial(int32_t IsMaterial) {
    fbb_.AddElement<int32_t>(HatchInfoData::VT_ISMATERIAL, IsMaterial, 0);
  }
  void add_InstanceId(flatbuffers::Offset<flatbuffers::String> InstanceId) {
    fbb_.AddOffset(HatchInfoData::VT_INSTANCEID, InstanceId);
  }
  explicit HatchInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HatchInfoDataBuilder &operator=(const HatchInfoDataBuilder &);
  flatbuffers::Offset<HatchInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HatchInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<HatchInfoData> CreateHatchInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> HatchStyle = 0,
    float Scale = 0.0f,
    float Angle = 0.0f,
    int32_t FillType = 0,
    int32_t RegionType = 0,
    int32_t IsMaterial = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId = 0) {
  HatchInfoDataBuilder builder_(_fbb);
  builder_.add_InstanceId(InstanceId);
  builder_.add_IsMaterial(IsMaterial);
  builder_.add_RegionType(RegionType);
  builder_.add_FillType(FillType);
  builder_.add_Angle(Angle);
  builder_.add_Scale(Scale);
  builder_.add_HatchStyle(HatchStyle);
  return builder_.Finish();
}

inline flatbuffers::Offset<HatchInfoData> CreateHatchInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *HatchStyle = nullptr,
    float Scale = 0.0f,
    float Angle = 0.0f,
    int32_t FillType = 0,
    int32_t RegionType = 0,
    int32_t IsMaterial = 0,
    const char *InstanceId = nullptr) {
  auto HatchStyle__ = HatchStyle ? _fbb.CreateString(HatchStyle) : 0;
  auto InstanceId__ = InstanceId ? _fbb.CreateString(InstanceId) : 0;
  return FlatBufferDocSpace::CreateHatchInfoData(
      _fbb,
      HatchStyle__,
      Scale,
      Angle,
      FillType,
      RegionType,
      IsMaterial,
      InstanceId__);
}

struct HatchRegionElements FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HatchRegionElementsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HATCHPROJECTLINE = 4,
    VT_HATCHPROJECTEDGES = 6,
    VT_HATCHINFO = 8,
    VT_BREAKSECINDEX = 10
  };
  const FlatBufferDocSpace::ElementData *HatchProjectLine() const {
    return GetPointer<const FlatBufferDocSpace::ElementData *>(VT_HATCHPROJECTLINE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchEdgeElementsData>> *HatchProjectEdges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchEdgeElementsData>> *>(VT_HATCHPROJECTEDGES);
  }
  const FlatBufferDocSpace::HatchInfoData *HatchInfo() const {
    return GetPointer<const FlatBufferDocSpace::HatchInfoData *>(VT_HATCHINFO);
  }
  int32_t BreakSecIndex() const {
    return GetField<int32_t>(VT_BREAKSECINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HATCHPROJECTLINE) &&
           verifier.VerifyTable(HatchProjectLine()) &&
           VerifyOffset(verifier, VT_HATCHPROJECTEDGES) &&
           verifier.VerifyVector(HatchProjectEdges()) &&
           verifier.VerifyVectorOfTables(HatchProjectEdges()) &&
           VerifyOffset(verifier, VT_HATCHINFO) &&
           verifier.VerifyTable(HatchInfo()) &&
           VerifyField<int32_t>(verifier, VT_BREAKSECINDEX) &&
           verifier.EndTable();
  }
};

struct HatchRegionElementsBuilder {
  typedef HatchRegionElements Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HatchProjectLine(flatbuffers::Offset<FlatBufferDocSpace::ElementData> HatchProjectLine) {
    fbb_.AddOffset(HatchRegionElements::VT_HATCHPROJECTLINE, HatchProjectLine);
  }
  void add_HatchProjectEdges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchEdgeElementsData>>> HatchProjectEdges) {
    fbb_.AddOffset(HatchRegionElements::VT_HATCHPROJECTEDGES, HatchProjectEdges);
  }
  void add_HatchInfo(flatbuffers::Offset<FlatBufferDocSpace::HatchInfoData> HatchInfo) {
    fbb_.AddOffset(HatchRegionElements::VT_HATCHINFO, HatchInfo);
  }
  void add_BreakSecIndex(int32_t BreakSecIndex) {
    fbb_.AddElement<int32_t>(HatchRegionElements::VT_BREAKSECINDEX, BreakSecIndex, 0);
  }
  explicit HatchRegionElementsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HatchRegionElementsBuilder &operator=(const HatchRegionElementsBuilder &);
  flatbuffers::Offset<HatchRegionElements> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HatchRegionElements>(end);
    return o;
  }
};

inline flatbuffers::Offset<HatchRegionElements> CreateHatchRegionElements(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::ElementData> HatchProjectLine = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchEdgeElementsData>>> HatchProjectEdges = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HatchInfoData> HatchInfo = 0,
    int32_t BreakSecIndex = 0) {
  HatchRegionElementsBuilder builder_(_fbb);
  builder_.add_BreakSecIndex(BreakSecIndex);
  builder_.add_HatchInfo(HatchInfo);
  builder_.add_HatchProjectEdges(HatchProjectEdges);
  builder_.add_HatchProjectLine(HatchProjectLine);
  return builder_.Finish();
}

inline flatbuffers::Offset<HatchRegionElements> CreateHatchRegionElementsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::ElementData> HatchProjectLine = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HatchEdgeElementsData>> *HatchProjectEdges = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::HatchInfoData> HatchInfo = 0,
    int32_t BreakSecIndex = 0) {
  auto HatchProjectEdges__ = HatchProjectEdges ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HatchEdgeElementsData>>(*HatchProjectEdges) : 0;
  return FlatBufferDocSpace::CreateHatchRegionElements(
      _fbb,
      HatchProjectLine,
      HatchProjectEdges__,
      HatchInfo,
      BreakSecIndex);
}

struct ExplodeViewData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExplodeViewDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_BOX = 6,
    VT_TRANSFORMINSTANCE = 8
  };
  const flatbuffers::String *Index() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX);
  }
  const flatbuffers::Vector<float> *Box() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BOX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *TransformInstance() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *>(VT_TRANSFORMINSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(Index()) &&
           VerifyOffset(verifier, VT_BOX) &&
           verifier.VerifyVector(Box()) &&
           VerifyOffset(verifier, VT_TRANSFORMINSTANCE) &&
           verifier.VerifyVector(TransformInstance()) &&
           verifier.VerifyVectorOfTables(TransformInstance()) &&
           verifier.EndTable();
  }
};

struct ExplodeViewDataBuilder {
  typedef ExplodeViewData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Index(flatbuffers::Offset<flatbuffers::String> Index) {
    fbb_.AddOffset(ExplodeViewData::VT_INDEX, Index);
  }
  void add_Box(flatbuffers::Offset<flatbuffers::Vector<float>> Box) {
    fbb_.AddOffset(ExplodeViewData::VT_BOX, Box);
  }
  void add_TransformInstance(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>> TransformInstance) {
    fbb_.AddOffset(ExplodeViewData::VT_TRANSFORMINSTANCE, TransformInstance);
  }
  explicit ExplodeViewDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExplodeViewDataBuilder &operator=(const ExplodeViewDataBuilder &);
  flatbuffers::Offset<ExplodeViewData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExplodeViewData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExplodeViewData> CreateExplodeViewData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Index = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Box = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>> TransformInstance = 0) {
  ExplodeViewDataBuilder builder_(_fbb);
  builder_.add_TransformInstance(TransformInstance);
  builder_.add_Box(Box);
  builder_.add_Index(Index);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExplodeViewData> CreateExplodeViewDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Index = nullptr,
    const std::vector<float> *Box = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *TransformInstance = nullptr) {
  auto Index__ = Index ? _fbb.CreateString(Index) : 0;
  auto Box__ = Box ? _fbb.CreateVector<float>(*Box) : 0;
  auto TransformInstance__ = TransformInstance ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>(*TransformInstance) : 0;
  return FlatBufferDocSpace::CreateExplodeViewData(
      _fbb,
      Index__,
      Box__,
      TransformInstance__);
}

struct AddHistInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddHistInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCEINDEX = 4,
    VT_FEATUREINDEX = 6
  };
  const flatbuffers::String *InstanceIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEINDEX);
  }
  const flatbuffers::String *FeatureIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_FEATUREINDEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCEINDEX) &&
           verifier.VerifyString(InstanceIndex()) &&
           VerifyOffset(verifier, VT_FEATUREINDEX) &&
           verifier.VerifyString(FeatureIndex()) &&
           verifier.EndTable();
  }
};

struct AddHistInfoBuilder {
  typedef AddHistInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_InstanceIndex(flatbuffers::Offset<flatbuffers::String> InstanceIndex) {
    fbb_.AddOffset(AddHistInfo::VT_INSTANCEINDEX, InstanceIndex);
  }
  void add_FeatureIndex(flatbuffers::Offset<flatbuffers::String> FeatureIndex) {
    fbb_.AddOffset(AddHistInfo::VT_FEATUREINDEX, FeatureIndex);
  }
  explicit AddHistInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddHistInfoBuilder &operator=(const AddHistInfoBuilder &);
  flatbuffers::Offset<AddHistInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddHistInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddHistInfo> CreateAddHistInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> InstanceIndex = 0,
    flatbuffers::Offset<flatbuffers::String> FeatureIndex = 0) {
  AddHistInfoBuilder builder_(_fbb);
  builder_.add_FeatureIndex(FeatureIndex);
  builder_.add_InstanceIndex(InstanceIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddHistInfo> CreateAddHistInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *InstanceIndex = nullptr,
    const char *FeatureIndex = nullptr) {
  auto InstanceIndex__ = InstanceIndex ? _fbb.CreateString(InstanceIndex) : 0;
  auto FeatureIndex__ = FeatureIndex ? _fbb.CreateString(FeatureIndex) : 0;
  return FlatBufferDocSpace::CreateAddHistInfo(
      _fbb,
      InstanceIndex__,
      FeatureIndex__);
}

struct AddSolidInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddSolidInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCEINDEX = 4,
    VT_SOLIDID = 6
  };
  const flatbuffers::String *InstanceIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEINDEX);
  }
  int32_t SolidId() const {
    return GetField<int32_t>(VT_SOLIDID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCEINDEX) &&
           verifier.VerifyString(InstanceIndex()) &&
           VerifyField<int32_t>(verifier, VT_SOLIDID) &&
           verifier.EndTable();
  }
};

struct AddSolidInfoBuilder {
  typedef AddSolidInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_InstanceIndex(flatbuffers::Offset<flatbuffers::String> InstanceIndex) {
    fbb_.AddOffset(AddSolidInfo::VT_INSTANCEINDEX, InstanceIndex);
  }
  void add_SolidId(int32_t SolidId) {
    fbb_.AddElement<int32_t>(AddSolidInfo::VT_SOLIDID, SolidId, 0);
  }
  explicit AddSolidInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddSolidInfoBuilder &operator=(const AddSolidInfoBuilder &);
  flatbuffers::Offset<AddSolidInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddSolidInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddSolidInfo> CreateAddSolidInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> InstanceIndex = 0,
    int32_t SolidId = 0) {
  AddSolidInfoBuilder builder_(_fbb);
  builder_.add_SolidId(SolidId);
  builder_.add_InstanceIndex(InstanceIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddSolidInfo> CreateAddSolidInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *InstanceIndex = nullptr,
    int32_t SolidId = 0) {
  auto InstanceIndex__ = InstanceIndex ? _fbb.CreateString(InstanceIndex) : 0;
  return FlatBufferDocSpace::CreateAddSolidInfo(
      _fbb,
      InstanceIndex__,
      SolidId);
}

struct ViewPropertyData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ViewPropertyDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HIDDENPARTLIST = 4,
    VT_HIDDENSOLIDLIST = 6,
    VT_SHOWHIDDENLINEPART = 8,
    VT_SHOWHIDDENLINESOLID = 10,
    VT_SHOWHIDDENLINEFEATURE = 12,
    VT_NOTCUTINSTANCEINDEXLIST = 14,
    VT_NOTCUTALLINSTANCE = 16,
    VT_NOTCUTFEATUREINDEXLIST = 18,
    VT_EXPLODEVIEW = 20
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *HiddenPartList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HIDDENPARTLIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>> *HiddenSolidList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>> *>(VT_HIDDENSOLIDLIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *ShowHiddenLinePart() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SHOWHIDDENLINEPART);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>> *ShowHiddenLineSolid() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>> *>(VT_SHOWHIDDENLINESOLID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>> *ShowHiddenLineFeature() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>> *>(VT_SHOWHIDDENLINEFEATURE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *NotCutInstanceIndexList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NOTCUTINSTANCEINDEXLIST);
  }
  bool NotCutAllInstance() const {
    return GetField<uint8_t>(VT_NOTCUTALLINSTANCE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>> *NotCutFeatureIndexList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>> *>(VT_NOTCUTFEATUREINDEXLIST);
  }
  const FlatBufferDocSpace::ExplodeViewData *ExplodeView() const {
    return GetPointer<const FlatBufferDocSpace::ExplodeViewData *>(VT_EXPLODEVIEW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HIDDENPARTLIST) &&
           verifier.VerifyVector(HiddenPartList()) &&
           verifier.VerifyVectorOfStrings(HiddenPartList()) &&
           VerifyOffset(verifier, VT_HIDDENSOLIDLIST) &&
           verifier.VerifyVector(HiddenSolidList()) &&
           verifier.VerifyVectorOfTables(HiddenSolidList()) &&
           VerifyOffset(verifier, VT_SHOWHIDDENLINEPART) &&
           verifier.VerifyVector(ShowHiddenLinePart()) &&
           verifier.VerifyVectorOfStrings(ShowHiddenLinePart()) &&
           VerifyOffset(verifier, VT_SHOWHIDDENLINESOLID) &&
           verifier.VerifyVector(ShowHiddenLineSolid()) &&
           verifier.VerifyVectorOfTables(ShowHiddenLineSolid()) &&
           VerifyOffset(verifier, VT_SHOWHIDDENLINEFEATURE) &&
           verifier.VerifyVector(ShowHiddenLineFeature()) &&
           verifier.VerifyVectorOfTables(ShowHiddenLineFeature()) &&
           VerifyOffset(verifier, VT_NOTCUTINSTANCEINDEXLIST) &&
           verifier.VerifyVector(NotCutInstanceIndexList()) &&
           verifier.VerifyVectorOfStrings(NotCutInstanceIndexList()) &&
           VerifyField<uint8_t>(verifier, VT_NOTCUTALLINSTANCE) &&
           VerifyOffset(verifier, VT_NOTCUTFEATUREINDEXLIST) &&
           verifier.VerifyVector(NotCutFeatureIndexList()) &&
           verifier.VerifyVectorOfTables(NotCutFeatureIndexList()) &&
           VerifyOffset(verifier, VT_EXPLODEVIEW) &&
           verifier.VerifyTable(ExplodeView()) &&
           verifier.EndTable();
  }
};

struct ViewPropertyDataBuilder {
  typedef ViewPropertyData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HiddenPartList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HiddenPartList) {
    fbb_.AddOffset(ViewPropertyData::VT_HIDDENPARTLIST, HiddenPartList);
  }
  void add_HiddenSolidList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>>> HiddenSolidList) {
    fbb_.AddOffset(ViewPropertyData::VT_HIDDENSOLIDLIST, HiddenSolidList);
  }
  void add_ShowHiddenLinePart(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ShowHiddenLinePart) {
    fbb_.AddOffset(ViewPropertyData::VT_SHOWHIDDENLINEPART, ShowHiddenLinePart);
  }
  void add_ShowHiddenLineSolid(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>>> ShowHiddenLineSolid) {
    fbb_.AddOffset(ViewPropertyData::VT_SHOWHIDDENLINESOLID, ShowHiddenLineSolid);
  }
  void add_ShowHiddenLineFeature(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>>> ShowHiddenLineFeature) {
    fbb_.AddOffset(ViewPropertyData::VT_SHOWHIDDENLINEFEATURE, ShowHiddenLineFeature);
  }
  void add_NotCutInstanceIndexList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> NotCutInstanceIndexList) {
    fbb_.AddOffset(ViewPropertyData::VT_NOTCUTINSTANCEINDEXLIST, NotCutInstanceIndexList);
  }
  void add_NotCutAllInstance(bool NotCutAllInstance) {
    fbb_.AddElement<uint8_t>(ViewPropertyData::VT_NOTCUTALLINSTANCE, static_cast<uint8_t>(NotCutAllInstance), 0);
  }
  void add_NotCutFeatureIndexList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>>> NotCutFeatureIndexList) {
    fbb_.AddOffset(ViewPropertyData::VT_NOTCUTFEATUREINDEXLIST, NotCutFeatureIndexList);
  }
  void add_ExplodeView(flatbuffers::Offset<FlatBufferDocSpace::ExplodeViewData> ExplodeView) {
    fbb_.AddOffset(ViewPropertyData::VT_EXPLODEVIEW, ExplodeView);
  }
  explicit ViewPropertyDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ViewPropertyDataBuilder &operator=(const ViewPropertyDataBuilder &);
  flatbuffers::Offset<ViewPropertyData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ViewPropertyData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ViewPropertyData> CreateViewPropertyData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HiddenPartList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>>> HiddenSolidList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ShowHiddenLinePart = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>>> ShowHiddenLineSolid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>>> ShowHiddenLineFeature = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> NotCutInstanceIndexList = 0,
    bool NotCutAllInstance = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>>> NotCutFeatureIndexList = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ExplodeViewData> ExplodeView = 0) {
  ViewPropertyDataBuilder builder_(_fbb);
  builder_.add_ExplodeView(ExplodeView);
  builder_.add_NotCutFeatureIndexList(NotCutFeatureIndexList);
  builder_.add_NotCutInstanceIndexList(NotCutInstanceIndexList);
  builder_.add_ShowHiddenLineFeature(ShowHiddenLineFeature);
  builder_.add_ShowHiddenLineSolid(ShowHiddenLineSolid);
  builder_.add_ShowHiddenLinePart(ShowHiddenLinePart);
  builder_.add_HiddenSolidList(HiddenSolidList);
  builder_.add_HiddenPartList(HiddenPartList);
  builder_.add_NotCutAllInstance(NotCutAllInstance);
  return builder_.Finish();
}

inline flatbuffers::Offset<ViewPropertyData> CreateViewPropertyDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *HiddenPartList = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>> *HiddenSolidList = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *ShowHiddenLinePart = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>> *ShowHiddenLineSolid = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>> *ShowHiddenLineFeature = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *NotCutInstanceIndexList = nullptr,
    bool NotCutAllInstance = false,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>> *NotCutFeatureIndexList = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::ExplodeViewData> ExplodeView = 0) {
  auto HiddenPartList__ = HiddenPartList ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*HiddenPartList) : 0;
  auto HiddenSolidList__ = HiddenSolidList ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>>(*HiddenSolidList) : 0;
  auto ShowHiddenLinePart__ = ShowHiddenLinePart ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*ShowHiddenLinePart) : 0;
  auto ShowHiddenLineSolid__ = ShowHiddenLineSolid ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AddSolidInfo>>(*ShowHiddenLineSolid) : 0;
  auto ShowHiddenLineFeature__ = ShowHiddenLineFeature ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>>(*ShowHiddenLineFeature) : 0;
  auto NotCutInstanceIndexList__ = NotCutInstanceIndexList ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*NotCutInstanceIndexList) : 0;
  auto NotCutFeatureIndexList__ = NotCutFeatureIndexList ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AddHistInfo>>(*NotCutFeatureIndexList) : 0;
  return FlatBufferDocSpace::CreateViewPropertyData(
      _fbb,
      HiddenPartList__,
      HiddenSolidList__,
      ShowHiddenLinePart__,
      ShowHiddenLineSolid__,
      ShowHiddenLineFeature__,
      NotCutInstanceIndexList__,
      NotCutAllInstance,
      NotCutFeatureIndexList__,
      ExplodeView);
}

struct TableInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLETYPE = 4,
    VT_ROWSNUM = 6,
    VT_COLUMNSNUM = 8,
    VT_RELVIEW = 10,
    VT_BALLOONINFOLIST = 12,
    VT_LOCK = 14,
    VT_LOCKTYPE = 16,
    VT_REVERSE = 18,
    VT_PARENTID = 20,
    VT_DELETED = 22,
    VT_ISSHOWTITLE = 24,
    VT_TABLEPOSITION = 26,
    VT_COLUMNWIDTHS = 28,
    VT_ROWSHEIGHTS = 30,
    VT_COLUMNTYPE = 32,
    VT_ROWTYPE = 34,
    VT_CELLISCONNECTED = 36,
    VT_CELLTEXTALIGN = 38,
    VT_VARIABLE = 40,
    VT_MERGECELLSINFO = 42,
    VT_NOLABELTYPE = 44,
    VT_ISDEPART = 46,
    VT_DEPARTTYPE = 48,
    VT_LOCKCOL = 50,
    VT_LOCKROW = 52,
    VT_ROWRELHI = 54,
    VT_BOMTYPE = 56,
    VT_HYPPROTOID = 58,
    VT_HYPINSTANCEID = 60,
    VT_DOCUMENTID = 62,
    VT_VERSIONID = 64,
    VT_HYPDOCUMENTID = 66,
    VT_HYPVERSIONID = 68,
    VT_ROWIDS = 70,
    VT_REVISIONIDS = 72,
    VT_ISACTIVESYMBOL = 74,
    VT_ISAUTOUPDATE = 76,
    VT_DEFAULTSYMBOLTYPE = 78,
    VT_CELLTEXT = 80,
    VT_CELL = 82,
    VT_ALLCOLTYPE = 84,
    VT_REFVIEWINDEX = 86,
    VT_ROWLABELFINDEX = 88,
    VT_SORTBYASSEMBLE = 90,
    VT_SORTBYSUBASSEMBLE = 92,
    VT_NOTCHANGEBALLOONINF = 94,
    VT_LAYER = 96,
    VT_COLOR = 98
  };
  int32_t TableType() const {
    return GetField<int32_t>(VT_TABLETYPE, 0);
  }
  int32_t RowsNum() const {
    return GetField<int32_t>(VT_ROWSNUM, 0);
  }
  int32_t ColumnsNum() const {
    return GetField<int32_t>(VT_COLUMNSNUM, 0);
  }
  const flatbuffers::String *RelView() const {
    return GetPointer<const flatbuffers::String *>(VT_RELVIEW);
  }
  const flatbuffers::Vector<int32_t> *balloonInfoList() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BALLOONINFOLIST);
  }
  bool Lock() const {
    return GetField<uint8_t>(VT_LOCK, 0) != 0;
  }
  int32_t LockType() const {
    return GetField<int32_t>(VT_LOCKTYPE, 0);
  }
  bool Reverse() const {
    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
  }
  const flatbuffers::String *ParentId() const {
    return GetPointer<const flatbuffers::String *>(VT_PARENTID);
  }
  bool Deleted() const {
    return GetField<uint8_t>(VT_DELETED, 0) != 0;
  }
  bool isShowTitle() const {
    return GetField<uint8_t>(VT_ISSHOWTITLE, 0) != 0;
  }
  const flatbuffers::Vector<float> *TablePosition() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TABLEPOSITION);
  }
  const flatbuffers::Vector<double> *ColumnWidths() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COLUMNWIDTHS);
  }
  const flatbuffers::Vector<double> *rowsHeights() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ROWSHEIGHTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *ColumnType() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNTYPE);
  }
  const flatbuffers::Vector<int32_t> *RowType() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ROWTYPE);
  }
  const flatbuffers::Vector<uint8_t> *CellIsConnected() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CELLISCONNECTED);
  }
  const flatbuffers::Vector<int32_t> *CellTextAlign() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CELLTEXTALIGN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CellVariableData>> *Variable() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CellVariableData>> *>(VT_VARIABLE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MergeCellsInfoData>> *MergeCellsInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MergeCellsInfoData>> *>(VT_MERGECELLSINFO);
  }
  int32_t NOLabelType() const {
    return GetField<int32_t>(VT_NOLABELTYPE, 0);
  }
  int32_t IsDepart() const {
    return GetField<int32_t>(VT_ISDEPART, 0);
  }
  int32_t DepartType() const {
    return GetField<int32_t>(VT_DEPARTTYPE, 0);
  }
  const flatbuffers::Vector<uint8_t> *LockCol() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LOCKCOL);
  }
  const flatbuffers::Vector<uint8_t> *LockRow() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LOCKROW);
  }
  const flatbuffers::Vector<int32_t> *RowRelHi() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ROWRELHI);
  }
  int32_t BOMType() const {
    return GetField<int32_t>(VT_BOMTYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *HypProtoId() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HYPPROTOID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *HypInstanceId() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HYPINSTANCEID);
  }
  const flatbuffers::String *DocumentId() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTID);
  }
  const flatbuffers::String *VersionId() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSIONID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *HypDocumentId() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HYPDOCUMENTID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *HypVersionId() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HYPVERSIONID);
  }
  const flatbuffers::Vector<int32_t> *RowIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ROWIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *RevisionIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_REVISIONIDS);
  }
  bool isActiveSymbol() const {
    return GetField<uint8_t>(VT_ISACTIVESYMBOL, 0) != 0;
  }
  bool isAutoUpdate() const {
    return GetField<uint8_t>(VT_ISAUTOUPDATE, 0) != 0;
  }
  int32_t defaultSymbolType() const {
    return GetField<int32_t>(VT_DEFAULTSYMBOLTYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TableTextData>> *CellText() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TableTextData>> *>(VT_CELLTEXT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CellInfoData>> *Cell() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CellInfoData>> *>(VT_CELL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *AllColType() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALLCOLTYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *RefViewIndex() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_REFVIEWINDEX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *RowLabelFIndex() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ROWLABELFINDEX);
  }
  int32_t SortByAssemble() const {
    return GetField<int32_t>(VT_SORTBYASSEMBLE, 0);
  }
  int32_t SortBySubAssemble() const {
    return GetField<int32_t>(VT_SORTBYSUBASSEMBLE, 0);
  }
  int32_t NotChangeBalloonInf() const {
    return GetField<int32_t>(VT_NOTCHANGEBALLOONINF, 0);
  }
  int32_t Layer() const {
    return GetField<int32_t>(VT_LAYER, 0);
  }
  int32_t Color() const {
    return GetField<int32_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TABLETYPE) &&
           VerifyField<int32_t>(verifier, VT_ROWSNUM) &&
           VerifyField<int32_t>(verifier, VT_COLUMNSNUM) &&
           VerifyOffset(verifier, VT_RELVIEW) &&
           verifier.VerifyString(RelView()) &&
           VerifyOffset(verifier, VT_BALLOONINFOLIST) &&
           verifier.VerifyVector(balloonInfoList()) &&
           VerifyField<uint8_t>(verifier, VT_LOCK) &&
           VerifyField<int32_t>(verifier, VT_LOCKTYPE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
           VerifyOffset(verifier, VT_PARENTID) &&
           verifier.VerifyString(ParentId()) &&
           VerifyField<uint8_t>(verifier, VT_DELETED) &&
           VerifyField<uint8_t>(verifier, VT_ISSHOWTITLE) &&
           VerifyOffset(verifier, VT_TABLEPOSITION) &&
           verifier.VerifyVector(TablePosition()) &&
           VerifyOffset(verifier, VT_COLUMNWIDTHS) &&
           verifier.VerifyVector(ColumnWidths()) &&
           VerifyOffset(verifier, VT_ROWSHEIGHTS) &&
           verifier.VerifyVector(rowsHeights()) &&
           VerifyOffset(verifier, VT_COLUMNTYPE) &&
           verifier.VerifyVector(ColumnType()) &&
           verifier.VerifyVectorOfStrings(ColumnType()) &&
           VerifyOffset(verifier, VT_ROWTYPE) &&
           verifier.VerifyVector(RowType()) &&
           VerifyOffset(verifier, VT_CELLISCONNECTED) &&
           verifier.VerifyVector(CellIsConnected()) &&
           VerifyOffset(verifier, VT_CELLTEXTALIGN) &&
           verifier.VerifyVector(CellTextAlign()) &&
           VerifyOffset(verifier, VT_VARIABLE) &&
           verifier.VerifyVector(Variable()) &&
           verifier.VerifyVectorOfTables(Variable()) &&
           VerifyOffset(verifier, VT_MERGECELLSINFO) &&
           verifier.VerifyVector(MergeCellsInfo()) &&
           verifier.VerifyVectorOfTables(MergeCellsInfo()) &&
           VerifyField<int32_t>(verifier, VT_NOLABELTYPE) &&
           VerifyField<int32_t>(verifier, VT_ISDEPART) &&
           VerifyField<int32_t>(verifier, VT_DEPARTTYPE) &&
           VerifyOffset(verifier, VT_LOCKCOL) &&
           verifier.VerifyVector(LockCol()) &&
           VerifyOffset(verifier, VT_LOCKROW) &&
           verifier.VerifyVector(LockRow()) &&
           VerifyOffset(verifier, VT_ROWRELHI) &&
           verifier.VerifyVector(RowRelHi()) &&
           VerifyField<int32_t>(verifier, VT_BOMTYPE) &&
           VerifyOffset(verifier, VT_HYPPROTOID) &&
           verifier.VerifyVector(HypProtoId()) &&
           verifier.VerifyVectorOfStrings(HypProtoId()) &&
           VerifyOffset(verifier, VT_HYPINSTANCEID) &&
           verifier.VerifyVector(HypInstanceId()) &&
           verifier.VerifyVectorOfStrings(HypInstanceId()) &&
           VerifyOffset(verifier, VT_DOCUMENTID) &&
           verifier.VerifyString(DocumentId()) &&
           VerifyOffset(verifier, VT_VERSIONID) &&
           verifier.VerifyString(VersionId()) &&
           VerifyOffset(verifier, VT_HYPDOCUMENTID) &&
           verifier.VerifyVector(HypDocumentId()) &&
           verifier.VerifyVectorOfStrings(HypDocumentId()) &&
           VerifyOffset(verifier, VT_HYPVERSIONID) &&
           verifier.VerifyVector(HypVersionId()) &&
           verifier.VerifyVectorOfStrings(HypVersionId()) &&
           VerifyOffset(verifier, VT_ROWIDS) &&
           verifier.VerifyVector(RowIds()) &&
           VerifyOffset(verifier, VT_REVISIONIDS) &&
           verifier.VerifyVector(RevisionIds()) &&
           verifier.VerifyVectorOfStrings(RevisionIds()) &&
           VerifyField<uint8_t>(verifier, VT_ISACTIVESYMBOL) &&
           VerifyField<uint8_t>(verifier, VT_ISAUTOUPDATE) &&
           VerifyField<int32_t>(verifier, VT_DEFAULTSYMBOLTYPE) &&
           VerifyOffset(verifier, VT_CELLTEXT) &&
           verifier.VerifyVector(CellText()) &&
           verifier.VerifyVectorOfTables(CellText()) &&
           VerifyOffset(verifier, VT_CELL) &&
           verifier.VerifyVector(Cell()) &&
           verifier.VerifyVectorOfTables(Cell()) &&
           VerifyOffset(verifier, VT_ALLCOLTYPE) &&
           verifier.VerifyVector(AllColType()) &&
           verifier.VerifyVectorOfStrings(AllColType()) &&
           VerifyOffset(verifier, VT_REFVIEWINDEX) &&
           verifier.VerifyVector(RefViewIndex()) &&
           verifier.VerifyVectorOfStrings(RefViewIndex()) &&
           VerifyOffset(verifier, VT_ROWLABELFINDEX) &&
           verifier.VerifyVector(RowLabelFIndex()) &&
           verifier.VerifyVectorOfStrings(RowLabelFIndex()) &&
           VerifyField<int32_t>(verifier, VT_SORTBYASSEMBLE) &&
           VerifyField<int32_t>(verifier, VT_SORTBYSUBASSEMBLE) &&
           VerifyField<int32_t>(verifier, VT_NOTCHANGEBALLOONINF) &&
           VerifyField<int32_t>(verifier, VT_LAYER) &&
           VerifyField<int32_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct TableInfoDataBuilder {
  typedef TableInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TableType(int32_t TableType) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_TABLETYPE, TableType, 0);
  }
  void add_RowsNum(int32_t RowsNum) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_ROWSNUM, RowsNum, 0);
  }
  void add_ColumnsNum(int32_t ColumnsNum) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_COLUMNSNUM, ColumnsNum, 0);
  }
  void add_RelView(flatbuffers::Offset<flatbuffers::String> RelView) {
    fbb_.AddOffset(TableInfoData::VT_RELVIEW, RelView);
  }
  void add_balloonInfoList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> balloonInfoList) {
    fbb_.AddOffset(TableInfoData::VT_BALLOONINFOLIST, balloonInfoList);
  }
  void add_Lock(bool Lock) {
    fbb_.AddElement<uint8_t>(TableInfoData::VT_LOCK, static_cast<uint8_t>(Lock), 0);
  }
  void add_LockType(int32_t LockType) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_LOCKTYPE, LockType, 0);
  }
  void add_Reverse(bool Reverse) {
    fbb_.AddElement<uint8_t>(TableInfoData::VT_REVERSE, static_cast<uint8_t>(Reverse), 0);
  }
  void add_ParentId(flatbuffers::Offset<flatbuffers::String> ParentId) {
    fbb_.AddOffset(TableInfoData::VT_PARENTID, ParentId);
  }
  void add_Deleted(bool Deleted) {
    fbb_.AddElement<uint8_t>(TableInfoData::VT_DELETED, static_cast<uint8_t>(Deleted), 0);
  }
  void add_isShowTitle(bool isShowTitle) {
    fbb_.AddElement<uint8_t>(TableInfoData::VT_ISSHOWTITLE, static_cast<uint8_t>(isShowTitle), 0);
  }
  void add_TablePosition(flatbuffers::Offset<flatbuffers::Vector<float>> TablePosition) {
    fbb_.AddOffset(TableInfoData::VT_TABLEPOSITION, TablePosition);
  }
  void add_ColumnWidths(flatbuffers::Offset<flatbuffers::Vector<double>> ColumnWidths) {
    fbb_.AddOffset(TableInfoData::VT_COLUMNWIDTHS, ColumnWidths);
  }
  void add_rowsHeights(flatbuffers::Offset<flatbuffers::Vector<double>> rowsHeights) {
    fbb_.AddOffset(TableInfoData::VT_ROWSHEIGHTS, rowsHeights);
  }
  void add_ColumnType(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ColumnType) {
    fbb_.AddOffset(TableInfoData::VT_COLUMNTYPE, ColumnType);
  }
  void add_RowType(flatbuffers::Offset<flatbuffers::Vector<int32_t>> RowType) {
    fbb_.AddOffset(TableInfoData::VT_ROWTYPE, RowType);
  }
  void add_CellIsConnected(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> CellIsConnected) {
    fbb_.AddOffset(TableInfoData::VT_CELLISCONNECTED, CellIsConnected);
  }
  void add_CellTextAlign(flatbuffers::Offset<flatbuffers::Vector<int32_t>> CellTextAlign) {
    fbb_.AddOffset(TableInfoData::VT_CELLTEXTALIGN, CellTextAlign);
  }
  void add_Variable(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CellVariableData>>> Variable) {
    fbb_.AddOffset(TableInfoData::VT_VARIABLE, Variable);
  }
  void add_MergeCellsInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MergeCellsInfoData>>> MergeCellsInfo) {
    fbb_.AddOffset(TableInfoData::VT_MERGECELLSINFO, MergeCellsInfo);
  }
  void add_NOLabelType(int32_t NOLabelType) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_NOLABELTYPE, NOLabelType, 0);
  }
  void add_IsDepart(int32_t IsDepart) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_ISDEPART, IsDepart, 0);
  }
  void add_DepartType(int32_t DepartType) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_DEPARTTYPE, DepartType, 0);
  }
  void add_LockCol(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> LockCol) {
    fbb_.AddOffset(TableInfoData::VT_LOCKCOL, LockCol);
  }
  void add_LockRow(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> LockRow) {
    fbb_.AddOffset(TableInfoData::VT_LOCKROW, LockRow);
  }
  void add_RowRelHi(flatbuffers::Offset<flatbuffers::Vector<int32_t>> RowRelHi) {
    fbb_.AddOffset(TableInfoData::VT_ROWRELHI, RowRelHi);
  }
  void add_BOMType(int32_t BOMType) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_BOMTYPE, BOMType, 0);
  }
  void add_HypProtoId(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HypProtoId) {
    fbb_.AddOffset(TableInfoData::VT_HYPPROTOID, HypProtoId);
  }
  void add_HypInstanceId(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HypInstanceId) {
    fbb_.AddOffset(TableInfoData::VT_HYPINSTANCEID, HypInstanceId);
  }
  void add_DocumentId(flatbuffers::Offset<flatbuffers::String> DocumentId) {
    fbb_.AddOffset(TableInfoData::VT_DOCUMENTID, DocumentId);
  }
  void add_VersionId(flatbuffers::Offset<flatbuffers::String> VersionId) {
    fbb_.AddOffset(TableInfoData::VT_VERSIONID, VersionId);
  }
  void add_HypDocumentId(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HypDocumentId) {
    fbb_.AddOffset(TableInfoData::VT_HYPDOCUMENTID, HypDocumentId);
  }
  void add_HypVersionId(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HypVersionId) {
    fbb_.AddOffset(TableInfoData::VT_HYPVERSIONID, HypVersionId);
  }
  void add_RowIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> RowIds) {
    fbb_.AddOffset(TableInfoData::VT_ROWIDS, RowIds);
  }
  void add_RevisionIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RevisionIds) {
    fbb_.AddOffset(TableInfoData::VT_REVISIONIDS, RevisionIds);
  }
  void add_isActiveSymbol(bool isActiveSymbol) {
    fbb_.AddElement<uint8_t>(TableInfoData::VT_ISACTIVESYMBOL, static_cast<uint8_t>(isActiveSymbol), 0);
  }
  void add_isAutoUpdate(bool isAutoUpdate) {
    fbb_.AddElement<uint8_t>(TableInfoData::VT_ISAUTOUPDATE, static_cast<uint8_t>(isAutoUpdate), 0);
  }
  void add_defaultSymbolType(int32_t defaultSymbolType) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_DEFAULTSYMBOLTYPE, defaultSymbolType, 0);
  }
  void add_CellText(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TableTextData>>> CellText) {
    fbb_.AddOffset(TableInfoData::VT_CELLTEXT, CellText);
  }
  void add_Cell(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CellInfoData>>> Cell) {
    fbb_.AddOffset(TableInfoData::VT_CELL, Cell);
  }
  void add_AllColType(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> AllColType) {
    fbb_.AddOffset(TableInfoData::VT_ALLCOLTYPE, AllColType);
  }
  void add_RefViewIndex(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RefViewIndex) {
    fbb_.AddOffset(TableInfoData::VT_REFVIEWINDEX, RefViewIndex);
  }
  void add_RowLabelFIndex(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RowLabelFIndex) {
    fbb_.AddOffset(TableInfoData::VT_ROWLABELFINDEX, RowLabelFIndex);
  }
  void add_SortByAssemble(int32_t SortByAssemble) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_SORTBYASSEMBLE, SortByAssemble, 0);
  }
  void add_SortBySubAssemble(int32_t SortBySubAssemble) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_SORTBYSUBASSEMBLE, SortBySubAssemble, 0);
  }
  void add_NotChangeBalloonInf(int32_t NotChangeBalloonInf) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_NOTCHANGEBALLOONINF, NotChangeBalloonInf, 0);
  }
  void add_Layer(int32_t Layer) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_LAYER, Layer, 0);
  }
  void add_Color(int32_t Color) {
    fbb_.AddElement<int32_t>(TableInfoData::VT_COLOR, Color, 0);
  }
  explicit TableInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableInfoDataBuilder &operator=(const TableInfoDataBuilder &);
  flatbuffers::Offset<TableInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableInfoData> CreateTableInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t TableType = 0,
    int32_t RowsNum = 0,
    int32_t ColumnsNum = 0,
    flatbuffers::Offset<flatbuffers::String> RelView = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> balloonInfoList = 0,
    bool Lock = false,
    int32_t LockType = 0,
    bool Reverse = false,
    flatbuffers::Offset<flatbuffers::String> ParentId = 0,
    bool Deleted = false,
    bool isShowTitle = false,
    flatbuffers::Offset<flatbuffers::Vector<float>> TablePosition = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ColumnWidths = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> rowsHeights = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ColumnType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> RowType = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> CellIsConnected = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> CellTextAlign = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CellVariableData>>> Variable = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MergeCellsInfoData>>> MergeCellsInfo = 0,
    int32_t NOLabelType = 0,
    int32_t IsDepart = 0,
    int32_t DepartType = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> LockCol = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> LockRow = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> RowRelHi = 0,
    int32_t BOMType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HypProtoId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HypInstanceId = 0,
    flatbuffers::Offset<flatbuffers::String> DocumentId = 0,
    flatbuffers::Offset<flatbuffers::String> VersionId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HypDocumentId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> HypVersionId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> RowIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RevisionIds = 0,
    bool isActiveSymbol = false,
    bool isAutoUpdate = false,
    int32_t defaultSymbolType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TableTextData>>> CellText = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CellInfoData>>> Cell = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> AllColType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RefViewIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RowLabelFIndex = 0,
    int32_t SortByAssemble = 0,
    int32_t SortBySubAssemble = 0,
    int32_t NotChangeBalloonInf = 0,
    int32_t Layer = 0,
    int32_t Color = 0) {
  TableInfoDataBuilder builder_(_fbb);
  builder_.add_Color(Color);
  builder_.add_Layer(Layer);
  builder_.add_NotChangeBalloonInf(NotChangeBalloonInf);
  builder_.add_SortBySubAssemble(SortBySubAssemble);
  builder_.add_SortByAssemble(SortByAssemble);
  builder_.add_RowLabelFIndex(RowLabelFIndex);
  builder_.add_RefViewIndex(RefViewIndex);
  builder_.add_AllColType(AllColType);
  builder_.add_Cell(Cell);
  builder_.add_CellText(CellText);
  builder_.add_defaultSymbolType(defaultSymbolType);
  builder_.add_RevisionIds(RevisionIds);
  builder_.add_RowIds(RowIds);
  builder_.add_HypVersionId(HypVersionId);
  builder_.add_HypDocumentId(HypDocumentId);
  builder_.add_VersionId(VersionId);
  builder_.add_DocumentId(DocumentId);
  builder_.add_HypInstanceId(HypInstanceId);
  builder_.add_HypProtoId(HypProtoId);
  builder_.add_BOMType(BOMType);
  builder_.add_RowRelHi(RowRelHi);
  builder_.add_LockRow(LockRow);
  builder_.add_LockCol(LockCol);
  builder_.add_DepartType(DepartType);
  builder_.add_IsDepart(IsDepart);
  builder_.add_NOLabelType(NOLabelType);
  builder_.add_MergeCellsInfo(MergeCellsInfo);
  builder_.add_Variable(Variable);
  builder_.add_CellTextAlign(CellTextAlign);
  builder_.add_CellIsConnected(CellIsConnected);
  builder_.add_RowType(RowType);
  builder_.add_ColumnType(ColumnType);
  builder_.add_rowsHeights(rowsHeights);
  builder_.add_ColumnWidths(ColumnWidths);
  builder_.add_TablePosition(TablePosition);
  builder_.add_ParentId(ParentId);
  builder_.add_LockType(LockType);
  builder_.add_balloonInfoList(balloonInfoList);
  builder_.add_RelView(RelView);
  builder_.add_ColumnsNum(ColumnsNum);
  builder_.add_RowsNum(RowsNum);
  builder_.add_TableType(TableType);
  builder_.add_isAutoUpdate(isAutoUpdate);
  builder_.add_isActiveSymbol(isActiveSymbol);
  builder_.add_isShowTitle(isShowTitle);
  builder_.add_Deleted(Deleted);
  builder_.add_Reverse(Reverse);
  builder_.add_Lock(Lock);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableInfoData> CreateTableInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t TableType = 0,
    int32_t RowsNum = 0,
    int32_t ColumnsNum = 0,
    const char *RelView = nullptr,
    const std::vector<int32_t> *balloonInfoList = nullptr,
    bool Lock = false,
    int32_t LockType = 0,
    bool Reverse = false,
    const char *ParentId = nullptr,
    bool Deleted = false,
    bool isShowTitle = false,
    const std::vector<float> *TablePosition = nullptr,
    const std::vector<double> *ColumnWidths = nullptr,
    const std::vector<double> *rowsHeights = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *ColumnType = nullptr,
    const std::vector<int32_t> *RowType = nullptr,
    const std::vector<uint8_t> *CellIsConnected = nullptr,
    const std::vector<int32_t> *CellTextAlign = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CellVariableData>> *Variable = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MergeCellsInfoData>> *MergeCellsInfo = nullptr,
    int32_t NOLabelType = 0,
    int32_t IsDepart = 0,
    int32_t DepartType = 0,
    const std::vector<uint8_t> *LockCol = nullptr,
    const std::vector<uint8_t> *LockRow = nullptr,
    const std::vector<int32_t> *RowRelHi = nullptr,
    int32_t BOMType = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *HypProtoId = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *HypInstanceId = nullptr,
    const char *DocumentId = nullptr,
    const char *VersionId = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *HypDocumentId = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *HypVersionId = nullptr,
    const std::vector<int32_t> *RowIds = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *RevisionIds = nullptr,
    bool isActiveSymbol = false,
    bool isAutoUpdate = false,
    int32_t defaultSymbolType = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TableTextData>> *CellText = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CellInfoData>> *Cell = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *AllColType = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *RefViewIndex = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *RowLabelFIndex = nullptr,
    int32_t SortByAssemble = 0,
    int32_t SortBySubAssemble = 0,
    int32_t NotChangeBalloonInf = 0,
    int32_t Layer = 0,
    int32_t Color = 0) {
  auto RelView__ = RelView ? _fbb.CreateString(RelView) : 0;
  auto balloonInfoList__ = balloonInfoList ? _fbb.CreateVector<int32_t>(*balloonInfoList) : 0;
  auto ParentId__ = ParentId ? _fbb.CreateString(ParentId) : 0;
  auto TablePosition__ = TablePosition ? _fbb.CreateVector<float>(*TablePosition) : 0;
  auto ColumnWidths__ = ColumnWidths ? _fbb.CreateVector<double>(*ColumnWidths) : 0;
  auto rowsHeights__ = rowsHeights ? _fbb.CreateVector<double>(*rowsHeights) : 0;
  auto ColumnType__ = ColumnType ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*ColumnType) : 0;
  auto RowType__ = RowType ? _fbb.CreateVector<int32_t>(*RowType) : 0;
  auto CellIsConnected__ = CellIsConnected ? _fbb.CreateVector<uint8_t>(*CellIsConnected) : 0;
  auto CellTextAlign__ = CellTextAlign ? _fbb.CreateVector<int32_t>(*CellTextAlign) : 0;
  auto Variable__ = Variable ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CellVariableData>>(*Variable) : 0;
  auto MergeCellsInfo__ = MergeCellsInfo ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MergeCellsInfoData>>(*MergeCellsInfo) : 0;
  auto LockCol__ = LockCol ? _fbb.CreateVector<uint8_t>(*LockCol) : 0;
  auto LockRow__ = LockRow ? _fbb.CreateVector<uint8_t>(*LockRow) : 0;
  auto RowRelHi__ = RowRelHi ? _fbb.CreateVector<int32_t>(*RowRelHi) : 0;
  auto HypProtoId__ = HypProtoId ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*HypProtoId) : 0;
  auto HypInstanceId__ = HypInstanceId ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*HypInstanceId) : 0;
  auto DocumentId__ = DocumentId ? _fbb.CreateString(DocumentId) : 0;
  auto VersionId__ = VersionId ? _fbb.CreateString(VersionId) : 0;
  auto HypDocumentId__ = HypDocumentId ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*HypDocumentId) : 0;
  auto HypVersionId__ = HypVersionId ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*HypVersionId) : 0;
  auto RowIds__ = RowIds ? _fbb.CreateVector<int32_t>(*RowIds) : 0;
  auto RevisionIds__ = RevisionIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*RevisionIds) : 0;
  auto CellText__ = CellText ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TableTextData>>(*CellText) : 0;
  auto Cell__ = Cell ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CellInfoData>>(*Cell) : 0;
  auto AllColType__ = AllColType ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*AllColType) : 0;
  auto RefViewIndex__ = RefViewIndex ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*RefViewIndex) : 0;
  auto RowLabelFIndex__ = RowLabelFIndex ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*RowLabelFIndex) : 0;
  return FlatBufferDocSpace::CreateTableInfoData(
      _fbb,
      TableType,
      RowsNum,
      ColumnsNum,
      RelView__,
      balloonInfoList__,
      Lock,
      LockType,
      Reverse,
      ParentId__,
      Deleted,
      isShowTitle,
      TablePosition__,
      ColumnWidths__,
      rowsHeights__,
      ColumnType__,
      RowType__,
      CellIsConnected__,
      CellTextAlign__,
      Variable__,
      MergeCellsInfo__,
      NOLabelType,
      IsDepart,
      DepartType,
      LockCol__,
      LockRow__,
      RowRelHi__,
      BOMType,
      HypProtoId__,
      HypInstanceId__,
      DocumentId__,
      VersionId__,
      HypDocumentId__,
      HypVersionId__,
      RowIds__,
      RevisionIds__,
      isActiveSymbol,
      isAutoUpdate,
      defaultSymbolType,
      CellText__,
      Cell__,
      AllColType__,
      RefViewIndex__,
      RowLabelFIndex__,
      SortByAssemble,
      SortBySubAssemble,
      NotChangeBalloonInf,
      Layer,
      Color);
}

struct DrawingViewEntity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DrawingViewEntityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RENDERMODE = 6,
    VT_SCALETYPE = 8,
    VT_INDEX = 10,
    VT_DIMENSIONTYPE = 12,
    VT_SCRAPEDGEVISIBLE = 14,
    VT_VIEWSCALE = 16,
    VT_SCALE = 18,
    VT_VIEWTYPE = 20,
    VT_VIEWALIGNTYPE = 22,
    VT_USEPARENTSTYLE = 24,
    VT_VIEWVISIBLE = 26,
    VT_UP = 28,
    VT_NORM = 30,
    VT_ORGVIEWBOX = 32,
    VT_FOCUSVIEWBOX = 34,
    VT_CENTERPOSITION = 36,
    VT_MODELORG = 38,
    VT_THREEDCENTERPOSITION = 40,
    VT_SECTIONID = 42,
    VT_TYPE = 44,
    VT_PARENTINDEX = 46,
    VT_PROJECTGEOMETRY = 48,
    VT_HIDEPROJECTGEOMETRY = 50,
    VT_MODELSKETCHGROUP = 52,
    VT_VIEWDIRECTION = 54,
    VT_DOCUMENTID = 56,
    VT_VERSIONID = 58,
    VT_USERDEFNAMES = 60,
    VT_USERDEFDIR = 62,
    VT_BREAKSTYLE = 64,
    VT_BREAKVIEWPNTS = 66,
    VT_BREAKLINES = 68,
    VT_GAPSIZE = 70,
    VT_ORIGINVIEWTYPE = 72,
    VT_CONTOURTYPE = 74,
    VT_CONTOURCENTERPNT = 76,
    VT_CONTOURRADIUS = 78,
    VT_CONTOURDISPLAYTYPE = 80,
    VT_CONTOURSTYLE = 82,
    VT_CONTOURLINES = 84,
    VT_SELECTCONTOUR = 86,
    VT_CROPBOUNDS = 88,
    VT_CROPCONTOUERLINES = 90,
    VT_HIDEOUTLINEGEOMETRY = 92,
    VT_OUTLINEGEOMETRY = 94,
    VT_ISFLATPATTERN = 96,
    VT_HASBENDLINE = 98,
    VT_HASBENDANNOTATION = 100,
    VT_ISREVERSAL = 102,
    VT_BENDANNOTATION = 104,
    VT_ROTANGLE = 106,
    VT_MODELBOX = 108,
    VT_VIEWPROPERTY = 110,
    VT_DETAILCONTOURLINES = 112,
    VT_DIMENSION = 114,
    VT_GEOMETRY = 116,
    VT_CENTERMARK = 118,
    VT_SECTIONS = 120,
    VT_DRAFTSYMBOL = 122,
    VT_HATCHREGIONDATAS = 124,
    VT_BROKENSECDATAS = 126,
    VT_MASTERINDEX = 128,
    VT_CUSTOMVIEWFLAG = 130,
    VT_CUSTOMVIEWINDEX = 132,
    VT_REMOVEDSECTIONCUTTINGLINES = 134,
    VT_AREAHATCHDATAS = 136,
    VT_TABLEINDEX = 138,
    VT_ISROTATECHILD = 140,
    VT_ISROTATECENTERMARK = 142
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t RenderMode() const {
    return GetField<int32_t>(VT_RENDERMODE, 0);
  }
  int32_t ScaleType() const {
    return GetField<int32_t>(VT_SCALETYPE, 0);
  }
  const flatbuffers::String *Index() const {
    return GetPointer<const flatbuffers::String *>(VT_INDEX);
  }
  int32_t DimensionType() const {
    return GetField<int32_t>(VT_DIMENSIONTYPE, 0);
  }
  int32_t ScrapEdgeVisible() const {
    return GetField<int32_t>(VT_SCRAPEDGEVISIBLE, 0);
  }
  const flatbuffers::String *ViewScale() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWSCALE);
  }
  float Scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  int32_t ViewType() const {
    return GetField<int32_t>(VT_VIEWTYPE, 0);
  }
  int32_t ViewAlignType() const {
    return GetField<int32_t>(VT_VIEWALIGNTYPE, 0);
  }
  int32_t UseParentStyle() const {
    return GetField<int32_t>(VT_USEPARENTSTYLE, 0);
  }
  int32_t ViewVisible() const {
    return GetField<int32_t>(VT_VIEWVISIBLE, 0);
  }
  const flatbuffers::Vector<float> *Up() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_UP);
  }
  const flatbuffers::Vector<float> *Norm() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_NORM);
  }
  const flatbuffers::Vector<float> *OrgViewBox() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ORGVIEWBOX);
  }
  const flatbuffers::Vector<float> *FocusViewBox() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FOCUSVIEWBOX);
  }
  const flatbuffers::Vector<float> *CenterPosition() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CENTERPOSITION);
  }
  const flatbuffers::Vector<float> *ModelOrg() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MODELORG);
  }
  const flatbuffers::Vector<float> *ThreeDCenterPosition() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_THREEDCENTERPOSITION);
  }
  int32_t SectionId() const {
    return GetField<int32_t>(VT_SECTIONID, 0);
  }
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *ParentIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_PARENTINDEX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ProjectGeometry() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_PROJECTGEOMETRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *HideProjectGeometry() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_HIDEPROJECTGEOMETRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchData>> *ModelSketchGroup() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchData>> *>(VT_MODELSKETCHGROUP);
  }
  const flatbuffers::String *ViewDirection() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWDIRECTION);
  }
  const flatbuffers::String *DocumentId() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTID);
  }
  const flatbuffers::String *VersionId() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSIONID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *UserDefNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_USERDEFNAMES);
  }
  const flatbuffers::Vector<double> *UserDefDir() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_USERDEFDIR);
  }
  int32_t BreakStyle() const {
    return GetField<int32_t>(VT_BREAKSTYLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddBreakPts>> *BreakViewPnts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddBreakPts>> *>(VT_BREAKVIEWPNTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *BreakLines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_BREAKLINES);
  }
  double GapSize() const {
    return GetField<double>(VT_GAPSIZE, 0.0);
  }
  int32_t OriginViewType() const {
    return GetField<int32_t>(VT_ORIGINVIEWTYPE, 0);
  }
  int32_t ContourType() const {
    return GetField<int32_t>(VT_CONTOURTYPE, 0);
  }
  const flatbuffers::Vector<double> *ContourCenterPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CONTOURCENTERPNT);
  }
  double ContourRadius() const {
    return GetField<double>(VT_CONTOURRADIUS, 0.0);
  }
  int32_t ContourDisplayType() const {
    return GetField<int32_t>(VT_CONTOURDISPLAYTYPE, 0);
  }
  int32_t ContourStyle() const {
    return GetField<int32_t>(VT_CONTOURSTYLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ContourLines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_CONTOURLINES);
  }
  int32_t SelectContour() const {
    return GetField<int32_t>(VT_SELECTCONTOUR, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *CropBounds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_CROPBOUNDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *CropContouerLines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_CROPCONTOUERLINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *HideOutLineGeometry() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_HIDEOUTLINEGEOMETRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *OutLineGeometry() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_OUTLINEGEOMETRY);
  }
  bool isFlatPattern() const {
    return GetField<uint8_t>(VT_ISFLATPATTERN, 0) != 0;
  }
  bool hasBendLine() const {
    return GetField<uint8_t>(VT_HASBENDLINE, 0) != 0;
  }
  bool hasBendAnnotation() const {
    return GetField<uint8_t>(VT_HASBENDANNOTATION, 0) != 0;
  }
  bool isReversal() const {
    return GetField<uint8_t>(VT_ISREVERSAL, 0) != 0;
  }
  const flatbuffers::String *bendAnnotation() const {
    return GetPointer<const flatbuffers::String *>(VT_BENDANNOTATION);
  }
  double rotAngle() const {
    return GetField<double>(VT_ROTANGLE, 0.0);
  }
  const flatbuffers::Vector<float> *ModelBox() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MODELBOX);
  }
  const FlatBufferDocSpace::ViewPropertyData *ViewProperty() const {
    return GetPointer<const FlatBufferDocSpace::ViewPropertyData *>(VT_VIEWPROPERTY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *DetailContourLines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_DETAILCONTOURLINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Dimension() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_DIMENSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Geometry() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_GEOMETRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *CenterMark() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_CENTERMARK);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Sections() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_SECTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *DraftSymbol() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_DRAFTSYMBOL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>> *HatchRegionDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>> *>(VT_HATCHREGIONDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>> *BrokenSecDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>> *>(VT_BROKENSECDATAS);
  }
  const flatbuffers::String *MasterIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_MASTERINDEX);
  }
  const flatbuffers::Vector<int32_t> *CustomViewFlag() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CUSTOMVIEWFLAG);
  }
  const flatbuffers::String *CustomViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOMVIEWINDEX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *RemovedSectionCuttingLines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_REMOVEDSECTIONCUTTINGLINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>> *AreaHatchDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>> *>(VT_AREAHATCHDATAS);
  }
  const flatbuffers::String *TableIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_TABLEINDEX);
  }
  bool IsRotateChild() const {
    return GetField<uint8_t>(VT_ISROTATECHILD, 0) != 0;
  }
  bool IsRotateCenterMark() const {
    return GetField<uint8_t>(VT_ISROTATECENTERMARK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_RENDERMODE) &&
           VerifyField<int32_t>(verifier, VT_SCALETYPE) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyString(Index()) &&
           VerifyField<int32_t>(verifier, VT_DIMENSIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_SCRAPEDGEVISIBLE) &&
           VerifyOffset(verifier, VT_VIEWSCALE) &&
           verifier.VerifyString(ViewScale()) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_VIEWTYPE) &&
           VerifyField<int32_t>(verifier, VT_VIEWALIGNTYPE) &&
           VerifyField<int32_t>(verifier, VT_USEPARENTSTYLE) &&
           VerifyField<int32_t>(verifier, VT_VIEWVISIBLE) &&
           VerifyOffset(verifier, VT_UP) &&
           verifier.VerifyVector(Up()) &&
           VerifyOffset(verifier, VT_NORM) &&
           verifier.VerifyVector(Norm()) &&
           VerifyOffset(verifier, VT_ORGVIEWBOX) &&
           verifier.VerifyVector(OrgViewBox()) &&
           VerifyOffset(verifier, VT_FOCUSVIEWBOX) &&
           verifier.VerifyVector(FocusViewBox()) &&
           VerifyOffset(verifier, VT_CENTERPOSITION) &&
           verifier.VerifyVector(CenterPosition()) &&
           VerifyOffset(verifier, VT_MODELORG) &&
           verifier.VerifyVector(ModelOrg()) &&
           VerifyOffset(verifier, VT_THREEDCENTERPOSITION) &&
           verifier.VerifyVector(ThreeDCenterPosition()) &&
           VerifyField<int32_t>(verifier, VT_SECTIONID) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_PARENTINDEX) &&
           verifier.VerifyString(ParentIndex()) &&
           VerifyOffset(verifier, VT_PROJECTGEOMETRY) &&
           verifier.VerifyVector(ProjectGeometry()) &&
           verifier.VerifyVectorOfTables(ProjectGeometry()) &&
           VerifyOffset(verifier, VT_HIDEPROJECTGEOMETRY) &&
           verifier.VerifyVector(HideProjectGeometry()) &&
           verifier.VerifyVectorOfTables(HideProjectGeometry()) &&
           VerifyOffset(verifier, VT_MODELSKETCHGROUP) &&
           verifier.VerifyVector(ModelSketchGroup()) &&
           verifier.VerifyVectorOfTables(ModelSketchGroup()) &&
           VerifyOffset(verifier, VT_VIEWDIRECTION) &&
           verifier.VerifyString(ViewDirection()) &&
           VerifyOffset(verifier, VT_DOCUMENTID) &&
           verifier.VerifyString(DocumentId()) &&
           VerifyOffset(verifier, VT_VERSIONID) &&
           verifier.VerifyString(VersionId()) &&
           VerifyOffset(verifier, VT_USERDEFNAMES) &&
           verifier.VerifyVector(UserDefNames()) &&
           verifier.VerifyVectorOfStrings(UserDefNames()) &&
           VerifyOffset(verifier, VT_USERDEFDIR) &&
           verifier.VerifyVector(UserDefDir()) &&
           VerifyField<int32_t>(verifier, VT_BREAKSTYLE) &&
           VerifyOffset(verifier, VT_BREAKVIEWPNTS) &&
           verifier.VerifyVector(BreakViewPnts()) &&
           verifier.VerifyVectorOfTables(BreakViewPnts()) &&
           VerifyOffset(verifier, VT_BREAKLINES) &&
           verifier.VerifyVector(BreakLines()) &&
           verifier.VerifyVectorOfTables(BreakLines()) &&
           VerifyField<double>(verifier, VT_GAPSIZE) &&
           VerifyField<int32_t>(verifier, VT_ORIGINVIEWTYPE) &&
           VerifyField<int32_t>(verifier, VT_CONTOURTYPE) &&
           VerifyOffset(verifier, VT_CONTOURCENTERPNT) &&
           verifier.VerifyVector(ContourCenterPnt()) &&
           VerifyField<double>(verifier, VT_CONTOURRADIUS) &&
           VerifyField<int32_t>(verifier, VT_CONTOURDISPLAYTYPE) &&
           VerifyField<int32_t>(verifier, VT_CONTOURSTYLE) &&
           VerifyOffset(verifier, VT_CONTOURLINES) &&
           verifier.VerifyVector(ContourLines()) &&
           verifier.VerifyVectorOfTables(ContourLines()) &&
           VerifyField<int32_t>(verifier, VT_SELECTCONTOUR) &&
           VerifyOffset(verifier, VT_CROPBOUNDS) &&
           verifier.VerifyVector(CropBounds()) &&
           verifier.VerifyVectorOfTables(CropBounds()) &&
           VerifyOffset(verifier, VT_CROPCONTOUERLINES) &&
           verifier.VerifyVector(CropContouerLines()) &&
           verifier.VerifyVectorOfTables(CropContouerLines()) &&
           VerifyOffset(verifier, VT_HIDEOUTLINEGEOMETRY) &&
           verifier.VerifyVector(HideOutLineGeometry()) &&
           verifier.VerifyVectorOfTables(HideOutLineGeometry()) &&
           VerifyOffset(verifier, VT_OUTLINEGEOMETRY) &&
           verifier.VerifyVector(OutLineGeometry()) &&
           verifier.VerifyVectorOfTables(OutLineGeometry()) &&
           VerifyField<uint8_t>(verifier, VT_ISFLATPATTERN) &&
           VerifyField<uint8_t>(verifier, VT_HASBENDLINE) &&
           VerifyField<uint8_t>(verifier, VT_HASBENDANNOTATION) &&
           VerifyField<uint8_t>(verifier, VT_ISREVERSAL) &&
           VerifyOffset(verifier, VT_BENDANNOTATION) &&
           verifier.VerifyString(bendAnnotation()) &&
           VerifyField<double>(verifier, VT_ROTANGLE) &&
           VerifyOffset(verifier, VT_MODELBOX) &&
           verifier.VerifyVector(ModelBox()) &&
           VerifyOffset(verifier, VT_VIEWPROPERTY) &&
           verifier.VerifyTable(ViewProperty()) &&
           VerifyOffset(verifier, VT_DETAILCONTOURLINES) &&
           verifier.VerifyVector(DetailContourLines()) &&
           verifier.VerifyVectorOfTables(DetailContourLines()) &&
           VerifyOffset(verifier, VT_DIMENSION) &&
           verifier.VerifyVector(Dimension()) &&
           verifier.VerifyVectorOfTables(Dimension()) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyVector(Geometry()) &&
           verifier.VerifyVectorOfTables(Geometry()) &&
           VerifyOffset(verifier, VT_CENTERMARK) &&
           verifier.VerifyVector(CenterMark()) &&
           verifier.VerifyVectorOfTables(CenterMark()) &&
           VerifyOffset(verifier, VT_SECTIONS) &&
           verifier.VerifyVector(Sections()) &&
           verifier.VerifyVectorOfTables(Sections()) &&
           VerifyOffset(verifier, VT_DRAFTSYMBOL) &&
           verifier.VerifyVector(DraftSymbol()) &&
           verifier.VerifyVectorOfTables(DraftSymbol()) &&
           VerifyOffset(verifier, VT_HATCHREGIONDATAS) &&
           verifier.VerifyVector(HatchRegionDatas()) &&
           verifier.VerifyVectorOfTables(HatchRegionDatas()) &&
           VerifyOffset(verifier, VT_BROKENSECDATAS) &&
           verifier.VerifyVector(BrokenSecDatas()) &&
           verifier.VerifyVectorOfTables(BrokenSecDatas()) &&
           VerifyOffset(verifier, VT_MASTERINDEX) &&
           verifier.VerifyString(MasterIndex()) &&
           VerifyOffset(verifier, VT_CUSTOMVIEWFLAG) &&
           verifier.VerifyVector(CustomViewFlag()) &&
           VerifyOffset(verifier, VT_CUSTOMVIEWINDEX) &&
           verifier.VerifyString(CustomViewIndex()) &&
           VerifyOffset(verifier, VT_REMOVEDSECTIONCUTTINGLINES) &&
           verifier.VerifyVector(RemovedSectionCuttingLines()) &&
           verifier.VerifyVectorOfTables(RemovedSectionCuttingLines()) &&
           VerifyOffset(verifier, VT_AREAHATCHDATAS) &&
           verifier.VerifyVector(AreaHatchDatas()) &&
           verifier.VerifyVectorOfTables(AreaHatchDatas()) &&
           VerifyOffset(verifier, VT_TABLEINDEX) &&
           verifier.VerifyString(TableIndex()) &&
           VerifyField<uint8_t>(verifier, VT_ISROTATECHILD) &&
           VerifyField<uint8_t>(verifier, VT_ISROTATECENTERMARK) &&
           verifier.EndTable();
  }
};

struct DrawingViewEntityBuilder {
  typedef DrawingViewEntity Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_ID, Id, 0);
  }
  void add_RenderMode(int32_t RenderMode) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_RENDERMODE, RenderMode, 0);
  }
  void add_ScaleType(int32_t ScaleType) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_SCALETYPE, ScaleType, 0);
  }
  void add_Index(flatbuffers::Offset<flatbuffers::String> Index) {
    fbb_.AddOffset(DrawingViewEntity::VT_INDEX, Index);
  }
  void add_DimensionType(int32_t DimensionType) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_DIMENSIONTYPE, DimensionType, 0);
  }
  void add_ScrapEdgeVisible(int32_t ScrapEdgeVisible) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_SCRAPEDGEVISIBLE, ScrapEdgeVisible, 0);
  }
  void add_ViewScale(flatbuffers::Offset<flatbuffers::String> ViewScale) {
    fbb_.AddOffset(DrawingViewEntity::VT_VIEWSCALE, ViewScale);
  }
  void add_Scale(float Scale) {
    fbb_.AddElement<float>(DrawingViewEntity::VT_SCALE, Scale, 0.0f);
  }
  void add_ViewType(int32_t ViewType) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_VIEWTYPE, ViewType, 0);
  }
  void add_ViewAlignType(int32_t ViewAlignType) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_VIEWALIGNTYPE, ViewAlignType, 0);
  }
  void add_UseParentStyle(int32_t UseParentStyle) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_USEPARENTSTYLE, UseParentStyle, 0);
  }
  void add_ViewVisible(int32_t ViewVisible) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_VIEWVISIBLE, ViewVisible, 0);
  }
  void add_Up(flatbuffers::Offset<flatbuffers::Vector<float>> Up) {
    fbb_.AddOffset(DrawingViewEntity::VT_UP, Up);
  }
  void add_Norm(flatbuffers::Offset<flatbuffers::Vector<float>> Norm) {
    fbb_.AddOffset(DrawingViewEntity::VT_NORM, Norm);
  }
  void add_OrgViewBox(flatbuffers::Offset<flatbuffers::Vector<float>> OrgViewBox) {
    fbb_.AddOffset(DrawingViewEntity::VT_ORGVIEWBOX, OrgViewBox);
  }
  void add_FocusViewBox(flatbuffers::Offset<flatbuffers::Vector<float>> FocusViewBox) {
    fbb_.AddOffset(DrawingViewEntity::VT_FOCUSVIEWBOX, FocusViewBox);
  }
  void add_CenterPosition(flatbuffers::Offset<flatbuffers::Vector<float>> CenterPosition) {
    fbb_.AddOffset(DrawingViewEntity::VT_CENTERPOSITION, CenterPosition);
  }
  void add_ModelOrg(flatbuffers::Offset<flatbuffers::Vector<float>> ModelOrg) {
    fbb_.AddOffset(DrawingViewEntity::VT_MODELORG, ModelOrg);
  }
  void add_ThreeDCenterPosition(flatbuffers::Offset<flatbuffers::Vector<float>> ThreeDCenterPosition) {
    fbb_.AddOffset(DrawingViewEntity::VT_THREEDCENTERPOSITION, ThreeDCenterPosition);
  }
  void add_SectionId(int32_t SectionId) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_SECTIONID, SectionId, 0);
  }
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(DrawingViewEntity::VT_TYPE, Type);
  }
  void add_ParentIndex(flatbuffers::Offset<flatbuffers::String> ParentIndex) {
    fbb_.AddOffset(DrawingViewEntity::VT_PARENTINDEX, ParentIndex);
  }
  void add_ProjectGeometry(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ProjectGeometry) {
    fbb_.AddOffset(DrawingViewEntity::VT_PROJECTGEOMETRY, ProjectGeometry);
  }
  void add_HideProjectGeometry(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> HideProjectGeometry) {
    fbb_.AddOffset(DrawingViewEntity::VT_HIDEPROJECTGEOMETRY, HideProjectGeometry);
  }
  void add_ModelSketchGroup(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchData>>> ModelSketchGroup) {
    fbb_.AddOffset(DrawingViewEntity::VT_MODELSKETCHGROUP, ModelSketchGroup);
  }
  void add_ViewDirection(flatbuffers::Offset<flatbuffers::String> ViewDirection) {
    fbb_.AddOffset(DrawingViewEntity::VT_VIEWDIRECTION, ViewDirection);
  }
  void add_DocumentId(flatbuffers::Offset<flatbuffers::String> DocumentId) {
    fbb_.AddOffset(DrawingViewEntity::VT_DOCUMENTID, DocumentId);
  }
  void add_VersionId(flatbuffers::Offset<flatbuffers::String> VersionId) {
    fbb_.AddOffset(DrawingViewEntity::VT_VERSIONID, VersionId);
  }
  void add_UserDefNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> UserDefNames) {
    fbb_.AddOffset(DrawingViewEntity::VT_USERDEFNAMES, UserDefNames);
  }
  void add_UserDefDir(flatbuffers::Offset<flatbuffers::Vector<double>> UserDefDir) {
    fbb_.AddOffset(DrawingViewEntity::VT_USERDEFDIR, UserDefDir);
  }
  void add_BreakStyle(int32_t BreakStyle) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_BREAKSTYLE, BreakStyle, 0);
  }
  void add_BreakViewPnts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddBreakPts>>> BreakViewPnts) {
    fbb_.AddOffset(DrawingViewEntity::VT_BREAKVIEWPNTS, BreakViewPnts);
  }
  void add_BreakLines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> BreakLines) {
    fbb_.AddOffset(DrawingViewEntity::VT_BREAKLINES, BreakLines);
  }
  void add_GapSize(double GapSize) {
    fbb_.AddElement<double>(DrawingViewEntity::VT_GAPSIZE, GapSize, 0.0);
  }
  void add_OriginViewType(int32_t OriginViewType) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_ORIGINVIEWTYPE, OriginViewType, 0);
  }
  void add_ContourType(int32_t ContourType) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_CONTOURTYPE, ContourType, 0);
  }
  void add_ContourCenterPnt(flatbuffers::Offset<flatbuffers::Vector<double>> ContourCenterPnt) {
    fbb_.AddOffset(DrawingViewEntity::VT_CONTOURCENTERPNT, ContourCenterPnt);
  }
  void add_ContourRadius(double ContourRadius) {
    fbb_.AddElement<double>(DrawingViewEntity::VT_CONTOURRADIUS, ContourRadius, 0.0);
  }
  void add_ContourDisplayType(int32_t ContourDisplayType) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_CONTOURDISPLAYTYPE, ContourDisplayType, 0);
  }
  void add_ContourStyle(int32_t ContourStyle) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_CONTOURSTYLE, ContourStyle, 0);
  }
  void add_ContourLines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ContourLines) {
    fbb_.AddOffset(DrawingViewEntity::VT_CONTOURLINES, ContourLines);
  }
  void add_SelectContour(int32_t SelectContour) {
    fbb_.AddElement<int32_t>(DrawingViewEntity::VT_SELECTCONTOUR, SelectContour, 0);
  }
  void add_CropBounds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> CropBounds) {
    fbb_.AddOffset(DrawingViewEntity::VT_CROPBOUNDS, CropBounds);
  }
  void add_CropContouerLines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> CropContouerLines) {
    fbb_.AddOffset(DrawingViewEntity::VT_CROPCONTOUERLINES, CropContouerLines);
  }
  void add_HideOutLineGeometry(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> HideOutLineGeometry) {
    fbb_.AddOffset(DrawingViewEntity::VT_HIDEOUTLINEGEOMETRY, HideOutLineGeometry);
  }
  void add_OutLineGeometry(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> OutLineGeometry) {
    fbb_.AddOffset(DrawingViewEntity::VT_OUTLINEGEOMETRY, OutLineGeometry);
  }
  void add_isFlatPattern(bool isFlatPattern) {
    fbb_.AddElement<uint8_t>(DrawingViewEntity::VT_ISFLATPATTERN, static_cast<uint8_t>(isFlatPattern), 0);
  }
  void add_hasBendLine(bool hasBendLine) {
    fbb_.AddElement<uint8_t>(DrawingViewEntity::VT_HASBENDLINE, static_cast<uint8_t>(hasBendLine), 0);
  }
  void add_hasBendAnnotation(bool hasBendAnnotation) {
    fbb_.AddElement<uint8_t>(DrawingViewEntity::VT_HASBENDANNOTATION, static_cast<uint8_t>(hasBendAnnotation), 0);
  }
  void add_isReversal(bool isReversal) {
    fbb_.AddElement<uint8_t>(DrawingViewEntity::VT_ISREVERSAL, static_cast<uint8_t>(isReversal), 0);
  }
  void add_bendAnnotation(flatbuffers::Offset<flatbuffers::String> bendAnnotation) {
    fbb_.AddOffset(DrawingViewEntity::VT_BENDANNOTATION, bendAnnotation);
  }
  void add_rotAngle(double rotAngle) {
    fbb_.AddElement<double>(DrawingViewEntity::VT_ROTANGLE, rotAngle, 0.0);
  }
  void add_ModelBox(flatbuffers::Offset<flatbuffers::Vector<float>> ModelBox) {
    fbb_.AddOffset(DrawingViewEntity::VT_MODELBOX, ModelBox);
  }
  void add_ViewProperty(flatbuffers::Offset<FlatBufferDocSpace::ViewPropertyData> ViewProperty) {
    fbb_.AddOffset(DrawingViewEntity::VT_VIEWPROPERTY, ViewProperty);
  }
  void add_DetailContourLines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> DetailContourLines) {
    fbb_.AddOffset(DrawingViewEntity::VT_DETAILCONTOURLINES, DetailContourLines);
  }
  void add_Dimension(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Dimension) {
    fbb_.AddOffset(DrawingViewEntity::VT_DIMENSION, Dimension);
  }
  void add_Geometry(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Geometry) {
    fbb_.AddOffset(DrawingViewEntity::VT_GEOMETRY, Geometry);
  }
  void add_CenterMark(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> CenterMark) {
    fbb_.AddOffset(DrawingViewEntity::VT_CENTERMARK, CenterMark);
  }
  void add_Sections(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Sections) {
    fbb_.AddOffset(DrawingViewEntity::VT_SECTIONS, Sections);
  }
  void add_DraftSymbol(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> DraftSymbol) {
    fbb_.AddOffset(DrawingViewEntity::VT_DRAFTSYMBOL, DraftSymbol);
  }
  void add_HatchRegionDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>>> HatchRegionDatas) {
    fbb_.AddOffset(DrawingViewEntity::VT_HATCHREGIONDATAS, HatchRegionDatas);
  }
  void add_BrokenSecDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>>> BrokenSecDatas) {
    fbb_.AddOffset(DrawingViewEntity::VT_BROKENSECDATAS, BrokenSecDatas);
  }
  void add_MasterIndex(flatbuffers::Offset<flatbuffers::String> MasterIndex) {
    fbb_.AddOffset(DrawingViewEntity::VT_MASTERINDEX, MasterIndex);
  }
  void add_CustomViewFlag(flatbuffers::Offset<flatbuffers::Vector<int32_t>> CustomViewFlag) {
    fbb_.AddOffset(DrawingViewEntity::VT_CUSTOMVIEWFLAG, CustomViewFlag);
  }
  void add_CustomViewIndex(flatbuffers::Offset<flatbuffers::String> CustomViewIndex) {
    fbb_.AddOffset(DrawingViewEntity::VT_CUSTOMVIEWINDEX, CustomViewIndex);
  }
  void add_RemovedSectionCuttingLines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> RemovedSectionCuttingLines) {
    fbb_.AddOffset(DrawingViewEntity::VT_REMOVEDSECTIONCUTTINGLINES, RemovedSectionCuttingLines);
  }
  void add_AreaHatchDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>>> AreaHatchDatas) {
    fbb_.AddOffset(DrawingViewEntity::VT_AREAHATCHDATAS, AreaHatchDatas);
  }
  void add_TableIndex(flatbuffers::Offset<flatbuffers::String> TableIndex) {
    fbb_.AddOffset(DrawingViewEntity::VT_TABLEINDEX, TableIndex);
  }
  void add_IsRotateChild(bool IsRotateChild) {
    fbb_.AddElement<uint8_t>(DrawingViewEntity::VT_ISROTATECHILD, static_cast<uint8_t>(IsRotateChild), 0);
  }
  void add_IsRotateCenterMark(bool IsRotateCenterMark) {
    fbb_.AddElement<uint8_t>(DrawingViewEntity::VT_ISROTATECENTERMARK, static_cast<uint8_t>(IsRotateCenterMark), 0);
  }
  explicit DrawingViewEntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DrawingViewEntityBuilder &operator=(const DrawingViewEntityBuilder &);
  flatbuffers::Offset<DrawingViewEntity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DrawingViewEntity>(end);
    return o;
  }
};

inline flatbuffers::Offset<DrawingViewEntity> CreateDrawingViewEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    int32_t RenderMode = 0,
    int32_t ScaleType = 0,
    flatbuffers::Offset<flatbuffers::String> Index = 0,
    int32_t DimensionType = 0,
    int32_t ScrapEdgeVisible = 0,
    flatbuffers::Offset<flatbuffers::String> ViewScale = 0,
    float Scale = 0.0f,
    int32_t ViewType = 0,
    int32_t ViewAlignType = 0,
    int32_t UseParentStyle = 0,
    int32_t ViewVisible = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Up = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Norm = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> OrgViewBox = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> FocusViewBox = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> CenterPosition = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> ModelOrg = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> ThreeDCenterPosition = 0,
    int32_t SectionId = 0,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::String> ParentIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ProjectGeometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> HideProjectGeometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SketchData>>> ModelSketchGroup = 0,
    flatbuffers::Offset<flatbuffers::String> ViewDirection = 0,
    flatbuffers::Offset<flatbuffers::String> DocumentId = 0,
    flatbuffers::Offset<flatbuffers::String> VersionId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> UserDefNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> UserDefDir = 0,
    int32_t BreakStyle = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::AddBreakPts>>> BreakViewPnts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> BreakLines = 0,
    double GapSize = 0.0,
    int32_t OriginViewType = 0,
    int32_t ContourType = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> ContourCenterPnt = 0,
    double ContourRadius = 0.0,
    int32_t ContourDisplayType = 0,
    int32_t ContourStyle = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ContourLines = 0,
    int32_t SelectContour = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> CropBounds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> CropContouerLines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> HideOutLineGeometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> OutLineGeometry = 0,
    bool isFlatPattern = false,
    bool hasBendLine = false,
    bool hasBendAnnotation = false,
    bool isReversal = false,
    flatbuffers::Offset<flatbuffers::String> bendAnnotation = 0,
    double rotAngle = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<float>> ModelBox = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ViewPropertyData> ViewProperty = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> DetailContourLines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Dimension = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Geometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> CenterMark = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Sections = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> DraftSymbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>>> HatchRegionDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>>> BrokenSecDatas = 0,
    flatbuffers::Offset<flatbuffers::String> MasterIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> CustomViewFlag = 0,
    flatbuffers::Offset<flatbuffers::String> CustomViewIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> RemovedSectionCuttingLines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>>> AreaHatchDatas = 0,
    flatbuffers::Offset<flatbuffers::String> TableIndex = 0,
    bool IsRotateChild = false,
    bool IsRotateCenterMark = false) {
  DrawingViewEntityBuilder builder_(_fbb);
  builder_.add_rotAngle(rotAngle);
  builder_.add_ContourRadius(ContourRadius);
  builder_.add_GapSize(GapSize);
  builder_.add_TableIndex(TableIndex);
  builder_.add_AreaHatchDatas(AreaHatchDatas);
  builder_.add_RemovedSectionCuttingLines(RemovedSectionCuttingLines);
  builder_.add_CustomViewIndex(CustomViewIndex);
  builder_.add_CustomViewFlag(CustomViewFlag);
  builder_.add_MasterIndex(MasterIndex);
  builder_.add_BrokenSecDatas(BrokenSecDatas);
  builder_.add_HatchRegionDatas(HatchRegionDatas);
  builder_.add_DraftSymbol(DraftSymbol);
  builder_.add_Sections(Sections);
  builder_.add_CenterMark(CenterMark);
  builder_.add_Geometry(Geometry);
  builder_.add_Dimension(Dimension);
  builder_.add_DetailContourLines(DetailContourLines);
  builder_.add_ViewProperty(ViewProperty);
  builder_.add_ModelBox(ModelBox);
  builder_.add_bendAnnotation(bendAnnotation);
  builder_.add_OutLineGeometry(OutLineGeometry);
  builder_.add_HideOutLineGeometry(HideOutLineGeometry);
  builder_.add_CropContouerLines(CropContouerLines);
  builder_.add_CropBounds(CropBounds);
  builder_.add_SelectContour(SelectContour);
  builder_.add_ContourLines(ContourLines);
  builder_.add_ContourStyle(ContourStyle);
  builder_.add_ContourDisplayType(ContourDisplayType);
  builder_.add_ContourCenterPnt(ContourCenterPnt);
  builder_.add_ContourType(ContourType);
  builder_.add_OriginViewType(OriginViewType);
  builder_.add_BreakLines(BreakLines);
  builder_.add_BreakViewPnts(BreakViewPnts);
  builder_.add_BreakStyle(BreakStyle);
  builder_.add_UserDefDir(UserDefDir);
  builder_.add_UserDefNames(UserDefNames);
  builder_.add_VersionId(VersionId);
  builder_.add_DocumentId(DocumentId);
  builder_.add_ViewDirection(ViewDirection);
  builder_.add_ModelSketchGroup(ModelSketchGroup);
  builder_.add_HideProjectGeometry(HideProjectGeometry);
  builder_.add_ProjectGeometry(ProjectGeometry);
  builder_.add_ParentIndex(ParentIndex);
  builder_.add_Type(Type);
  builder_.add_SectionId(SectionId);
  builder_.add_ThreeDCenterPosition(ThreeDCenterPosition);
  builder_.add_ModelOrg(ModelOrg);
  builder_.add_CenterPosition(CenterPosition);
  builder_.add_FocusViewBox(FocusViewBox);
  builder_.add_OrgViewBox(OrgViewBox);
  builder_.add_Norm(Norm);
  builder_.add_Up(Up);
  builder_.add_ViewVisible(ViewVisible);
  builder_.add_UseParentStyle(UseParentStyle);
  builder_.add_ViewAlignType(ViewAlignType);
  builder_.add_ViewType(ViewType);
  builder_.add_Scale(Scale);
  builder_.add_ViewScale(ViewScale);
  builder_.add_ScrapEdgeVisible(ScrapEdgeVisible);
  builder_.add_DimensionType(DimensionType);
  builder_.add_Index(Index);
  builder_.add_ScaleType(ScaleType);
  builder_.add_RenderMode(RenderMode);
  builder_.add_Id(Id);
  builder_.add_IsRotateCenterMark(IsRotateCenterMark);
  builder_.add_IsRotateChild(IsRotateChild);
  builder_.add_isReversal(isReversal);
  builder_.add_hasBendAnnotation(hasBendAnnotation);
  builder_.add_hasBendLine(hasBendLine);
  builder_.add_isFlatPattern(isFlatPattern);
  return builder_.Finish();
}

inline flatbuffers::Offset<DrawingViewEntity> CreateDrawingViewEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    int32_t RenderMode = 0,
    int32_t ScaleType = 0,
    const char *Index = nullptr,
    int32_t DimensionType = 0,
    int32_t ScrapEdgeVisible = 0,
    const char *ViewScale = nullptr,
    float Scale = 0.0f,
    int32_t ViewType = 0,
    int32_t ViewAlignType = 0,
    int32_t UseParentStyle = 0,
    int32_t ViewVisible = 0,
    const std::vector<float> *Up = nullptr,
    const std::vector<float> *Norm = nullptr,
    const std::vector<float> *OrgViewBox = nullptr,
    const std::vector<float> *FocusViewBox = nullptr,
    const std::vector<float> *CenterPosition = nullptr,
    const std::vector<float> *ModelOrg = nullptr,
    const std::vector<float> *ThreeDCenterPosition = nullptr,
    int32_t SectionId = 0,
    const char *Type = nullptr,
    const char *ParentIndex = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ProjectGeometry = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *HideProjectGeometry = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SketchData>> *ModelSketchGroup = nullptr,
    const char *ViewDirection = nullptr,
    const char *DocumentId = nullptr,
    const char *VersionId = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *UserDefNames = nullptr,
    const std::vector<double> *UserDefDir = nullptr,
    int32_t BreakStyle = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::AddBreakPts>> *BreakViewPnts = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *BreakLines = nullptr,
    double GapSize = 0.0,
    int32_t OriginViewType = 0,
    int32_t ContourType = 0,
    const std::vector<double> *ContourCenterPnt = nullptr,
    double ContourRadius = 0.0,
    int32_t ContourDisplayType = 0,
    int32_t ContourStyle = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ContourLines = nullptr,
    int32_t SelectContour = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *CropBounds = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *CropContouerLines = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *HideOutLineGeometry = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *OutLineGeometry = nullptr,
    bool isFlatPattern = false,
    bool hasBendLine = false,
    bool hasBendAnnotation = false,
    bool isReversal = false,
    const char *bendAnnotation = nullptr,
    double rotAngle = 0.0,
    const std::vector<float> *ModelBox = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::ViewPropertyData> ViewProperty = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *DetailContourLines = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Dimension = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Geometry = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *CenterMark = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Sections = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *DraftSymbol = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>> *HatchRegionDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>> *BrokenSecDatas = nullptr,
    const char *MasterIndex = nullptr,
    const std::vector<int32_t> *CustomViewFlag = nullptr,
    const char *CustomViewIndex = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *RemovedSectionCuttingLines = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>> *AreaHatchDatas = nullptr,
    const char *TableIndex = nullptr,
    bool IsRotateChild = false,
    bool IsRotateCenterMark = false) {
  auto Index__ = Index ? _fbb.CreateString(Index) : 0;
  auto ViewScale__ = ViewScale ? _fbb.CreateString(ViewScale) : 0;
  auto Up__ = Up ? _fbb.CreateVector<float>(*Up) : 0;
  auto Norm__ = Norm ? _fbb.CreateVector<float>(*Norm) : 0;
  auto OrgViewBox__ = OrgViewBox ? _fbb.CreateVector<float>(*OrgViewBox) : 0;
  auto FocusViewBox__ = FocusViewBox ? _fbb.CreateVector<float>(*FocusViewBox) : 0;
  auto CenterPosition__ = CenterPosition ? _fbb.CreateVector<float>(*CenterPosition) : 0;
  auto ModelOrg__ = ModelOrg ? _fbb.CreateVector<float>(*ModelOrg) : 0;
  auto ThreeDCenterPosition__ = ThreeDCenterPosition ? _fbb.CreateVector<float>(*ThreeDCenterPosition) : 0;
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto ParentIndex__ = ParentIndex ? _fbb.CreateString(ParentIndex) : 0;
  auto ProjectGeometry__ = ProjectGeometry ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*ProjectGeometry) : 0;
  auto HideProjectGeometry__ = HideProjectGeometry ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*HideProjectGeometry) : 0;
  auto ModelSketchGroup__ = ModelSketchGroup ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SketchData>>(*ModelSketchGroup) : 0;
  auto ViewDirection__ = ViewDirection ? _fbb.CreateString(ViewDirection) : 0;
  auto DocumentId__ = DocumentId ? _fbb.CreateString(DocumentId) : 0;
  auto VersionId__ = VersionId ? _fbb.CreateString(VersionId) : 0;
  auto UserDefNames__ = UserDefNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*UserDefNames) : 0;
  auto UserDefDir__ = UserDefDir ? _fbb.CreateVector<double>(*UserDefDir) : 0;
  auto BreakViewPnts__ = BreakViewPnts ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::AddBreakPts>>(*BreakViewPnts) : 0;
  auto BreakLines__ = BreakLines ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*BreakLines) : 0;
  auto ContourCenterPnt__ = ContourCenterPnt ? _fbb.CreateVector<double>(*ContourCenterPnt) : 0;
  auto ContourLines__ = ContourLines ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*ContourLines) : 0;
  auto CropBounds__ = CropBounds ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*CropBounds) : 0;
  auto CropContouerLines__ = CropContouerLines ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*CropContouerLines) : 0;
  auto HideOutLineGeometry__ = HideOutLineGeometry ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*HideOutLineGeometry) : 0;
  auto OutLineGeometry__ = OutLineGeometry ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*OutLineGeometry) : 0;
  auto bendAnnotation__ = bendAnnotation ? _fbb.CreateString(bendAnnotation) : 0;
  auto ModelBox__ = ModelBox ? _fbb.CreateVector<float>(*ModelBox) : 0;
  auto DetailContourLines__ = DetailContourLines ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*DetailContourLines) : 0;
  auto Dimension__ = Dimension ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*Dimension) : 0;
  auto Geometry__ = Geometry ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*Geometry) : 0;
  auto CenterMark__ = CenterMark ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*CenterMark) : 0;
  auto Sections__ = Sections ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*Sections) : 0;
  auto DraftSymbol__ = DraftSymbol ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*DraftSymbol) : 0;
  auto HatchRegionDatas__ = HatchRegionDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>>(*HatchRegionDatas) : 0;
  auto BrokenSecDatas__ = BrokenSecDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>>(*BrokenSecDatas) : 0;
  auto MasterIndex__ = MasterIndex ? _fbb.CreateString(MasterIndex) : 0;
  auto CustomViewFlag__ = CustomViewFlag ? _fbb.CreateVector<int32_t>(*CustomViewFlag) : 0;
  auto CustomViewIndex__ = CustomViewIndex ? _fbb.CreateString(CustomViewIndex) : 0;
  auto RemovedSectionCuttingLines__ = RemovedSectionCuttingLines ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*RemovedSectionCuttingLines) : 0;
  auto AreaHatchDatas__ = AreaHatchDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::HatchRegionElements>>(*AreaHatchDatas) : 0;
  auto TableIndex__ = TableIndex ? _fbb.CreateString(TableIndex) : 0;
  return FlatBufferDocSpace::CreateDrawingViewEntity(
      _fbb,
      Id,
      RenderMode,
      ScaleType,
      Index__,
      DimensionType,
      ScrapEdgeVisible,
      ViewScale__,
      Scale,
      ViewType,
      ViewAlignType,
      UseParentStyle,
      ViewVisible,
      Up__,
      Norm__,
      OrgViewBox__,
      FocusViewBox__,
      CenterPosition__,
      ModelOrg__,
      ThreeDCenterPosition__,
      SectionId,
      Type__,
      ParentIndex__,
      ProjectGeometry__,
      HideProjectGeometry__,
      ModelSketchGroup__,
      ViewDirection__,
      DocumentId__,
      VersionId__,
      UserDefNames__,
      UserDefDir__,
      BreakStyle,
      BreakViewPnts__,
      BreakLines__,
      GapSize,
      OriginViewType,
      ContourType,
      ContourCenterPnt__,
      ContourRadius,
      ContourDisplayType,
      ContourStyle,
      ContourLines__,
      SelectContour,
      CropBounds__,
      CropContouerLines__,
      HideOutLineGeometry__,
      OutLineGeometry__,
      isFlatPattern,
      hasBendLine,
      hasBendAnnotation,
      isReversal,
      bendAnnotation__,
      rotAngle,
      ModelBox__,
      ViewProperty,
      DetailContourLines__,
      Dimension__,
      Geometry__,
      CenterMark__,
      Sections__,
      DraftSymbol__,
      HatchRegionDatas__,
      BrokenSecDatas__,
      MasterIndex__,
      CustomViewFlag__,
      CustomViewIndex__,
      RemovedSectionCuttingLines__,
      AreaHatchDatas__,
      TableIndex__,
      IsRotateChild,
      IsRotateCenterMark);
}

struct ChamferDataElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChamferDataElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAMFERTYPE = 4,
    VT_FIRSTPARAM = 6,
    VT_SECONDPARAM = 8
  };
  int32_t ChamferType() const {
    return GetField<int32_t>(VT_CHAMFERTYPE, 0);
  }
  double FirstParam() const {
    return GetField<double>(VT_FIRSTPARAM, 0.0);
  }
  double SecondParam() const {
    return GetField<double>(VT_SECONDPARAM, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHAMFERTYPE) &&
           VerifyField<double>(verifier, VT_FIRSTPARAM) &&
           VerifyField<double>(verifier, VT_SECONDPARAM) &&
           verifier.EndTable();
  }
};

struct ChamferDataElementBuilder {
  typedef ChamferDataElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ChamferType(int32_t ChamferType) {
    fbb_.AddElement<int32_t>(ChamferDataElement::VT_CHAMFERTYPE, ChamferType, 0);
  }
  void add_FirstParam(double FirstParam) {
    fbb_.AddElement<double>(ChamferDataElement::VT_FIRSTPARAM, FirstParam, 0.0);
  }
  void add_SecondParam(double SecondParam) {
    fbb_.AddElement<double>(ChamferDataElement::VT_SECONDPARAM, SecondParam, 0.0);
  }
  explicit ChamferDataElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChamferDataElementBuilder &operator=(const ChamferDataElementBuilder &);
  flatbuffers::Offset<ChamferDataElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChamferDataElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChamferDataElement> CreateChamferDataElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ChamferType = 0,
    double FirstParam = 0.0,
    double SecondParam = 0.0) {
  ChamferDataElementBuilder builder_(_fbb);
  builder_.add_SecondParam(SecondParam);
  builder_.add_FirstParam(FirstParam);
  builder_.add_ChamferType(ChamferType);
  return builder_.Finish();
}

struct CloudPointData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloudPointDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLOUDPOINT = 4
  };
  const flatbuffers::Vector<double> *CloudPoint() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CLOUDPOINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLOUDPOINT) &&
           verifier.VerifyVector(CloudPoint()) &&
           verifier.EndTable();
  }
};

struct CloudPointDataBuilder {
  typedef CloudPointData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CloudPoint(flatbuffers::Offset<flatbuffers::Vector<double>> CloudPoint) {
    fbb_.AddOffset(CloudPointData::VT_CLOUDPOINT, CloudPoint);
  }
  explicit CloudPointDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CloudPointDataBuilder &operator=(const CloudPointDataBuilder &);
  flatbuffers::Offset<CloudPointData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloudPointData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CloudPointData> CreateCloudPointData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> CloudPoint = 0) {
  CloudPointDataBuilder builder_(_fbb);
  builder_.add_CloudPoint(CloudPoint);
  return builder_.Finish();
}

inline flatbuffers::Offset<CloudPointData> CreateCloudPointDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *CloudPoint = nullptr) {
  auto CloudPoint__ = CloudPoint ? _fbb.CreateVector<double>(*CloudPoint) : 0;
  return FlatBufferDocSpace::CreateCloudPointData(
      _fbb,
      CloudPoint__);
}

struct HoleDataElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HoleDataElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOLETYPE = 4,
    VT_ISTHROUGH = 6,
    VT_HOLEDIAMETER = 8,
    VT_HOLEDEPTH = 10,
    VT_HEADHOLEDIAMETER = 12,
    VT_HEADHOLEDEPTH = 14,
    VT_HEADANGLE = 16,
    VT_ENDANGLE = 18,
    VT_DESIGNATION = 20,
    VT_THREADDIA = 22,
    VT_THREADDEPTH = 24,
    VT_DIMTYPE = 26,
    VT_HOLENUMS = 28,
    VT_SLOTLENGTH = 30
  };
  int32_t HoleType() const {
    return GetField<int32_t>(VT_HOLETYPE, 0);
  }
  int32_t IsThrough() const {
    return GetField<int32_t>(VT_ISTHROUGH, 0);
  }
  double HoleDiameter() const {
    return GetField<double>(VT_HOLEDIAMETER, 0.0);
  }
  double HoleDepth() const {
    return GetField<double>(VT_HOLEDEPTH, 0.0);
  }
  double HeadHoleDiameter() const {
    return GetField<double>(VT_HEADHOLEDIAMETER, 0.0);
  }
  double HeadHoleDepth() const {
    return GetField<double>(VT_HEADHOLEDEPTH, 0.0);
  }
  double HeadAngle() const {
    return GetField<double>(VT_HEADANGLE, 0.0);
  }
  double EndAngle() const {
    return GetField<double>(VT_ENDANGLE, 0.0);
  }
  const flatbuffers::String *Designation() const {
    return GetPointer<const flatbuffers::String *>(VT_DESIGNATION);
  }
  double ThreadDia() const {
    return GetField<double>(VT_THREADDIA, 0.0);
  }
  double ThreadDepth() const {
    return GetField<double>(VT_THREADDEPTH, 0.0);
  }
  int32_t DimType() const {
    return GetField<int32_t>(VT_DIMTYPE, 0);
  }
  int32_t HoleNums() const {
    return GetField<int32_t>(VT_HOLENUMS, 0);
  }
  double SlotLength() const {
    return GetField<double>(VT_SLOTLENGTH, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HOLETYPE) &&
           VerifyField<int32_t>(verifier, VT_ISTHROUGH) &&
           VerifyField<double>(verifier, VT_HOLEDIAMETER) &&
           VerifyField<double>(verifier, VT_HOLEDEPTH) &&
           VerifyField<double>(verifier, VT_HEADHOLEDIAMETER) &&
           VerifyField<double>(verifier, VT_HEADHOLEDEPTH) &&
           VerifyField<double>(verifier, VT_HEADANGLE) &&
           VerifyField<double>(verifier, VT_ENDANGLE) &&
           VerifyOffset(verifier, VT_DESIGNATION) &&
           verifier.VerifyString(Designation()) &&
           VerifyField<double>(verifier, VT_THREADDIA) &&
           VerifyField<double>(verifier, VT_THREADDEPTH) &&
           VerifyField<int32_t>(verifier, VT_DIMTYPE) &&
           VerifyField<int32_t>(verifier, VT_HOLENUMS) &&
           VerifyField<double>(verifier, VT_SLOTLENGTH) &&
           verifier.EndTable();
  }
};

struct HoleDataElementBuilder {
  typedef HoleDataElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HoleType(int32_t HoleType) {
    fbb_.AddElement<int32_t>(HoleDataElement::VT_HOLETYPE, HoleType, 0);
  }
  void add_IsThrough(int32_t IsThrough) {
    fbb_.AddElement<int32_t>(HoleDataElement::VT_ISTHROUGH, IsThrough, 0);
  }
  void add_HoleDiameter(double HoleDiameter) {
    fbb_.AddElement<double>(HoleDataElement::VT_HOLEDIAMETER, HoleDiameter, 0.0);
  }
  void add_HoleDepth(double HoleDepth) {
    fbb_.AddElement<double>(HoleDataElement::VT_HOLEDEPTH, HoleDepth, 0.0);
  }
  void add_HeadHoleDiameter(double HeadHoleDiameter) {
    fbb_.AddElement<double>(HoleDataElement::VT_HEADHOLEDIAMETER, HeadHoleDiameter, 0.0);
  }
  void add_HeadHoleDepth(double HeadHoleDepth) {
    fbb_.AddElement<double>(HoleDataElement::VT_HEADHOLEDEPTH, HeadHoleDepth, 0.0);
  }
  void add_HeadAngle(double HeadAngle) {
    fbb_.AddElement<double>(HoleDataElement::VT_HEADANGLE, HeadAngle, 0.0);
  }
  void add_EndAngle(double EndAngle) {
    fbb_.AddElement<double>(HoleDataElement::VT_ENDANGLE, EndAngle, 0.0);
  }
  void add_Designation(flatbuffers::Offset<flatbuffers::String> Designation) {
    fbb_.AddOffset(HoleDataElement::VT_DESIGNATION, Designation);
  }
  void add_ThreadDia(double ThreadDia) {
    fbb_.AddElement<double>(HoleDataElement::VT_THREADDIA, ThreadDia, 0.0);
  }
  void add_ThreadDepth(double ThreadDepth) {
    fbb_.AddElement<double>(HoleDataElement::VT_THREADDEPTH, ThreadDepth, 0.0);
  }
  void add_DimType(int32_t DimType) {
    fbb_.AddElement<int32_t>(HoleDataElement::VT_DIMTYPE, DimType, 0);
  }
  void add_HoleNums(int32_t HoleNums) {
    fbb_.AddElement<int32_t>(HoleDataElement::VT_HOLENUMS, HoleNums, 0);
  }
  void add_SlotLength(double SlotLength) {
    fbb_.AddElement<double>(HoleDataElement::VT_SLOTLENGTH, SlotLength, 0.0);
  }
  explicit HoleDataElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HoleDataElementBuilder &operator=(const HoleDataElementBuilder &);
  flatbuffers::Offset<HoleDataElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HoleDataElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<HoleDataElement> CreateHoleDataElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t HoleType = 0,
    int32_t IsThrough = 0,
    double HoleDiameter = 0.0,
    double HoleDepth = 0.0,
    double HeadHoleDiameter = 0.0,
    double HeadHoleDepth = 0.0,
    double HeadAngle = 0.0,
    double EndAngle = 0.0,
    flatbuffers::Offset<flatbuffers::String> Designation = 0,
    double ThreadDia = 0.0,
    double ThreadDepth = 0.0,
    int32_t DimType = 0,
    int32_t HoleNums = 0,
    double SlotLength = 0.0) {
  HoleDataElementBuilder builder_(_fbb);
  builder_.add_SlotLength(SlotLength);
  builder_.add_ThreadDepth(ThreadDepth);
  builder_.add_ThreadDia(ThreadDia);
  builder_.add_EndAngle(EndAngle);
  builder_.add_HeadAngle(HeadAngle);
  builder_.add_HeadHoleDepth(HeadHoleDepth);
  builder_.add_HeadHoleDiameter(HeadHoleDiameter);
  builder_.add_HoleDepth(HoleDepth);
  builder_.add_HoleDiameter(HoleDiameter);
  builder_.add_HoleNums(HoleNums);
  builder_.add_DimType(DimType);
  builder_.add_Designation(Designation);
  builder_.add_IsThrough(IsThrough);
  builder_.add_HoleType(HoleType);
  return builder_.Finish();
}

inline flatbuffers::Offset<HoleDataElement> CreateHoleDataElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t HoleType = 0,
    int32_t IsThrough = 0,
    double HoleDiameter = 0.0,
    double HoleDepth = 0.0,
    double HeadHoleDiameter = 0.0,
    double HeadHoleDepth = 0.0,
    double HeadAngle = 0.0,
    double EndAngle = 0.0,
    const char *Designation = nullptr,
    double ThreadDia = 0.0,
    double ThreadDepth = 0.0,
    int32_t DimType = 0,
    int32_t HoleNums = 0,
    double SlotLength = 0.0) {
  auto Designation__ = Designation ? _fbb.CreateString(Designation) : 0;
  return FlatBufferDocSpace::CreateHoleDataElement(
      _fbb,
      HoleType,
      IsThrough,
      HoleDiameter,
      HoleDepth,
      HeadHoleDiameter,
      HeadHoleDepth,
      HeadAngle,
      EndAngle,
      Designation__,
      ThreadDia,
      ThreadDepth,
      DimType,
      HoleNums,
      SlotLength);
}

struct HoleTableAxis FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HoleTableAxisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XLAB = 4,
    VT_YLAB = 6,
    VT_XARROWTYPE = 8,
    VT_YARROWTYPE = 10,
    VT_XCONPTTYPE = 12,
    VT_YCONPTTYPE = 14,
    VT_SHOWZERO = 16,
    VT_XPNTS = 18,
    VT_YPNTS = 20
  };
  const flatbuffers::String *XLab() const {
    return GetPointer<const flatbuffers::String *>(VT_XLAB);
  }
  const flatbuffers::String *YLab() const {
    return GetPointer<const flatbuffers::String *>(VT_YLAB);
  }
  int32_t XArrowType() const {
    return GetField<int32_t>(VT_XARROWTYPE, 0);
  }
  int32_t YArrowType() const {
    return GetField<int32_t>(VT_YARROWTYPE, 0);
  }
  int32_t XConPtType() const {
    return GetField<int32_t>(VT_XCONPTTYPE, 0);
  }
  int32_t YConPtType() const {
    return GetField<int32_t>(VT_YCONPTTYPE, 0);
  }
  int32_t ShowZero() const {
    return GetField<int32_t>(VT_SHOWZERO, 0);
  }
  const flatbuffers::Vector<double> *XPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_XPNTS);
  }
  const flatbuffers::Vector<double> *YPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_YPNTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XLAB) &&
           verifier.VerifyString(XLab()) &&
           VerifyOffset(verifier, VT_YLAB) &&
           verifier.VerifyString(YLab()) &&
           VerifyField<int32_t>(verifier, VT_XARROWTYPE) &&
           VerifyField<int32_t>(verifier, VT_YARROWTYPE) &&
           VerifyField<int32_t>(verifier, VT_XCONPTTYPE) &&
           VerifyField<int32_t>(verifier, VT_YCONPTTYPE) &&
           VerifyField<int32_t>(verifier, VT_SHOWZERO) &&
           VerifyOffset(verifier, VT_XPNTS) &&
           verifier.VerifyVector(XPnts()) &&
           VerifyOffset(verifier, VT_YPNTS) &&
           verifier.VerifyVector(YPnts()) &&
           verifier.EndTable();
  }
};

struct HoleTableAxisBuilder {
  typedef HoleTableAxis Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_XLab(flatbuffers::Offset<flatbuffers::String> XLab) {
    fbb_.AddOffset(HoleTableAxis::VT_XLAB, XLab);
  }
  void add_YLab(flatbuffers::Offset<flatbuffers::String> YLab) {
    fbb_.AddOffset(HoleTableAxis::VT_YLAB, YLab);
  }
  void add_XArrowType(int32_t XArrowType) {
    fbb_.AddElement<int32_t>(HoleTableAxis::VT_XARROWTYPE, XArrowType, 0);
  }
  void add_YArrowType(int32_t YArrowType) {
    fbb_.AddElement<int32_t>(HoleTableAxis::VT_YARROWTYPE, YArrowType, 0);
  }
  void add_XConPtType(int32_t XConPtType) {
    fbb_.AddElement<int32_t>(HoleTableAxis::VT_XCONPTTYPE, XConPtType, 0);
  }
  void add_YConPtType(int32_t YConPtType) {
    fbb_.AddElement<int32_t>(HoleTableAxis::VT_YCONPTTYPE, YConPtType, 0);
  }
  void add_ShowZero(int32_t ShowZero) {
    fbb_.AddElement<int32_t>(HoleTableAxis::VT_SHOWZERO, ShowZero, 0);
  }
  void add_XPnts(flatbuffers::Offset<flatbuffers::Vector<double>> XPnts) {
    fbb_.AddOffset(HoleTableAxis::VT_XPNTS, XPnts);
  }
  void add_YPnts(flatbuffers::Offset<flatbuffers::Vector<double>> YPnts) {
    fbb_.AddOffset(HoleTableAxis::VT_YPNTS, YPnts);
  }
  explicit HoleTableAxisBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HoleTableAxisBuilder &operator=(const HoleTableAxisBuilder &);
  flatbuffers::Offset<HoleTableAxis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HoleTableAxis>(end);
    return o;
  }
};

inline flatbuffers::Offset<HoleTableAxis> CreateHoleTableAxis(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> XLab = 0,
    flatbuffers::Offset<flatbuffers::String> YLab = 0,
    int32_t XArrowType = 0,
    int32_t YArrowType = 0,
    int32_t XConPtType = 0,
    int32_t YConPtType = 0,
    int32_t ShowZero = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> XPnts = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> YPnts = 0) {
  HoleTableAxisBuilder builder_(_fbb);
  builder_.add_YPnts(YPnts);
  builder_.add_XPnts(XPnts);
  builder_.add_ShowZero(ShowZero);
  builder_.add_YConPtType(YConPtType);
  builder_.add_XConPtType(XConPtType);
  builder_.add_YArrowType(YArrowType);
  builder_.add_XArrowType(XArrowType);
  builder_.add_YLab(YLab);
  builder_.add_XLab(XLab);
  return builder_.Finish();
}

inline flatbuffers::Offset<HoleTableAxis> CreateHoleTableAxisDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *XLab = nullptr,
    const char *YLab = nullptr,
    int32_t XArrowType = 0,
    int32_t YArrowType = 0,
    int32_t XConPtType = 0,
    int32_t YConPtType = 0,
    int32_t ShowZero = 0,
    const std::vector<double> *XPnts = nullptr,
    const std::vector<double> *YPnts = nullptr) {
  auto XLab__ = XLab ? _fbb.CreateString(XLab) : 0;
  auto YLab__ = YLab ? _fbb.CreateString(YLab) : 0;
  auto XPnts__ = XPnts ? _fbb.CreateVector<double>(*XPnts) : 0;
  auto YPnts__ = YPnts ? _fbb.CreateVector<double>(*YPnts) : 0;
  return FlatBufferDocSpace::CreateHoleTableAxis(
      _fbb,
      XLab__,
      YLab__,
      XArrowType,
      YArrowType,
      XConPtType,
      YConPtType,
      ShowZero,
      XPnts__,
      YPnts__);
}

struct HoleSizeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HoleSizeDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOLEDATA = 4,
    VT_TOLTYPE = 6,
    VT_VALPRECISION = 8,
    VT_TOLPRECISION = 10,
    VT_FITTOLCATEGORY = 12,
    VT_FITTOLSHOWTYPE = 14
  };
  const FlatBufferDocSpace::HoleDataElement *HoleData() const {
    return GetPointer<const FlatBufferDocSpace::HoleDataElement *>(VT_HOLEDATA);
  }
  int32_t TolType() const {
    return GetField<int32_t>(VT_TOLTYPE, 0);
  }
  int32_t ValPrecision() const {
    return GetField<int32_t>(VT_VALPRECISION, 0);
  }
  int32_t TolPrecision() const {
    return GetField<int32_t>(VT_TOLPRECISION, 0);
  }
  int32_t FitTolCategory() const {
    return GetField<int32_t>(VT_FITTOLCATEGORY, 0);
  }
  int32_t FitTolShowType() const {
    return GetField<int32_t>(VT_FITTOLSHOWTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HOLEDATA) &&
           verifier.VerifyTable(HoleData()) &&
           VerifyField<int32_t>(verifier, VT_TOLTYPE) &&
           VerifyField<int32_t>(verifier, VT_VALPRECISION) &&
           VerifyField<int32_t>(verifier, VT_TOLPRECISION) &&
           VerifyField<int32_t>(verifier, VT_FITTOLCATEGORY) &&
           VerifyField<int32_t>(verifier, VT_FITTOLSHOWTYPE) &&
           verifier.EndTable();
  }
};

struct HoleSizeDataBuilder {
  typedef HoleSizeData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HoleData(flatbuffers::Offset<FlatBufferDocSpace::HoleDataElement> HoleData) {
    fbb_.AddOffset(HoleSizeData::VT_HOLEDATA, HoleData);
  }
  void add_TolType(int32_t TolType) {
    fbb_.AddElement<int32_t>(HoleSizeData::VT_TOLTYPE, TolType, 0);
  }
  void add_ValPrecision(int32_t ValPrecision) {
    fbb_.AddElement<int32_t>(HoleSizeData::VT_VALPRECISION, ValPrecision, 0);
  }
  void add_TolPrecision(int32_t TolPrecision) {
    fbb_.AddElement<int32_t>(HoleSizeData::VT_TOLPRECISION, TolPrecision, 0);
  }
  void add_FitTolCategory(int32_t FitTolCategory) {
    fbb_.AddElement<int32_t>(HoleSizeData::VT_FITTOLCATEGORY, FitTolCategory, 0);
  }
  void add_FitTolShowType(int32_t FitTolShowType) {
    fbb_.AddElement<int32_t>(HoleSizeData::VT_FITTOLSHOWTYPE, FitTolShowType, 0);
  }
  explicit HoleSizeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HoleSizeDataBuilder &operator=(const HoleSizeDataBuilder &);
  flatbuffers::Offset<HoleSizeData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HoleSizeData>(end);
    return o;
  }
};

inline flatbuffers::Offset<HoleSizeData> CreateHoleSizeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::HoleDataElement> HoleData = 0,
    int32_t TolType = 0,
    int32_t ValPrecision = 0,
    int32_t TolPrecision = 0,
    int32_t FitTolCategory = 0,
    int32_t FitTolShowType = 0) {
  HoleSizeDataBuilder builder_(_fbb);
  builder_.add_FitTolShowType(FitTolShowType);
  builder_.add_FitTolCategory(FitTolCategory);
  builder_.add_TolPrecision(TolPrecision);
  builder_.add_ValPrecision(ValPrecision);
  builder_.add_TolType(TolType);
  builder_.add_HoleData(HoleData);
  return builder_.Finish();
}

struct HolePosData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HolePosDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTDATAS = 4,
    VT_TOLPRECISION = 6,
    VT_TOLTYPE = 8,
    VT_VALPRECISION = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>> *TextDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>> *>(VT_TEXTDATAS);
  }
  int32_t TolPrecision() const {
    return GetField<int32_t>(VT_TOLPRECISION, 0);
  }
  int32_t TolType() const {
    return GetField<int32_t>(VT_TOLTYPE, 0);
  }
  int32_t ValPrecision() const {
    return GetField<int32_t>(VT_VALPRECISION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTDATAS) &&
           verifier.VerifyVector(TextDatas()) &&
           verifier.VerifyVectorOfTables(TextDatas()) &&
           VerifyField<int32_t>(verifier, VT_TOLPRECISION) &&
           VerifyField<int32_t>(verifier, VT_TOLTYPE) &&
           VerifyField<int32_t>(verifier, VT_VALPRECISION) &&
           verifier.EndTable();
  }
};

struct HolePosDataBuilder {
  typedef HolePosData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TextDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>>> TextDatas) {
    fbb_.AddOffset(HolePosData::VT_TEXTDATAS, TextDatas);
  }
  void add_TolPrecision(int32_t TolPrecision) {
    fbb_.AddElement<int32_t>(HolePosData::VT_TOLPRECISION, TolPrecision, 0);
  }
  void add_TolType(int32_t TolType) {
    fbb_.AddElement<int32_t>(HolePosData::VT_TOLTYPE, TolType, 0);
  }
  void add_ValPrecision(int32_t ValPrecision) {
    fbb_.AddElement<int32_t>(HolePosData::VT_VALPRECISION, ValPrecision, 0);
  }
  explicit HolePosDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HolePosDataBuilder &operator=(const HolePosDataBuilder &);
  flatbuffers::Offset<HolePosData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HolePosData>(end);
    return o;
  }
};

inline flatbuffers::Offset<HolePosData> CreateHolePosData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>>> TextDatas = 0,
    int32_t TolPrecision = 0,
    int32_t TolType = 0,
    int32_t ValPrecision = 0) {
  HolePosDataBuilder builder_(_fbb);
  builder_.add_ValPrecision(ValPrecision);
  builder_.add_TolType(TolType);
  builder_.add_TolPrecision(TolPrecision);
  builder_.add_TextDatas(TextDatas);
  return builder_.Finish();
}

inline flatbuffers::Offset<HolePosData> CreateHolePosDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TextData>> *TextDatas = nullptr,
    int32_t TolPrecision = 0,
    int32_t TolType = 0,
    int32_t ValPrecision = 0) {
  auto TextDatas__ = TextDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TextData>>(*TextDatas) : 0;
  return FlatBufferDocSpace::CreateHolePosData(
      _fbb,
      TextDatas__,
      TolPrecision,
      TolType,
      ValPrecision);
}

struct CellVariableData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellVariableDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROW = 4,
    VT_COL = 6,
    VT_NAME = 8
  };
  int32_t Row() const {
    return GetField<int32_t>(VT_ROW, 0);
  }
  int32_t Col() const {
    return GetField<int32_t>(VT_COL, 0);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROW) &&
           VerifyField<int32_t>(verifier, VT_COL) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           verifier.EndTable();
  }
};

struct CellVariableDataBuilder {
  typedef CellVariableData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Row(int32_t Row) {
    fbb_.AddElement<int32_t>(CellVariableData::VT_ROW, Row, 0);
  }
  void add_Col(int32_t Col) {
    fbb_.AddElement<int32_t>(CellVariableData::VT_COL, Col, 0);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(CellVariableData::VT_NAME, Name);
  }
  explicit CellVariableDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellVariableDataBuilder &operator=(const CellVariableDataBuilder &);
  flatbuffers::Offset<CellVariableData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellVariableData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellVariableData> CreateCellVariableData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Row = 0,
    int32_t Col = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0) {
  CellVariableDataBuilder builder_(_fbb);
  builder_.add_Name(Name);
  builder_.add_Col(Col);
  builder_.add_Row(Row);
  return builder_.Finish();
}

inline flatbuffers::Offset<CellVariableData> CreateCellVariableDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Row = 0,
    int32_t Col = 0,
    const char *Name = nullptr) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  return FlatBufferDocSpace::CreateCellVariableData(
      _fbb,
      Row,
      Col,
      Name__);
}

struct MergeCellsInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MergeCellsInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MERGECELL = 4
  };
  const flatbuffers::Vector<int32_t> *MergeCell() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MERGECELL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MERGECELL) &&
           verifier.VerifyVector(MergeCell()) &&
           verifier.EndTable();
  }
};

struct MergeCellsInfoDataBuilder {
  typedef MergeCellsInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MergeCell(flatbuffers::Offset<flatbuffers::Vector<int32_t>> MergeCell) {
    fbb_.AddOffset(MergeCellsInfoData::VT_MERGECELL, MergeCell);
  }
  explicit MergeCellsInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MergeCellsInfoDataBuilder &operator=(const MergeCellsInfoDataBuilder &);
  flatbuffers::Offset<MergeCellsInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MergeCellsInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MergeCellsInfoData> CreateMergeCellsInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> MergeCell = 0) {
  MergeCellsInfoDataBuilder builder_(_fbb);
  builder_.add_MergeCell(MergeCell);
  return builder_.Finish();
}

inline flatbuffers::Offset<MergeCellsInfoData> CreateMergeCellsInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *MergeCell = nullptr) {
  auto MergeCell__ = MergeCell ? _fbb.CreateVector<int32_t>(*MergeCell) : 0;
  return FlatBufferDocSpace::CreateMergeCellsInfoData(
      _fbb,
      MergeCell__);
}

struct IncrementalDrawingData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IncrementalDrawingDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDELEMENTS = 4,
    VT_MODELEMENTS = 6,
    VT_DELELEMENTS = 8,
    VT_ADDVIEWS = 10,
    VT_MODVIEWS = 12,
    VT_DELVIEWS = 14,
    VT_ADDENTITIES = 16,
    VT_MODENTITIES = 18,
    VT_DELENTITIES = 20,
    VT_FEATUREDATAS = 22,
    VT_ADDVARIABLES = 24,
    VT_DELVARIABLES = 26,
    VT_MODVARIABLES = 28,
    VT_ADDLAYER = 30,
    VT_MODLAYER = 32,
    VT_DELLAYER = 34,
    VT_CURRLAYER = 36
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *AddElements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_ADDELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ModElements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_MODELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>> *DelElements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>> *>(VT_DELELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *AddViews() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *>(VT_ADDVIEWS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *ModViews() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *>(VT_MODVIEWS);
  }
  const flatbuffers::Vector<int32_t> *DelViews() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELVIEWS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *AddEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_ADDENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *ModEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_MODENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>> *DelEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>> *>(VT_DELENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *>(VT_FEATUREDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *AddVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_ADDVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *DelVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *>(VT_DELVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *ModVariables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_MODVARIABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *AddLayer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *>(VT_ADDLAYER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *ModLayer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *>(VT_MODLAYER);
  }
  const flatbuffers::Vector<int32_t> *DelLayer() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELLAYER);
  }
  int32_t CurrLayer() const {
    return GetField<int32_t>(VT_CURRLAYER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDELEMENTS) &&
           verifier.VerifyVector(AddElements()) &&
           verifier.VerifyVectorOfTables(AddElements()) &&
           VerifyOffset(verifier, VT_MODELEMENTS) &&
           verifier.VerifyVector(ModElements()) &&
           verifier.VerifyVectorOfTables(ModElements()) &&
           VerifyOffset(verifier, VT_DELELEMENTS) &&
           verifier.VerifyVector(DelElements()) &&
           verifier.VerifyVectorOfTables(DelElements()) &&
           VerifyOffset(verifier, VT_ADDVIEWS) &&
           verifier.VerifyVector(AddViews()) &&
           verifier.VerifyVectorOfTables(AddViews()) &&
           VerifyOffset(verifier, VT_MODVIEWS) &&
           verifier.VerifyVector(ModViews()) &&
           verifier.VerifyVectorOfTables(ModViews()) &&
           VerifyOffset(verifier, VT_DELVIEWS) &&
           verifier.VerifyVector(DelViews()) &&
           VerifyOffset(verifier, VT_ADDENTITIES) &&
           verifier.VerifyVector(AddEntities()) &&
           verifier.VerifyVectorOfTables(AddEntities()) &&
           VerifyOffset(verifier, VT_MODENTITIES) &&
           verifier.VerifyVector(ModEntities()) &&
           verifier.VerifyVectorOfTables(ModEntities()) &&
           VerifyOffset(verifier, VT_DELENTITIES) &&
           verifier.VerifyVector(DelEntities()) &&
           verifier.VerifyVectorOfTables(DelEntities()) &&
           VerifyOffset(verifier, VT_FEATUREDATAS) &&
           verifier.VerifyVector(FeatureDatas()) &&
           verifier.VerifyVectorOfTables(FeatureDatas()) &&
           VerifyOffset(verifier, VT_ADDVARIABLES) &&
           verifier.VerifyVector(AddVariables()) &&
           verifier.VerifyVectorOfTables(AddVariables()) &&
           VerifyOffset(verifier, VT_DELVARIABLES) &&
           verifier.VerifyVector(DelVariables()) &&
           verifier.VerifyVectorOfTables(DelVariables()) &&
           VerifyOffset(verifier, VT_MODVARIABLES) &&
           verifier.VerifyVector(ModVariables()) &&
           verifier.VerifyVectorOfTables(ModVariables()) &&
           VerifyOffset(verifier, VT_ADDLAYER) &&
           verifier.VerifyVector(AddLayer()) &&
           verifier.VerifyVectorOfTables(AddLayer()) &&
           VerifyOffset(verifier, VT_MODLAYER) &&
           verifier.VerifyVector(ModLayer()) &&
           verifier.VerifyVectorOfTables(ModLayer()) &&
           VerifyOffset(verifier, VT_DELLAYER) &&
           verifier.VerifyVector(DelLayer()) &&
           VerifyField<int32_t>(verifier, VT_CURRLAYER) &&
           verifier.EndTable();
  }
};

struct IncrementalDrawingDataBuilder {
  typedef IncrementalDrawingData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AddElements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> AddElements) {
    fbb_.AddOffset(IncrementalDrawingData::VT_ADDELEMENTS, AddElements);
  }
  void add_ModElements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ModElements) {
    fbb_.AddOffset(IncrementalDrawingData::VT_MODELEMENTS, ModElements);
  }
  void add_DelElements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>>> DelElements) {
    fbb_.AddOffset(IncrementalDrawingData::VT_DELELEMENTS, DelElements);
  }
  void add_AddViews(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>> AddViews) {
    fbb_.AddOffset(IncrementalDrawingData::VT_ADDVIEWS, AddViews);
  }
  void add_ModViews(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>> ModViews) {
    fbb_.AddOffset(IncrementalDrawingData::VT_MODVIEWS, ModViews);
  }
  void add_DelViews(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelViews) {
    fbb_.AddOffset(IncrementalDrawingData::VT_DELVIEWS, DelViews);
  }
  void add_AddEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> AddEntities) {
    fbb_.AddOffset(IncrementalDrawingData::VT_ADDENTITIES, AddEntities);
  }
  void add_ModEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> ModEntities) {
    fbb_.AddOffset(IncrementalDrawingData::VT_MODENTITIES, ModEntities);
  }
  void add_DelEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>>> DelEntities) {
    fbb_.AddOffset(IncrementalDrawingData::VT_DELENTITIES, DelEntities);
  }
  void add_FeatureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas) {
    fbb_.AddOffset(IncrementalDrawingData::VT_FEATUREDATAS, FeatureDatas);
  }
  void add_AddVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> AddVariables) {
    fbb_.AddOffset(IncrementalDrawingData::VT_ADDVARIABLES, AddVariables);
  }
  void add_DelVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>> DelVariables) {
    fbb_.AddOffset(IncrementalDrawingData::VT_DELVARIABLES, DelVariables);
  }
  void add_ModVariables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> ModVariables) {
    fbb_.AddOffset(IncrementalDrawingData::VT_MODVARIABLES, ModVariables);
  }
  void add_AddLayer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>> AddLayer) {
    fbb_.AddOffset(IncrementalDrawingData::VT_ADDLAYER, AddLayer);
  }
  void add_ModLayer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>> ModLayer) {
    fbb_.AddOffset(IncrementalDrawingData::VT_MODLAYER, ModLayer);
  }
  void add_DelLayer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelLayer) {
    fbb_.AddOffset(IncrementalDrawingData::VT_DELLAYER, DelLayer);
  }
  void add_CurrLayer(int32_t CurrLayer) {
    fbb_.AddElement<int32_t>(IncrementalDrawingData::VT_CURRLAYER, CurrLayer, 0);
  }
  explicit IncrementalDrawingDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IncrementalDrawingDataBuilder &operator=(const IncrementalDrawingDataBuilder &);
  flatbuffers::Offset<IncrementalDrawingData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IncrementalDrawingData>(end);
    return o;
  }
};

inline flatbuffers::Offset<IncrementalDrawingData> CreateIncrementalDrawingData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> AddElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> ModElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>>> DelElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>> AddViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>> ModViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> AddEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> ModEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>>> DelEntities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> AddVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>> DelVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> ModVariables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>> AddLayer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>> ModLayer = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelLayer = 0,
    int32_t CurrLayer = 0) {
  IncrementalDrawingDataBuilder builder_(_fbb);
  builder_.add_CurrLayer(CurrLayer);
  builder_.add_DelLayer(DelLayer);
  builder_.add_ModLayer(ModLayer);
  builder_.add_AddLayer(AddLayer);
  builder_.add_ModVariables(ModVariables);
  builder_.add_DelVariables(DelVariables);
  builder_.add_AddVariables(AddVariables);
  builder_.add_FeatureDatas(FeatureDatas);
  builder_.add_DelEntities(DelEntities);
  builder_.add_ModEntities(ModEntities);
  builder_.add_AddEntities(AddEntities);
  builder_.add_DelViews(DelViews);
  builder_.add_ModViews(ModViews);
  builder_.add_AddViews(AddViews);
  builder_.add_DelElements(DelElements);
  builder_.add_ModElements(ModElements);
  builder_.add_AddElements(AddElements);
  return builder_.Finish();
}

inline flatbuffers::Offset<IncrementalDrawingData> CreateIncrementalDrawingDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *AddElements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *ModElements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>> *DelElements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *AddViews = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *ModViews = nullptr,
    const std::vector<int32_t> *DelViews = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *AddEntities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *ModEntities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>> *DelEntities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *AddVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>> *DelVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *ModVariables = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *AddLayer = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *ModLayer = nullptr,
    const std::vector<int32_t> *DelLayer = nullptr,
    int32_t CurrLayer = 0) {
  auto AddElements__ = AddElements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*AddElements) : 0;
  auto ModElements__ = ModElements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*ModElements) : 0;
  auto DelElements__ = DelElements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>>(*DelElements) : 0;
  auto AddViews__ = AddViews ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>(*AddViews) : 0;
  auto ModViews__ = ModViews ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>(*ModViews) : 0;
  auto DelViews__ = DelViews ? _fbb.CreateVector<int32_t>(*DelViews) : 0;
  auto AddEntities__ = AddEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*AddEntities) : 0;
  auto ModEntities__ = ModEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*ModEntities) : 0;
  auto DelEntities__ = DelEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DelDrawingElement>>(*DelEntities) : 0;
  auto FeatureDatas__ = FeatureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>(*FeatureDatas) : 0;
  auto AddVariables__ = AddVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*AddVariables) : 0;
  auto DelVariables__ = DelVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DeleteVariable>>(*DelVariables) : 0;
  auto ModVariables__ = ModVariables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*ModVariables) : 0;
  auto AddLayer__ = AddLayer ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>(*AddLayer) : 0;
  auto ModLayer__ = ModLayer ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>(*ModLayer) : 0;
  auto DelLayer__ = DelLayer ? _fbb.CreateVector<int32_t>(*DelLayer) : 0;
  return FlatBufferDocSpace::CreateIncrementalDrawingData(
      _fbb,
      AddElements__,
      ModElements__,
      DelElements__,
      AddViews__,
      ModViews__,
      DelViews__,
      AddEntities__,
      ModEntities__,
      DelEntities__,
      FeatureDatas__,
      AddVariables__,
      DelVariables__,
      ModVariables__,
      AddLayer__,
      ModLayer__,
      DelLayer__,
      CurrLayer);
}

struct DrawingQueryInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DrawingQueryInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_F = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InfoData>> *Info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InfoData>> *>(VT_INFO);
  }
  const flatbuffers::String *F() const {
    return GetPointer<const flatbuffers::String *>(VT_F);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(Info()) &&
           verifier.VerifyVectorOfTables(Info()) &&
           VerifyOffset(verifier, VT_F) &&
           verifier.VerifyString(F()) &&
           verifier.EndTable();
  }
};

struct DrawingQueryInfoBuilder {
  typedef DrawingQueryInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InfoData>>> Info) {
    fbb_.AddOffset(DrawingQueryInfo::VT_INFO, Info);
  }
  void add_F(flatbuffers::Offset<flatbuffers::String> F) {
    fbb_.AddOffset(DrawingQueryInfo::VT_F, F);
  }
  explicit DrawingQueryInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DrawingQueryInfoBuilder &operator=(const DrawingQueryInfoBuilder &);
  flatbuffers::Offset<DrawingQueryInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DrawingQueryInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DrawingQueryInfo> CreateDrawingQueryInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::InfoData>>> Info = 0,
    flatbuffers::Offset<flatbuffers::String> F = 0) {
  DrawingQueryInfoBuilder builder_(_fbb);
  builder_.add_F(F);
  builder_.add_Info(Info);
  return builder_.Finish();
}

inline flatbuffers::Offset<DrawingQueryInfo> CreateDrawingQueryInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::InfoData>> *Info = nullptr,
    const char *F = nullptr) {
  auto Info__ = Info ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::InfoData>>(*Info) : 0;
  auto F__ = F ? _fbb.CreateString(F) : 0;
  return FlatBufferDocSpace::CreateDrawingQueryInfo(
      _fbb,
      Info__,
      F__);
}

struct DrawingQueryData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DrawingQueryDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DRAWINGQUERYINFODATA = 4,
    VT_SUPPORTALIGNMENTTYPE = 6,
    VT_SKIDS = 8,
    VT_SIGNALPROTOINFO = 10,
    VT_TRANSFORMINSTANCE = 12,
    VT_BOX = 14,
    VT_ISCLOSED = 16,
    VT_ALLOWEDPICKFLAG = 18
  };
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryInfo>> *DrawingQueryInfoData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryInfo>> *>(VT_DRAWINGQUERYINFODATA);
  }
  const FlatBufferDocSpace::SupportAlignmentTypeData *SupportAlignmentType() const {
    return GetPointer<const FlatBufferDocSpace::SupportAlignmentTypeData *>(VT_SUPPORTALIGNMENTTYPE);
  }
  const flatbuffers::Vector<int32_t> *SkIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SKIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SignalProtoInfoData>> *SignalProtoInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SignalProtoInfoData>> *>(VT_SIGNALPROTOINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *TransformInstance() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *>(VT_TRANSFORMINSTANCE);
  }
  const flatbuffers::Vector<float> *Box() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BOX);
  }
  int32_t IsClosed() const {
    return GetField<int32_t>(VT_ISCLOSED, 0);
  }
  int32_t AllowedPickFlag() const {
    return GetField<int32_t>(VT_ALLOWEDPICKFLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DRAWINGQUERYINFODATA) &&
           verifier.VerifyVector(DrawingQueryInfoData()) &&
           verifier.VerifyVectorOfTables(DrawingQueryInfoData()) &&
           VerifyOffset(verifier, VT_SUPPORTALIGNMENTTYPE) &&
           verifier.VerifyTable(SupportAlignmentType()) &&
           VerifyOffset(verifier, VT_SKIDS) &&
           verifier.VerifyVector(SkIds()) &&
           VerifyOffset(verifier, VT_SIGNALPROTOINFO) &&
           verifier.VerifyVector(SignalProtoInfo()) &&
           verifier.VerifyVectorOfTables(SignalProtoInfo()) &&
           VerifyOffset(verifier, VT_TRANSFORMINSTANCE) &&
           verifier.VerifyVector(TransformInstance()) &&
           verifier.VerifyVectorOfTables(TransformInstance()) &&
           VerifyOffset(verifier, VT_BOX) &&
           verifier.VerifyVector(Box()) &&
           VerifyField<int32_t>(verifier, VT_ISCLOSED) &&
           VerifyField<int32_t>(verifier, VT_ALLOWEDPICKFLAG) &&
           verifier.EndTable();
  }
};

struct DrawingQueryDataBuilder {
  typedef DrawingQueryData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DrawingQueryInfoData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryInfo>>> DrawingQueryInfoData) {
    fbb_.AddOffset(DrawingQueryData::VT_DRAWINGQUERYINFODATA, DrawingQueryInfoData);
  }
  void add_SupportAlignmentType(flatbuffers::Offset<FlatBufferDocSpace::SupportAlignmentTypeData> SupportAlignmentType) {
    fbb_.AddOffset(DrawingQueryData::VT_SUPPORTALIGNMENTTYPE, SupportAlignmentType);
  }
  void add_SkIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> SkIds) {
    fbb_.AddOffset(DrawingQueryData::VT_SKIDS, SkIds);
  }
  void add_SignalProtoInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SignalProtoInfoData>>> SignalProtoInfo) {
    fbb_.AddOffset(DrawingQueryData::VT_SIGNALPROTOINFO, SignalProtoInfo);
  }
  void add_TransformInstance(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>> TransformInstance) {
    fbb_.AddOffset(DrawingQueryData::VT_TRANSFORMINSTANCE, TransformInstance);
  }
  void add_Box(flatbuffers::Offset<flatbuffers::Vector<float>> Box) {
    fbb_.AddOffset(DrawingQueryData::VT_BOX, Box);
  }
  void add_IsClosed(int32_t IsClosed) {
    fbb_.AddElement<int32_t>(DrawingQueryData::VT_ISCLOSED, IsClosed, 0);
  }
  void add_AllowedPickFlag(int32_t AllowedPickFlag) {
    fbb_.AddElement<int32_t>(DrawingQueryData::VT_ALLOWEDPICKFLAG, AllowedPickFlag, 0);
  }
  explicit DrawingQueryDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DrawingQueryDataBuilder &operator=(const DrawingQueryDataBuilder &);
  flatbuffers::Offset<DrawingQueryData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DrawingQueryData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DrawingQueryData> CreateDrawingQueryData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryInfo>>> DrawingQueryInfoData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::SupportAlignmentTypeData> SupportAlignmentType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> SkIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SignalProtoInfoData>>> SignalProtoInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>> TransformInstance = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Box = 0,
    int32_t IsClosed = 0,
    int32_t AllowedPickFlag = 0) {
  DrawingQueryDataBuilder builder_(_fbb);
  builder_.add_AllowedPickFlag(AllowedPickFlag);
  builder_.add_IsClosed(IsClosed);
  builder_.add_Box(Box);
  builder_.add_TransformInstance(TransformInstance);
  builder_.add_SignalProtoInfo(SignalProtoInfo);
  builder_.add_SkIds(SkIds);
  builder_.add_SupportAlignmentType(SupportAlignmentType);
  builder_.add_DrawingQueryInfoData(DrawingQueryInfoData);
  return builder_.Finish();
}

inline flatbuffers::Offset<DrawingQueryData> CreateDrawingQueryDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryInfo>> *DrawingQueryInfoData = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::SupportAlignmentTypeData> SupportAlignmentType = 0,
    const std::vector<int32_t> *SkIds = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SignalProtoInfoData>> *SignalProtoInfo = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>> *TransformInstance = nullptr,
    const std::vector<float> *Box = nullptr,
    int32_t IsClosed = 0,
    int32_t AllowedPickFlag = 0) {
  auto DrawingQueryInfoData__ = DrawingQueryInfoData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryInfo>>(*DrawingQueryInfoData) : 0;
  auto SkIds__ = SkIds ? _fbb.CreateVector<int32_t>(*SkIds) : 0;
  auto SignalProtoInfo__ = SignalProtoInfo ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SignalProtoInfoData>>(*SignalProtoInfo) : 0;
  auto TransformInstance__ = TransformInstance ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::TransformInstanceData>>(*TransformInstance) : 0;
  auto Box__ = Box ? _fbb.CreateVector<float>(*Box) : 0;
  return FlatBufferDocSpace::CreateDrawingQueryData(
      _fbb,
      DrawingQueryInfoData__,
      SupportAlignmentType,
      SkIds__,
      SignalProtoInfo__,
      TransformInstance__,
      Box__,
      IsClosed,
      AllowedPickFlag);
}

struct LineDataElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LineDataElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_G = 6,
    VT_CENTERMARKLINETYPE = 8,
    VT_A = 10,
    VT_D = 12,
    VT_CENTERMARKDATA = 14,
    VT_VIEWINDEX = 16,
    VT_ISSLOT = 18,
    VT_LAYER = 20,
    VT_LINECOLOR = 22,
    VT_VISIBLE = 24
  };
  int32_t T() const {
    return GetField<int32_t>(VT_T, 0);
  }
  int32_t G() const {
    return GetField<int32_t>(VT_G, 0);
  }
  int32_t CenterMarkLineType() const {
    return GetField<int32_t>(VT_CENTERMARKLINETYPE, 0);
  }
  const FlatBufferDocSpace::AttributeData *A() const {
    return GetPointer<const FlatBufferDocSpace::AttributeData *>(VT_A);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DValuesData>> *D() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DValuesData>> *>(VT_D);
  }
  const FlatBufferDocSpace::CenterMarkElement *CenterMarkData() const {
    return GetPointer<const FlatBufferDocSpace::CenterMarkElement *>(VT_CENTERMARKDATA);
  }
  const flatbuffers::String *ViewIndex() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWINDEX);
  }
  int32_t IsSlot() const {
    return GetField<int32_t>(VT_ISSLOT, 0);
  }
  int32_t Layer() const {
    return GetField<int32_t>(VT_LAYER, 0);
  }
  int32_t LineColor() const {
    return GetField<int32_t>(VT_LINECOLOR, 0);
  }
  bool Visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyField<int32_t>(verifier, VT_G) &&
           VerifyField<int32_t>(verifier, VT_CENTERMARKLINETYPE) &&
           VerifyOffset(verifier, VT_A) &&
           verifier.VerifyTable(A()) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyVector(D()) &&
           verifier.VerifyVectorOfTables(D()) &&
           VerifyOffset(verifier, VT_CENTERMARKDATA) &&
           verifier.VerifyTable(CenterMarkData()) &&
           VerifyOffset(verifier, VT_VIEWINDEX) &&
           verifier.VerifyString(ViewIndex()) &&
           VerifyField<int32_t>(verifier, VT_ISSLOT) &&
           VerifyField<int32_t>(verifier, VT_LAYER) &&
           VerifyField<int32_t>(verifier, VT_LINECOLOR) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           verifier.EndTable();
  }
};

struct LineDataElementBuilder {
  typedef LineDataElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(int32_t T) {
    fbb_.AddElement<int32_t>(LineDataElement::VT_T, T, 0);
  }
  void add_G(int32_t G) {
    fbb_.AddElement<int32_t>(LineDataElement::VT_G, G, 0);
  }
  void add_CenterMarkLineType(int32_t CenterMarkLineType) {
    fbb_.AddElement<int32_t>(LineDataElement::VT_CENTERMARKLINETYPE, CenterMarkLineType, 0);
  }
  void add_A(flatbuffers::Offset<FlatBufferDocSpace::AttributeData> A) {
    fbb_.AddOffset(LineDataElement::VT_A, A);
  }
  void add_D(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DValuesData>>> D) {
    fbb_.AddOffset(LineDataElement::VT_D, D);
  }
  void add_CenterMarkData(flatbuffers::Offset<FlatBufferDocSpace::CenterMarkElement> CenterMarkData) {
    fbb_.AddOffset(LineDataElement::VT_CENTERMARKDATA, CenterMarkData);
  }
  void add_ViewIndex(flatbuffers::Offset<flatbuffers::String> ViewIndex) {
    fbb_.AddOffset(LineDataElement::VT_VIEWINDEX, ViewIndex);
  }
  void add_IsSlot(int32_t IsSlot) {
    fbb_.AddElement<int32_t>(LineDataElement::VT_ISSLOT, IsSlot, 0);
  }
  void add_Layer(int32_t Layer) {
    fbb_.AddElement<int32_t>(LineDataElement::VT_LAYER, Layer, 0);
  }
  void add_LineColor(int32_t LineColor) {
    fbb_.AddElement<int32_t>(LineDataElement::VT_LINECOLOR, LineColor, 0);
  }
  void add_Visible(bool Visible) {
    fbb_.AddElement<uint8_t>(LineDataElement::VT_VISIBLE, static_cast<uint8_t>(Visible), 0);
  }
  explicit LineDataElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LineDataElementBuilder &operator=(const LineDataElementBuilder &);
  flatbuffers::Offset<LineDataElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LineDataElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<LineDataElement> CreateLineDataElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t T = 0,
    int32_t G = 0,
    int32_t CenterMarkLineType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::AttributeData> A = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DValuesData>>> D = 0,
    flatbuffers::Offset<FlatBufferDocSpace::CenterMarkElement> CenterMarkData = 0,
    flatbuffers::Offset<flatbuffers::String> ViewIndex = 0,
    int32_t IsSlot = 0,
    int32_t Layer = 0,
    int32_t LineColor = 0,
    bool Visible = false) {
  LineDataElementBuilder builder_(_fbb);
  builder_.add_LineColor(LineColor);
  builder_.add_Layer(Layer);
  builder_.add_IsSlot(IsSlot);
  builder_.add_ViewIndex(ViewIndex);
  builder_.add_CenterMarkData(CenterMarkData);
  builder_.add_D(D);
  builder_.add_A(A);
  builder_.add_CenterMarkLineType(CenterMarkLineType);
  builder_.add_G(G);
  builder_.add_T(T);
  builder_.add_Visible(Visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<LineDataElement> CreateLineDataElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t T = 0,
    int32_t G = 0,
    int32_t CenterMarkLineType = 0,
    flatbuffers::Offset<FlatBufferDocSpace::AttributeData> A = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DValuesData>> *D = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::CenterMarkElement> CenterMarkData = 0,
    const char *ViewIndex = nullptr,
    int32_t IsSlot = 0,
    int32_t Layer = 0,
    int32_t LineColor = 0,
    bool Visible = false) {
  auto D__ = D ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DValuesData>>(*D) : 0;
  auto ViewIndex__ = ViewIndex ? _fbb.CreateString(ViewIndex) : 0;
  return FlatBufferDocSpace::CreateLineDataElement(
      _fbb,
      T,
      G,
      CenterMarkLineType,
      A,
      D__,
      CenterMarkData,
      ViewIndex__,
      IsSlot,
      Layer,
      LineColor,
      Visible);
}

struct CenterMarkElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CenterMarkElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTERPNT = 4,
    VT_ARCRADIUS = 6,
    VT_CENTERMARKSIZE = 8,
    VT_ISUSEDOCDEFAULT = 10,
    VT_CENMARKCROSSSTARTPNT = 12,
    VT_CENMARKCROSSENDPNT = 14,
    VT_CENMARKCROSSLINETYPE = 16,
    VT_CENMARKCROSSLINEWIDTH = 18,
    VT_CENMARKEXTENDLINETYPE = 20,
    VT_CENMARKEXTENDLINEWIDTH = 22,
    VT_HELPLINE = 24
  };
  const flatbuffers::Vector<double> *CenterPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CENTERPNT);
  }
  double ArcRadius() const {
    return GetField<double>(VT_ARCRADIUS, 0.0);
  }
  double CenterMarkSize() const {
    return GetField<double>(VT_CENTERMARKSIZE, 0.0);
  }
  int32_t IsUseDocDefault() const {
    return GetField<int32_t>(VT_ISUSEDOCDEFAULT, 0);
  }
  const flatbuffers::Vector<double> *CenMarkCrossStartPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CENMARKCROSSSTARTPNT);
  }
  const flatbuffers::Vector<double> *CenMarkCrossEndPnt() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CENMARKCROSSENDPNT);
  }
  int32_t CenMarkCrossLineType() const {
    return GetField<int32_t>(VT_CENMARKCROSSLINETYPE, 0);
  }
  int32_t CenMarkCrossLineWidth() const {
    return GetField<int32_t>(VT_CENMARKCROSSLINEWIDTH, 0);
  }
  int32_t CenMarkExtendLineType() const {
    return GetField<int32_t>(VT_CENMARKEXTENDLINETYPE, 0);
  }
  int32_t CenMarkExtendLineWidth() const {
    return GetField<int32_t>(VT_CENMARKEXTENDLINEWIDTH, 0);
  }
  int32_t HelpLine() const {
    return GetField<int32_t>(VT_HELPLINE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CENTERPNT) &&
           verifier.VerifyVector(CenterPnt()) &&
           VerifyField<double>(verifier, VT_ARCRADIUS) &&
           VerifyField<double>(verifier, VT_CENTERMARKSIZE) &&
           VerifyField<int32_t>(verifier, VT_ISUSEDOCDEFAULT) &&
           VerifyOffset(verifier, VT_CENMARKCROSSSTARTPNT) &&
           verifier.VerifyVector(CenMarkCrossStartPnt()) &&
           VerifyOffset(verifier, VT_CENMARKCROSSENDPNT) &&
           verifier.VerifyVector(CenMarkCrossEndPnt()) &&
           VerifyField<int32_t>(verifier, VT_CENMARKCROSSLINETYPE) &&
           VerifyField<int32_t>(verifier, VT_CENMARKCROSSLINEWIDTH) &&
           VerifyField<int32_t>(verifier, VT_CENMARKEXTENDLINETYPE) &&
           VerifyField<int32_t>(verifier, VT_CENMARKEXTENDLINEWIDTH) &&
           VerifyField<int32_t>(verifier, VT_HELPLINE) &&
           verifier.EndTable();
  }
};

struct CenterMarkElementBuilder {
  typedef CenterMarkElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CenterPnt(flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt) {
    fbb_.AddOffset(CenterMarkElement::VT_CENTERPNT, CenterPnt);
  }
  void add_ArcRadius(double ArcRadius) {
    fbb_.AddElement<double>(CenterMarkElement::VT_ARCRADIUS, ArcRadius, 0.0);
  }
  void add_CenterMarkSize(double CenterMarkSize) {
    fbb_.AddElement<double>(CenterMarkElement::VT_CENTERMARKSIZE, CenterMarkSize, 0.0);
  }
  void add_IsUseDocDefault(int32_t IsUseDocDefault) {
    fbb_.AddElement<int32_t>(CenterMarkElement::VT_ISUSEDOCDEFAULT, IsUseDocDefault, 0);
  }
  void add_CenMarkCrossStartPnt(flatbuffers::Offset<flatbuffers::Vector<double>> CenMarkCrossStartPnt) {
    fbb_.AddOffset(CenterMarkElement::VT_CENMARKCROSSSTARTPNT, CenMarkCrossStartPnt);
  }
  void add_CenMarkCrossEndPnt(flatbuffers::Offset<flatbuffers::Vector<double>> CenMarkCrossEndPnt) {
    fbb_.AddOffset(CenterMarkElement::VT_CENMARKCROSSENDPNT, CenMarkCrossEndPnt);
  }
  void add_CenMarkCrossLineType(int32_t CenMarkCrossLineType) {
    fbb_.AddElement<int32_t>(CenterMarkElement::VT_CENMARKCROSSLINETYPE, CenMarkCrossLineType, 0);
  }
  void add_CenMarkCrossLineWidth(int32_t CenMarkCrossLineWidth) {
    fbb_.AddElement<int32_t>(CenterMarkElement::VT_CENMARKCROSSLINEWIDTH, CenMarkCrossLineWidth, 0);
  }
  void add_CenMarkExtendLineType(int32_t CenMarkExtendLineType) {
    fbb_.AddElement<int32_t>(CenterMarkElement::VT_CENMARKEXTENDLINETYPE, CenMarkExtendLineType, 0);
  }
  void add_CenMarkExtendLineWidth(int32_t CenMarkExtendLineWidth) {
    fbb_.AddElement<int32_t>(CenterMarkElement::VT_CENMARKEXTENDLINEWIDTH, CenMarkExtendLineWidth, 0);
  }
  void add_HelpLine(int32_t HelpLine) {
    fbb_.AddElement<int32_t>(CenterMarkElement::VT_HELPLINE, HelpLine, 0);
  }
  explicit CenterMarkElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CenterMarkElementBuilder &operator=(const CenterMarkElementBuilder &);
  flatbuffers::Offset<CenterMarkElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CenterMarkElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<CenterMarkElement> CreateCenterMarkElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> CenterPnt = 0,
    double ArcRadius = 0.0,
    double CenterMarkSize = 0.0,
    int32_t IsUseDocDefault = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CenMarkCrossStartPnt = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> CenMarkCrossEndPnt = 0,
    int32_t CenMarkCrossLineType = 0,
    int32_t CenMarkCrossLineWidth = 0,
    int32_t CenMarkExtendLineType = 0,
    int32_t CenMarkExtendLineWidth = 0,
    int32_t HelpLine = 0) {
  CenterMarkElementBuilder builder_(_fbb);
  builder_.add_CenterMarkSize(CenterMarkSize);
  builder_.add_ArcRadius(ArcRadius);
  builder_.add_HelpLine(HelpLine);
  builder_.add_CenMarkExtendLineWidth(CenMarkExtendLineWidth);
  builder_.add_CenMarkExtendLineType(CenMarkExtendLineType);
  builder_.add_CenMarkCrossLineWidth(CenMarkCrossLineWidth);
  builder_.add_CenMarkCrossLineType(CenMarkCrossLineType);
  builder_.add_CenMarkCrossEndPnt(CenMarkCrossEndPnt);
  builder_.add_CenMarkCrossStartPnt(CenMarkCrossStartPnt);
  builder_.add_IsUseDocDefault(IsUseDocDefault);
  builder_.add_CenterPnt(CenterPnt);
  return builder_.Finish();
}

inline flatbuffers::Offset<CenterMarkElement> CreateCenterMarkElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *CenterPnt = nullptr,
    double ArcRadius = 0.0,
    double CenterMarkSize = 0.0,
    int32_t IsUseDocDefault = 0,
    const std::vector<double> *CenMarkCrossStartPnt = nullptr,
    const std::vector<double> *CenMarkCrossEndPnt = nullptr,
    int32_t CenMarkCrossLineType = 0,
    int32_t CenMarkCrossLineWidth = 0,
    int32_t CenMarkExtendLineType = 0,
    int32_t CenMarkExtendLineWidth = 0,
    int32_t HelpLine = 0) {
  auto CenterPnt__ = CenterPnt ? _fbb.CreateVector<double>(*CenterPnt) : 0;
  auto CenMarkCrossStartPnt__ = CenMarkCrossStartPnt ? _fbb.CreateVector<double>(*CenMarkCrossStartPnt) : 0;
  auto CenMarkCrossEndPnt__ = CenMarkCrossEndPnt ? _fbb.CreateVector<double>(*CenMarkCrossEndPnt) : 0;
  return FlatBufferDocSpace::CreateCenterMarkElement(
      _fbb,
      CenterPnt__,
      ArcRadius,
      CenterMarkSize,
      IsUseDocDefault,
      CenMarkCrossStartPnt__,
      CenMarkCrossEndPnt__,
      CenMarkCrossLineType,
      CenMarkCrossLineWidth,
      CenMarkExtendLineType,
      CenMarkExtendLineWidth,
      HelpLine);
}

struct DValuesData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DValuesDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_V = 6
  };
  const flatbuffers::String *T() const {
    return GetPointer<const flatbuffers::String *>(VT_T);
  }
  const flatbuffers::Vector<double> *V() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyString(T()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.VerifyVector(V()) &&
           verifier.EndTable();
  }
};

struct DValuesDataBuilder {
  typedef DValuesData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(flatbuffers::Offset<flatbuffers::String> T) {
    fbb_.AddOffset(DValuesData::VT_T, T);
  }
  void add_V(flatbuffers::Offset<flatbuffers::Vector<double>> V) {
    fbb_.AddOffset(DValuesData::VT_V, V);
  }
  explicit DValuesDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DValuesDataBuilder &operator=(const DValuesDataBuilder &);
  flatbuffers::Offset<DValuesData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DValuesData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DValuesData> CreateDValuesData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> T = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> V = 0) {
  DValuesDataBuilder builder_(_fbb);
  builder_.add_V(V);
  builder_.add_T(T);
  return builder_.Finish();
}

inline flatbuffers::Offset<DValuesData> CreateDValuesDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *T = nullptr,
    const std::vector<double> *V = nullptr) {
  auto T__ = T ? _fbb.CreateString(T) : 0;
  auto V__ = V ? _fbb.CreateVector<double>(*V) : 0;
  return FlatBufferDocSpace::CreateDValuesData(
      _fbb,
      T__,
      V__);
}

struct FolderGroupData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FolderGroupDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESSCHILDRENIDS = 4,
    VT_SUCCESSCHILDRENNAMES = 6
  };
  const flatbuffers::Vector<int32_t> *SuccessChildrenIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SUCCESSCHILDRENIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *SuccessChildrenNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SUCCESSCHILDRENNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SUCCESSCHILDRENIDS) &&
           verifier.VerifyVector(SuccessChildrenIds()) &&
           VerifyOffset(verifier, VT_SUCCESSCHILDRENNAMES) &&
           verifier.VerifyVector(SuccessChildrenNames()) &&
           verifier.VerifyVectorOfStrings(SuccessChildrenNames()) &&
           verifier.EndTable();
  }
};

struct FolderGroupDataBuilder {
  typedef FolderGroupData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SuccessChildrenIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> SuccessChildrenIds) {
    fbb_.AddOffset(FolderGroupData::VT_SUCCESSCHILDRENIDS, SuccessChildrenIds);
  }
  void add_SuccessChildrenNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> SuccessChildrenNames) {
    fbb_.AddOffset(FolderGroupData::VT_SUCCESSCHILDRENNAMES, SuccessChildrenNames);
  }
  explicit FolderGroupDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FolderGroupDataBuilder &operator=(const FolderGroupDataBuilder &);
  flatbuffers::Offset<FolderGroupData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FolderGroupData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FolderGroupData> CreateFolderGroupData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> SuccessChildrenIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> SuccessChildrenNames = 0) {
  FolderGroupDataBuilder builder_(_fbb);
  builder_.add_SuccessChildrenNames(SuccessChildrenNames);
  builder_.add_SuccessChildrenIds(SuccessChildrenIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<FolderGroupData> CreateFolderGroupDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *SuccessChildrenIds = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *SuccessChildrenNames = nullptr) {
  auto SuccessChildrenIds__ = SuccessChildrenIds ? _fbb.CreateVector<int32_t>(*SuccessChildrenIds) : 0;
  auto SuccessChildrenNames__ = SuccessChildrenNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*SuccessChildrenNames) : 0;
  return FlatBufferDocSpace::CreateFolderGroupData(
      _fbb,
      SuccessChildrenIds__,
      SuccessChildrenNames__);
}

struct FeatData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FeatDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_FEATUREID = 6,
    VT_INSTANCEID = 8,
    VT_MATINGINDEX = 10
  };
  int32_t Type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t FeatureId() const {
    return GetField<int32_t>(VT_FEATUREID, 0);
  }
  const flatbuffers::String *InstanceId() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID);
  }
  int32_t MatingIndex() const {
    return GetField<int32_t>(VT_MATINGINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FEATUREID) &&
           VerifyOffset(verifier, VT_INSTANCEID) &&
           verifier.VerifyString(InstanceId()) &&
           VerifyField<int32_t>(verifier, VT_MATINGINDEX) &&
           verifier.EndTable();
  }
};

struct FeatDataBuilder {
  typedef FeatData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Type(int32_t Type) {
    fbb_.AddElement<int32_t>(FeatData::VT_TYPE, Type, 0);
  }
  void add_FeatureId(int32_t FeatureId) {
    fbb_.AddElement<int32_t>(FeatData::VT_FEATUREID, FeatureId, 0);
  }
  void add_InstanceId(flatbuffers::Offset<flatbuffers::String> InstanceId) {
    fbb_.AddOffset(FeatData::VT_INSTANCEID, InstanceId);
  }
  void add_MatingIndex(int32_t MatingIndex) {
    fbb_.AddElement<int32_t>(FeatData::VT_MATINGINDEX, MatingIndex, 0);
  }
  explicit FeatDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FeatDataBuilder &operator=(const FeatDataBuilder &);
  flatbuffers::Offset<FeatData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FeatData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FeatData> CreateFeatData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Type = 0,
    int32_t FeatureId = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId = 0,
    int32_t MatingIndex = 0) {
  FeatDataBuilder builder_(_fbb);
  builder_.add_MatingIndex(MatingIndex);
  builder_.add_InstanceId(InstanceId);
  builder_.add_FeatureId(FeatureId);
  builder_.add_Type(Type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FeatData> CreateFeatDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Type = 0,
    int32_t FeatureId = 0,
    const char *InstanceId = nullptr,
    int32_t MatingIndex = 0) {
  auto InstanceId__ = InstanceId ? _fbb.CreateString(InstanceId) : 0;
  return FlatBufferDocSpace::CreateFeatData(
      _fbb,
      Type,
      FeatureId,
      InstanceId__,
      MatingIndex);
}

struct FeatRelations FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FeatRelationsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUERYFEATURE = 4,
    VT_PARENTFEATURE = 6,
    VT_CHILDFEATURE = 8
  };
  const FlatBufferDocSpace::FeatData *QueryFeature() const {
    return GetPointer<const FlatBufferDocSpace::FeatData *>(VT_QUERYFEATURE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>> *ParentFeature() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>> *>(VT_PARENTFEATURE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>> *ChildFeature() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>> *>(VT_CHILDFEATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERYFEATURE) &&
           verifier.VerifyTable(QueryFeature()) &&
           VerifyOffset(verifier, VT_PARENTFEATURE) &&
           verifier.VerifyVector(ParentFeature()) &&
           verifier.VerifyVectorOfTables(ParentFeature()) &&
           VerifyOffset(verifier, VT_CHILDFEATURE) &&
           verifier.VerifyVector(ChildFeature()) &&
           verifier.VerifyVectorOfTables(ChildFeature()) &&
           verifier.EndTable();
  }
};

struct FeatRelationsBuilder {
  typedef FeatRelations Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_QueryFeature(flatbuffers::Offset<FlatBufferDocSpace::FeatData> QueryFeature) {
    fbb_.AddOffset(FeatRelations::VT_QUERYFEATURE, QueryFeature);
  }
  void add_ParentFeature(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>>> ParentFeature) {
    fbb_.AddOffset(FeatRelations::VT_PARENTFEATURE, ParentFeature);
  }
  void add_ChildFeature(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>>> ChildFeature) {
    fbb_.AddOffset(FeatRelations::VT_CHILDFEATURE, ChildFeature);
  }
  explicit FeatRelationsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FeatRelationsBuilder &operator=(const FeatRelationsBuilder &);
  flatbuffers::Offset<FeatRelations> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FeatRelations>(end);
    return o;
  }
};

inline flatbuffers::Offset<FeatRelations> CreateFeatRelations(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::FeatData> QueryFeature = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>>> ParentFeature = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>>> ChildFeature = 0) {
  FeatRelationsBuilder builder_(_fbb);
  builder_.add_ChildFeature(ChildFeature);
  builder_.add_ParentFeature(ParentFeature);
  builder_.add_QueryFeature(QueryFeature);
  return builder_.Finish();
}

inline flatbuffers::Offset<FeatRelations> CreateFeatRelationsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::FeatData> QueryFeature = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>> *ParentFeature = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>> *ChildFeature = nullptr) {
  auto ParentFeature__ = ParentFeature ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>>(*ParentFeature) : 0;
  auto ChildFeature__ = ChildFeature ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FeatData>>(*ChildFeature) : 0;
  return FlatBufferDocSpace::CreateFeatRelations(
      _fbb,
      QueryFeature,
      ParentFeature__,
      ChildFeature__);
}

struct ExtRefData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtRefDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATUREID = 4,
    VT_FEATURENAME = 6,
    VT_INSTANCEID = 8,
    VT_REFINSTANCEID = 10,
    VT_REFENTITYIDS = 12,
    VT_REFTYPE = 14,
    VT_REFINDEX = 16,
    VT_STATUS = 18
  };
  int32_t FeatureId() const {
    return GetField<int32_t>(VT_FEATUREID, 0);
  }
  const flatbuffers::String *FeatureName() const {
    return GetPointer<const flatbuffers::String *>(VT_FEATURENAME);
  }
  const flatbuffers::String *InstanceId() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *RefInstanceId() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_REFINSTANCEID);
  }
  const flatbuffers::Vector<int32_t> *RefEntityIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_REFENTITYIDS);
  }
  int32_t RefType() const {
    return GetField<int32_t>(VT_REFTYPE, 0);
  }
  int32_t RefIndex() const {
    return GetField<int32_t>(VT_REFINDEX, 0);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FEATUREID) &&
           VerifyOffset(verifier, VT_FEATURENAME) &&
           verifier.VerifyString(FeatureName()) &&
           VerifyOffset(verifier, VT_INSTANCEID) &&
           verifier.VerifyString(InstanceId()) &&
           VerifyOffset(verifier, VT_REFINSTANCEID) &&
           verifier.VerifyVector(RefInstanceId()) &&
           verifier.VerifyVectorOfStrings(RefInstanceId()) &&
           VerifyOffset(verifier, VT_REFENTITYIDS) &&
           verifier.VerifyVector(RefEntityIds()) &&
           VerifyField<int32_t>(verifier, VT_REFTYPE) &&
           VerifyField<int32_t>(verifier, VT_REFINDEX) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct ExtRefDataBuilder {
  typedef ExtRefData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FeatureId(int32_t FeatureId) {
    fbb_.AddElement<int32_t>(ExtRefData::VT_FEATUREID, FeatureId, 0);
  }
  void add_FeatureName(flatbuffers::Offset<flatbuffers::String> FeatureName) {
    fbb_.AddOffset(ExtRefData::VT_FEATURENAME, FeatureName);
  }
  void add_InstanceId(flatbuffers::Offset<flatbuffers::String> InstanceId) {
    fbb_.AddOffset(ExtRefData::VT_INSTANCEID, InstanceId);
  }
  void add_RefInstanceId(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RefInstanceId) {
    fbb_.AddOffset(ExtRefData::VT_REFINSTANCEID, RefInstanceId);
  }
  void add_RefEntityIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> RefEntityIds) {
    fbb_.AddOffset(ExtRefData::VT_REFENTITYIDS, RefEntityIds);
  }
  void add_RefType(int32_t RefType) {
    fbb_.AddElement<int32_t>(ExtRefData::VT_REFTYPE, RefType, 0);
  }
  void add_RefIndex(int32_t RefIndex) {
    fbb_.AddElement<int32_t>(ExtRefData::VT_REFINDEX, RefIndex, 0);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(ExtRefData::VT_STATUS, Status, 0);
  }
  explicit ExtRefDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExtRefDataBuilder &operator=(const ExtRefDataBuilder &);
  flatbuffers::Offset<ExtRefData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExtRefData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExtRefData> CreateExtRefData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t FeatureId = 0,
    flatbuffers::Offset<flatbuffers::String> FeatureName = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> RefInstanceId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> RefEntityIds = 0,
    int32_t RefType = 0,
    int32_t RefIndex = 0,
    int32_t Status = 0) {
  ExtRefDataBuilder builder_(_fbb);
  builder_.add_Status(Status);
  builder_.add_RefIndex(RefIndex);
  builder_.add_RefType(RefType);
  builder_.add_RefEntityIds(RefEntityIds);
  builder_.add_RefInstanceId(RefInstanceId);
  builder_.add_InstanceId(InstanceId);
  builder_.add_FeatureName(FeatureName);
  builder_.add_FeatureId(FeatureId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExtRefData> CreateExtRefDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t FeatureId = 0,
    const char *FeatureName = nullptr,
    const char *InstanceId = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *RefInstanceId = nullptr,
    const std::vector<int32_t> *RefEntityIds = nullptr,
    int32_t RefType = 0,
    int32_t RefIndex = 0,
    int32_t Status = 0) {
  auto FeatureName__ = FeatureName ? _fbb.CreateString(FeatureName) : 0;
  auto InstanceId__ = InstanceId ? _fbb.CreateString(InstanceId) : 0;
  auto RefInstanceId__ = RefInstanceId ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*RefInstanceId) : 0;
  auto RefEntityIds__ = RefEntityIds ? _fbb.CreateVector<int32_t>(*RefEntityIds) : 0;
  return FlatBufferDocSpace::CreateExtRefData(
      _fbb,
      FeatureId,
      FeatureName__,
      InstanceId__,
      RefInstanceId__,
      RefEntityIds__,
      RefType,
      RefIndex,
      Status);
}

struct ExtHeadData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtHeadDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCEID = 4,
    VT_INSTANCENAME = 6,
    VT_STATUS = 8
  };
  const flatbuffers::String *InstanceId() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCEID);
  }
  const flatbuffers::String *InstanceName() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCENAME);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCEID) &&
           verifier.VerifyString(InstanceId()) &&
           VerifyOffset(verifier, VT_INSTANCENAME) &&
           verifier.VerifyString(InstanceName()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct ExtHeadDataBuilder {
  typedef ExtHeadData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_InstanceId(flatbuffers::Offset<flatbuffers::String> InstanceId) {
    fbb_.AddOffset(ExtHeadData::VT_INSTANCEID, InstanceId);
  }
  void add_InstanceName(flatbuffers::Offset<flatbuffers::String> InstanceName) {
    fbb_.AddOffset(ExtHeadData::VT_INSTANCENAME, InstanceName);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(ExtHeadData::VT_STATUS, Status, 0);
  }
  explicit ExtHeadDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExtHeadDataBuilder &operator=(const ExtHeadDataBuilder &);
  flatbuffers::Offset<ExtHeadData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExtHeadData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExtHeadData> CreateExtHeadData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> InstanceId = 0,
    flatbuffers::Offset<flatbuffers::String> InstanceName = 0,
    int32_t Status = 0) {
  ExtHeadDataBuilder builder_(_fbb);
  builder_.add_Status(Status);
  builder_.add_InstanceName(InstanceName);
  builder_.add_InstanceId(InstanceId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExtHeadData> CreateExtHeadDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *InstanceId = nullptr,
    const char *InstanceName = nullptr,
    int32_t Status = 0) {
  auto InstanceId__ = InstanceId ? _fbb.CreateString(InstanceId) : 0;
  auto InstanceName__ = InstanceName ? _fbb.CreateString(InstanceName) : 0;
  return FlatBufferDocSpace::CreateExtHeadData(
      _fbb,
      InstanceId__,
      InstanceName__,
      Status);
}

struct ExtRefTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtRefTreeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEAD = 4,
    VT_CUREXTREF = 6,
    VT_CHILDEXTREF = 8
  };
  const FlatBufferDocSpace::ExtHeadData *Head() const {
    return GetPointer<const FlatBufferDocSpace::ExtHeadData *>(VT_HEAD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefData>> *CurExtRef() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefData>> *>(VT_CUREXTREF);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefTree>> *ChildExtRef() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefTree>> *>(VT_CHILDEXTREF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEAD) &&
           verifier.VerifyTable(Head()) &&
           VerifyOffset(verifier, VT_CUREXTREF) &&
           verifier.VerifyVector(CurExtRef()) &&
           verifier.VerifyVectorOfTables(CurExtRef()) &&
           VerifyOffset(verifier, VT_CHILDEXTREF) &&
           verifier.VerifyVector(ChildExtRef()) &&
           verifier.VerifyVectorOfTables(ChildExtRef()) &&
           verifier.EndTable();
  }
};

struct ExtRefTreeBuilder {
  typedef ExtRefTree Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Head(flatbuffers::Offset<FlatBufferDocSpace::ExtHeadData> Head) {
    fbb_.AddOffset(ExtRefTree::VT_HEAD, Head);
  }
  void add_CurExtRef(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefData>>> CurExtRef) {
    fbb_.AddOffset(ExtRefTree::VT_CUREXTREF, CurExtRef);
  }
  void add_ChildExtRef(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefTree>>> ChildExtRef) {
    fbb_.AddOffset(ExtRefTree::VT_CHILDEXTREF, ChildExtRef);
  }
  explicit ExtRefTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExtRefTreeBuilder &operator=(const ExtRefTreeBuilder &);
  flatbuffers::Offset<ExtRefTree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExtRefTree>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExtRefTree> CreateExtRefTree(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::ExtHeadData> Head = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefData>>> CurExtRef = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefTree>>> ChildExtRef = 0) {
  ExtRefTreeBuilder builder_(_fbb);
  builder_.add_ChildExtRef(ChildExtRef);
  builder_.add_CurExtRef(CurExtRef);
  builder_.add_Head(Head);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExtRefTree> CreateExtRefTreeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FlatBufferDocSpace::ExtHeadData> Head = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefData>> *CurExtRef = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefTree>> *ChildExtRef = nullptr) {
  auto CurExtRef__ = CurExtRef ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefData>>(*CurExtRef) : 0;
  auto ChildExtRef__ = ChildExtRef ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ExtRefTree>>(*ChildExtRef) : 0;
  return FlatBufferDocSpace::CreateExtRefTree(
      _fbb,
      Head,
      CurExtRef__,
      ChildExtRef__);
}

struct ErrorMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_DESCRIPTION = 6
  };
  const flatbuffers::String *Code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::String *Description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(Code()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(Description()) &&
           verifier.EndTable();
  }
};

struct ErrorMessageBuilder {
  typedef ErrorMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Code(flatbuffers::Offset<flatbuffers::String> Code) {
    fbb_.AddOffset(ErrorMessage::VT_CODE, Code);
  }
  void add_Description(flatbuffers::Offset<flatbuffers::String> Description) {
    fbb_.AddOffset(ErrorMessage::VT_DESCRIPTION, Description);
  }
  explicit ErrorMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorMessageBuilder &operator=(const ErrorMessageBuilder &);
  flatbuffers::Offset<ErrorMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorMessage> CreateErrorMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Code = 0,
    flatbuffers::Offset<flatbuffers::String> Description = 0) {
  ErrorMessageBuilder builder_(_fbb);
  builder_.add_Description(Description);
  builder_.add_Code(Code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ErrorMessage> CreateErrorMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Code = nullptr,
    const char *Description = nullptr) {
  auto Code__ = Code ? _fbb.CreateString(Code) : 0;
  auto Description__ = Description ? _fbb.CreateString(Description) : 0;
  return FlatBufferDocSpace::CreateErrorMessage(
      _fbb,
      Code__,
      Description__);
}

struct HypUpdateMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HypUpdateMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOCUMENTID = 4,
    VT_VERSIONID = 6
  };
  const flatbuffers::String *DocumentId() const {
    return GetPointer<const flatbuffers::String *>(VT_DOCUMENTID);
  }
  const flatbuffers::String *VersionId() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSIONID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOCUMENTID) &&
           verifier.VerifyString(DocumentId()) &&
           VerifyOffset(verifier, VT_VERSIONID) &&
           verifier.VerifyString(VersionId()) &&
           verifier.EndTable();
  }
};

struct HypUpdateMessageBuilder {
  typedef HypUpdateMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DocumentId(flatbuffers::Offset<flatbuffers::String> DocumentId) {
    fbb_.AddOffset(HypUpdateMessage::VT_DOCUMENTID, DocumentId);
  }
  void add_VersionId(flatbuffers::Offset<flatbuffers::String> VersionId) {
    fbb_.AddOffset(HypUpdateMessage::VT_VERSIONID, VersionId);
  }
  explicit HypUpdateMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HypUpdateMessageBuilder &operator=(const HypUpdateMessageBuilder &);
  flatbuffers::Offset<HypUpdateMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HypUpdateMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<HypUpdateMessage> CreateHypUpdateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> DocumentId = 0,
    flatbuffers::Offset<flatbuffers::String> VersionId = 0) {
  HypUpdateMessageBuilder builder_(_fbb);
  builder_.add_VersionId(VersionId);
  builder_.add_DocumentId(DocumentId);
  return builder_.Finish();
}

inline flatbuffers::Offset<HypUpdateMessage> CreateHypUpdateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *DocumentId = nullptr,
    const char *VersionId = nullptr) {
  auto DocumentId__ = DocumentId ? _fbb.CreateString(DocumentId) : 0;
  auto VersionId__ = VersionId ? _fbb.CreateString(VersionId) : 0;
  return FlatBufferDocSpace::CreateHypUpdateMessage(
      _fbb,
      DocumentId__,
      VersionId__);
}

struct LayerDataInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerDataInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYERID = 4,
    VT_LAYERNAME = 6,
    VT_LAYERENTITYS = 8,
    VT_LAYERDESC = 10,
    VT_LAYERTYPEIDS = 12,
    VT_LAYERSTATUS = 14,
    VT_LAYERVISIBLE = 16,
    VT_LAYERPRINT = 18,
    VT_LAYERLINETYPE = 20,
    VT_LAYERLINEWIDTH = 22,
    VT_LAYERCOLOR = 24
  };
  int32_t LayerID() const {
    return GetField<int32_t>(VT_LAYERID, 0);
  }
  const flatbuffers::String *LayerName() const {
    return GetPointer<const flatbuffers::String *>(VT_LAYERNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *LayerEntitys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LAYERENTITYS);
  }
  const flatbuffers::String *LayerDesc() const {
    return GetPointer<const flatbuffers::String *>(VT_LAYERDESC);
  }
  const flatbuffers::Vector<int32_t> *LayerTypeIDs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LAYERTYPEIDS);
  }
  int16_t LayerStatus() const {
    return GetField<int16_t>(VT_LAYERSTATUS, 0);
  }
  int32_t LayerVisible() const {
    return GetField<int32_t>(VT_LAYERVISIBLE, 0);
  }
  int32_t LayerPrint() const {
    return GetField<int32_t>(VT_LAYERPRINT, 0);
  }
  int32_t LayerLineType() const {
    return GetField<int32_t>(VT_LAYERLINETYPE, 0);
  }
  int32_t LayerLineWidth() const {
    return GetField<int32_t>(VT_LAYERLINEWIDTH, 0);
  }
  int32_t LayerColor() const {
    return GetField<int32_t>(VT_LAYERCOLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LAYERID) &&
           VerifyOffset(verifier, VT_LAYERNAME) &&
           verifier.VerifyString(LayerName()) &&
           VerifyOffset(verifier, VT_LAYERENTITYS) &&
           verifier.VerifyVector(LayerEntitys()) &&
           verifier.VerifyVectorOfStrings(LayerEntitys()) &&
           VerifyOffset(verifier, VT_LAYERDESC) &&
           verifier.VerifyString(LayerDesc()) &&
           VerifyOffset(verifier, VT_LAYERTYPEIDS) &&
           verifier.VerifyVector(LayerTypeIDs()) &&
           VerifyField<int16_t>(verifier, VT_LAYERSTATUS) &&
           VerifyField<int32_t>(verifier, VT_LAYERVISIBLE) &&
           VerifyField<int32_t>(verifier, VT_LAYERPRINT) &&
           VerifyField<int32_t>(verifier, VT_LAYERLINETYPE) &&
           VerifyField<int32_t>(verifier, VT_LAYERLINEWIDTH) &&
           VerifyField<int32_t>(verifier, VT_LAYERCOLOR) &&
           verifier.EndTable();
  }
};

struct LayerDataInfoBuilder {
  typedef LayerDataInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_LayerID(int32_t LayerID) {
    fbb_.AddElement<int32_t>(LayerDataInfo::VT_LAYERID, LayerID, 0);
  }
  void add_LayerName(flatbuffers::Offset<flatbuffers::String> LayerName) {
    fbb_.AddOffset(LayerDataInfo::VT_LAYERNAME, LayerName);
  }
  void add_LayerEntitys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> LayerEntitys) {
    fbb_.AddOffset(LayerDataInfo::VT_LAYERENTITYS, LayerEntitys);
  }
  void add_LayerDesc(flatbuffers::Offset<flatbuffers::String> LayerDesc) {
    fbb_.AddOffset(LayerDataInfo::VT_LAYERDESC, LayerDesc);
  }
  void add_LayerTypeIDs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> LayerTypeIDs) {
    fbb_.AddOffset(LayerDataInfo::VT_LAYERTYPEIDS, LayerTypeIDs);
  }
  void add_LayerStatus(int16_t LayerStatus) {
    fbb_.AddElement<int16_t>(LayerDataInfo::VT_LAYERSTATUS, LayerStatus, 0);
  }
  void add_LayerVisible(int32_t LayerVisible) {
    fbb_.AddElement<int32_t>(LayerDataInfo::VT_LAYERVISIBLE, LayerVisible, 0);
  }
  void add_LayerPrint(int32_t LayerPrint) {
    fbb_.AddElement<int32_t>(LayerDataInfo::VT_LAYERPRINT, LayerPrint, 0);
  }
  void add_LayerLineType(int32_t LayerLineType) {
    fbb_.AddElement<int32_t>(LayerDataInfo::VT_LAYERLINETYPE, LayerLineType, 0);
  }
  void add_LayerLineWidth(int32_t LayerLineWidth) {
    fbb_.AddElement<int32_t>(LayerDataInfo::VT_LAYERLINEWIDTH, LayerLineWidth, 0);
  }
  void add_LayerColor(int32_t LayerColor) {
    fbb_.AddElement<int32_t>(LayerDataInfo::VT_LAYERCOLOR, LayerColor, 0);
  }
  explicit LayerDataInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerDataInfoBuilder &operator=(const LayerDataInfoBuilder &);
  flatbuffers::Offset<LayerDataInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerDataInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerDataInfo> CreateLayerDataInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t LayerID = 0,
    flatbuffers::Offset<flatbuffers::String> LayerName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> LayerEntitys = 0,
    flatbuffers::Offset<flatbuffers::String> LayerDesc = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> LayerTypeIDs = 0,
    int16_t LayerStatus = 0,
    int32_t LayerVisible = 0,
    int32_t LayerPrint = 0,
    int32_t LayerLineType = 0,
    int32_t LayerLineWidth = 0,
    int32_t LayerColor = 0) {
  LayerDataInfoBuilder builder_(_fbb);
  builder_.add_LayerColor(LayerColor);
  builder_.add_LayerLineWidth(LayerLineWidth);
  builder_.add_LayerLineType(LayerLineType);
  builder_.add_LayerPrint(LayerPrint);
  builder_.add_LayerVisible(LayerVisible);
  builder_.add_LayerTypeIDs(LayerTypeIDs);
  builder_.add_LayerDesc(LayerDesc);
  builder_.add_LayerEntitys(LayerEntitys);
  builder_.add_LayerName(LayerName);
  builder_.add_LayerID(LayerID);
  builder_.add_LayerStatus(LayerStatus);
  return builder_.Finish();
}

inline flatbuffers::Offset<LayerDataInfo> CreateLayerDataInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t LayerID = 0,
    const char *LayerName = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *LayerEntitys = nullptr,
    const char *LayerDesc = nullptr,
    const std::vector<int32_t> *LayerTypeIDs = nullptr,
    int16_t LayerStatus = 0,
    int32_t LayerVisible = 0,
    int32_t LayerPrint = 0,
    int32_t LayerLineType = 0,
    int32_t LayerLineWidth = 0,
    int32_t LayerColor = 0) {
  auto LayerName__ = LayerName ? _fbb.CreateString(LayerName) : 0;
  auto LayerEntitys__ = LayerEntitys ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*LayerEntitys) : 0;
  auto LayerDesc__ = LayerDesc ? _fbb.CreateString(LayerDesc) : 0;
  auto LayerTypeIDs__ = LayerTypeIDs ? _fbb.CreateVector<int32_t>(*LayerTypeIDs) : 0;
  return FlatBufferDocSpace::CreateLayerDataInfo(
      _fbb,
      LayerID,
      LayerName__,
      LayerEntitys__,
      LayerDesc__,
      LayerTypeIDs__,
      LayerStatus,
      LayerVisible,
      LayerPrint,
      LayerLineType,
      LayerLineWidth,
      LayerColor);
}

struct LayerType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYERTYPEID = 4,
    VT_LAYERTYPENAME = 6,
    VT_LAYERTYPEDESC = 8
  };
  int32_t LayerTypeId() const {
    return GetField<int32_t>(VT_LAYERTYPEID, 0);
  }
  const flatbuffers::String *LayerTypeName() const {
    return GetPointer<const flatbuffers::String *>(VT_LAYERTYPENAME);
  }
  const flatbuffers::String *LayerTypeDesc() const {
    return GetPointer<const flatbuffers::String *>(VT_LAYERTYPEDESC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LAYERTYPEID) &&
           VerifyOffset(verifier, VT_LAYERTYPENAME) &&
           verifier.VerifyString(LayerTypeName()) &&
           VerifyOffset(verifier, VT_LAYERTYPEDESC) &&
           verifier.VerifyString(LayerTypeDesc()) &&
           verifier.EndTable();
  }
};

struct LayerTypeBuilder {
  typedef LayerType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_LayerTypeId(int32_t LayerTypeId) {
    fbb_.AddElement<int32_t>(LayerType::VT_LAYERTYPEID, LayerTypeId, 0);
  }
  void add_LayerTypeName(flatbuffers::Offset<flatbuffers::String> LayerTypeName) {
    fbb_.AddOffset(LayerType::VT_LAYERTYPENAME, LayerTypeName);
  }
  void add_LayerTypeDesc(flatbuffers::Offset<flatbuffers::String> LayerTypeDesc) {
    fbb_.AddOffset(LayerType::VT_LAYERTYPEDESC, LayerTypeDesc);
  }
  explicit LayerTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerTypeBuilder &operator=(const LayerTypeBuilder &);
  flatbuffers::Offset<LayerType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerType>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerType> CreateLayerType(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t LayerTypeId = 0,
    flatbuffers::Offset<flatbuffers::String> LayerTypeName = 0,
    flatbuffers::Offset<flatbuffers::String> LayerTypeDesc = 0) {
  LayerTypeBuilder builder_(_fbb);
  builder_.add_LayerTypeDesc(LayerTypeDesc);
  builder_.add_LayerTypeName(LayerTypeName);
  builder_.add_LayerTypeId(LayerTypeId);
  return builder_.Finish();
}

inline flatbuffers::Offset<LayerType> CreateLayerTypeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t LayerTypeId = 0,
    const char *LayerTypeName = nullptr,
    const char *LayerTypeDesc = nullptr) {
  auto LayerTypeName__ = LayerTypeName ? _fbb.CreateString(LayerTypeName) : 0;
  auto LayerTypeDesc__ = LayerTypeDesc ? _fbb.CreateString(LayerTypeDesc) : 0;
  return FlatBufferDocSpace::CreateLayerType(
      _fbb,
      LayerTypeId,
      LayerTypeName__,
      LayerTypeDesc__);
}

struct LayerDataManager FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerDataManagerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENTLAYER = 4,
    VT_LAYERDATAS = 6,
    VT_LAYERTYPESMANAGER = 8
  };
  int32_t CurrentLayer() const {
    return GetField<int32_t>(VT_CURRENTLAYER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *LayerDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *>(VT_LAYERDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerType>> *LayerTypesManager() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerType>> *>(VT_LAYERTYPESMANAGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CURRENTLAYER) &&
           VerifyOffset(verifier, VT_LAYERDATAS) &&
           verifier.VerifyVector(LayerDatas()) &&
           verifier.VerifyVectorOfTables(LayerDatas()) &&
           VerifyOffset(verifier, VT_LAYERTYPESMANAGER) &&
           verifier.VerifyVector(LayerTypesManager()) &&
           verifier.VerifyVectorOfTables(LayerTypesManager()) &&
           verifier.EndTable();
  }
};

struct LayerDataManagerBuilder {
  typedef LayerDataManager Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CurrentLayer(int32_t CurrentLayer) {
    fbb_.AddElement<int32_t>(LayerDataManager::VT_CURRENTLAYER, CurrentLayer, 0);
  }
  void add_LayerDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>> LayerDatas) {
    fbb_.AddOffset(LayerDataManager::VT_LAYERDATAS, LayerDatas);
  }
  void add_LayerTypesManager(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerType>>> LayerTypesManager) {
    fbb_.AddOffset(LayerDataManager::VT_LAYERTYPESMANAGER, LayerTypesManager);
  }
  explicit LayerDataManagerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerDataManagerBuilder &operator=(const LayerDataManagerBuilder &);
  flatbuffers::Offset<LayerDataManager> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerDataManager>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerDataManager> CreateLayerDataManager(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t CurrentLayer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>> LayerDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::LayerType>>> LayerTypesManager = 0) {
  LayerDataManagerBuilder builder_(_fbb);
  builder_.add_LayerTypesManager(LayerTypesManager);
  builder_.add_LayerDatas(LayerDatas);
  builder_.add_CurrentLayer(CurrentLayer);
  return builder_.Finish();
}

inline flatbuffers::Offset<LayerDataManager> CreateLayerDataManagerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t CurrentLayer = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>> *LayerDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::LayerType>> *LayerTypesManager = nullptr) {
  auto LayerDatas__ = LayerDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::LayerDataInfo>>(*LayerDatas) : 0;
  auto LayerTypesManager__ = LayerTypesManager ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::LayerType>>(*LayerTypesManager) : 0;
  return FlatBufferDocSpace::CreateLayerDataManager(
      _fbb,
      CurrentLayer,
      LayerDatas__,
      LayerTypesManager__);
}

struct SignalFeatureInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalFeatureInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CHILD = 6
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<int32_t> *Child() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CHILD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_CHILD) &&
           verifier.VerifyVector(Child()) &&
           verifier.EndTable();
  }
};

struct SignalFeatureInfoDataBuilder {
  typedef SignalFeatureInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(SignalFeatureInfoData::VT_ID, ID, 0);
  }
  void add_Child(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Child) {
    fbb_.AddOffset(SignalFeatureInfoData::VT_CHILD, Child);
  }
  explicit SignalFeatureInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalFeatureInfoDataBuilder &operator=(const SignalFeatureInfoDataBuilder &);
  flatbuffers::Offset<SignalFeatureInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalFeatureInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalFeatureInfoData> CreateSignalFeatureInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Child = 0) {
  SignalFeatureInfoDataBuilder builder_(_fbb);
  builder_.add_Child(Child);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalFeatureInfoData> CreateSignalFeatureInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    const std::vector<int32_t> *Child = nullptr) {
  auto Child__ = Child ? _fbb.CreateVector<int32_t>(*Child) : 0;
  return FlatBufferDocSpace::CreateSignalFeatureInfoData(
      _fbb,
      ID,
      Child__);
}

struct SignalProtoInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalProtoInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOID = 4,
    VT_FEATUREINFO = 6
  };
  const flatbuffers::String *ProtoId() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SignalFeatureInfoData>> *FeatureInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SignalFeatureInfoData>> *>(VT_FEATUREINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROTOID) &&
           verifier.VerifyString(ProtoId()) &&
           VerifyOffset(verifier, VT_FEATUREINFO) &&
           verifier.VerifyVector(FeatureInfo()) &&
           verifier.VerifyVectorOfTables(FeatureInfo()) &&
           verifier.EndTable();
  }
};

struct SignalProtoInfoDataBuilder {
  typedef SignalProtoInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ProtoId(flatbuffers::Offset<flatbuffers::String> ProtoId) {
    fbb_.AddOffset(SignalProtoInfoData::VT_PROTOID, ProtoId);
  }
  void add_FeatureInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SignalFeatureInfoData>>> FeatureInfo) {
    fbb_.AddOffset(SignalProtoInfoData::VT_FEATUREINFO, FeatureInfo);
  }
  explicit SignalProtoInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalProtoInfoDataBuilder &operator=(const SignalProtoInfoDataBuilder &);
  flatbuffers::Offset<SignalProtoInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalProtoInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalProtoInfoData> CreateSignalProtoInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ProtoId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::SignalFeatureInfoData>>> FeatureInfo = 0) {
  SignalProtoInfoDataBuilder builder_(_fbb);
  builder_.add_FeatureInfo(FeatureInfo);
  builder_.add_ProtoId(ProtoId);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalProtoInfoData> CreateSignalProtoInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ProtoId = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::SignalFeatureInfoData>> *FeatureInfo = nullptr) {
  auto ProtoId__ = ProtoId ? _fbb.CreateString(ProtoId) : 0;
  auto FeatureInfo__ = FeatureInfo ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::SignalFeatureInfoData>>(*FeatureInfo) : 0;
  return FlatBufferDocSpace::CreateSignalProtoInfoData(
      _fbb,
      ProtoId__,
      FeatureInfo__);
}

struct InfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TOPO = 6
  };
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *Topo() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_TOPO) &&
           verifier.VerifyString(Topo()) &&
           verifier.EndTable();
  }
};

struct InfoDataBuilder {
  typedef InfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(InfoData::VT_ID, ID, 0);
  }
  void add_Topo(flatbuffers::Offset<flatbuffers::String> Topo) {
    fbb_.AddOffset(InfoData::VT_TOPO, Topo);
  }
  explicit InfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InfoDataBuilder &operator=(const InfoDataBuilder &);
  flatbuffers::Offset<InfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfoData> CreateInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    flatbuffers::Offset<flatbuffers::String> Topo = 0) {
  InfoDataBuilder builder_(_fbb);
  builder_.add_Topo(Topo);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<InfoData> CreateInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ID = 0,
    const char *Topo = nullptr) {
  auto Topo__ = Topo ? _fbb.CreateString(Topo) : 0;
  return FlatBufferDocSpace::CreateInfoData(
      _fbb,
      ID,
      Topo__);
}

struct SupportAlignmentTypeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SupportAlignmentTypeDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ISSUPPORTAUTOARRANGE = 4,
    VT_ISSUPPORTEQUIDDISTANCE = 6,
    VT_ISSUPPORTCOLLINEARALIGN = 8,
    VT_ISSUPPORTSTAGGERALIGN = 10,
    VT_ISSUPPORTTOPJUSTIFY = 12,
    VT_ISSUPPORTBOTTOMJUSTIFY = 14,
    VT_ISSUPPORTLEFTJUSTIFY = 16,
    VT_ISSUPPORTRIGHTJUSTIFY = 18
  };
  int32_t IsSupportAutoArrange() const {
    return GetField<int32_t>(VT_ISSUPPORTAUTOARRANGE, 0);
  }
  int32_t IsSupportEquidDistance() const {
    return GetField<int32_t>(VT_ISSUPPORTEQUIDDISTANCE, 0);
  }
  int32_t IsSupportColLinearAlign() const {
    return GetField<int32_t>(VT_ISSUPPORTCOLLINEARALIGN, 0);
  }
  int32_t IsSupportStaggerAlign() const {
    return GetField<int32_t>(VT_ISSUPPORTSTAGGERALIGN, 0);
  }
  int32_t IsSupportTopJustify() const {
    return GetField<int32_t>(VT_ISSUPPORTTOPJUSTIFY, 0);
  }
  int32_t IsSupportBottomJustify() const {
    return GetField<int32_t>(VT_ISSUPPORTBOTTOMJUSTIFY, 0);
  }
  int32_t IsSupportLeftJustify() const {
    return GetField<int32_t>(VT_ISSUPPORTLEFTJUSTIFY, 0);
  }
  int32_t IsSupportRightJustify() const {
    return GetField<int32_t>(VT_ISSUPPORTRIGHTJUSTIFY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ISSUPPORTAUTOARRANGE) &&
           VerifyField<int32_t>(verifier, VT_ISSUPPORTEQUIDDISTANCE) &&
           VerifyField<int32_t>(verifier, VT_ISSUPPORTCOLLINEARALIGN) &&
           VerifyField<int32_t>(verifier, VT_ISSUPPORTSTAGGERALIGN) &&
           VerifyField<int32_t>(verifier, VT_ISSUPPORTTOPJUSTIFY) &&
           VerifyField<int32_t>(verifier, VT_ISSUPPORTBOTTOMJUSTIFY) &&
           VerifyField<int32_t>(verifier, VT_ISSUPPORTLEFTJUSTIFY) &&
           VerifyField<int32_t>(verifier, VT_ISSUPPORTRIGHTJUSTIFY) &&
           verifier.EndTable();
  }
};

struct SupportAlignmentTypeDataBuilder {
  typedef SupportAlignmentTypeData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_IsSupportAutoArrange(int32_t IsSupportAutoArrange) {
    fbb_.AddElement<int32_t>(SupportAlignmentTypeData::VT_ISSUPPORTAUTOARRANGE, IsSupportAutoArrange, 0);
  }
  void add_IsSupportEquidDistance(int32_t IsSupportEquidDistance) {
    fbb_.AddElement<int32_t>(SupportAlignmentTypeData::VT_ISSUPPORTEQUIDDISTANCE, IsSupportEquidDistance, 0);
  }
  void add_IsSupportColLinearAlign(int32_t IsSupportColLinearAlign) {
    fbb_.AddElement<int32_t>(SupportAlignmentTypeData::VT_ISSUPPORTCOLLINEARALIGN, IsSupportColLinearAlign, 0);
  }
  void add_IsSupportStaggerAlign(int32_t IsSupportStaggerAlign) {
    fbb_.AddElement<int32_t>(SupportAlignmentTypeData::VT_ISSUPPORTSTAGGERALIGN, IsSupportStaggerAlign, 0);
  }
  void add_IsSupportTopJustify(int32_t IsSupportTopJustify) {
    fbb_.AddElement<int32_t>(SupportAlignmentTypeData::VT_ISSUPPORTTOPJUSTIFY, IsSupportTopJustify, 0);
  }
  void add_IsSupportBottomJustify(int32_t IsSupportBottomJustify) {
    fbb_.AddElement<int32_t>(SupportAlignmentTypeData::VT_ISSUPPORTBOTTOMJUSTIFY, IsSupportBottomJustify, 0);
  }
  void add_IsSupportLeftJustify(int32_t IsSupportLeftJustify) {
    fbb_.AddElement<int32_t>(SupportAlignmentTypeData::VT_ISSUPPORTLEFTJUSTIFY, IsSupportLeftJustify, 0);
  }
  void add_IsSupportRightJustify(int32_t IsSupportRightJustify) {
    fbb_.AddElement<int32_t>(SupportAlignmentTypeData::VT_ISSUPPORTRIGHTJUSTIFY, IsSupportRightJustify, 0);
  }
  explicit SupportAlignmentTypeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SupportAlignmentTypeDataBuilder &operator=(const SupportAlignmentTypeDataBuilder &);
  flatbuffers::Offset<SupportAlignmentTypeData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SupportAlignmentTypeData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SupportAlignmentTypeData> CreateSupportAlignmentTypeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t IsSupportAutoArrange = 0,
    int32_t IsSupportEquidDistance = 0,
    int32_t IsSupportColLinearAlign = 0,
    int32_t IsSupportStaggerAlign = 0,
    int32_t IsSupportTopJustify = 0,
    int32_t IsSupportBottomJustify = 0,
    int32_t IsSupportLeftJustify = 0,
    int32_t IsSupportRightJustify = 0) {
  SupportAlignmentTypeDataBuilder builder_(_fbb);
  builder_.add_IsSupportRightJustify(IsSupportRightJustify);
  builder_.add_IsSupportLeftJustify(IsSupportLeftJustify);
  builder_.add_IsSupportBottomJustify(IsSupportBottomJustify);
  builder_.add_IsSupportTopJustify(IsSupportTopJustify);
  builder_.add_IsSupportStaggerAlign(IsSupportStaggerAlign);
  builder_.add_IsSupportColLinearAlign(IsSupportColLinearAlign);
  builder_.add_IsSupportEquidDistance(IsSupportEquidDistance);
  builder_.add_IsSupportAutoArrange(IsSupportAutoArrange);
  return builder_.Finish();
}

struct MainsData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MainsDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ELEMENTS = 6,
    VT_ENTITIES = 8,
    VT_VIEWS = 10,
    VT_GROUPS = 12,
    VT_FEATUREDATAS = 14,
    VT_VARIABLES = 16,
    VT_DELELEMENTS = 18,
    VT_DELENTITIES = 20,
    VT_ISMAINHYD = 22,
    VT_TEMPLATELENGTH = 24,
    VT_TEMPLATEWIDTH = 26,
    VT_SHEETSCALE = 28,
    VT_UNDOSTEPNUM = 30,
    VT_PROJECTTYPE = 32
  };
  const flatbuffers::String *Type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Elements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *>(VT_ELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *Entities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_ENTITIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *Views() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *>(VT_VIEWS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *Groups() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *>(VT_GROUPS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *>(VT_FEATUREDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *Variables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *>(VT_VARIABLES);
  }
  const flatbuffers::Vector<int32_t> *DelElements() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELELEMENTS);
  }
  const flatbuffers::Vector<int32_t> *DelEntities() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DELENTITIES);
  }
  int32_t IsMainHyd() const {
    return GetField<int32_t>(VT_ISMAINHYD, 0);
  }
  double TemplateLength() const {
    return GetField<double>(VT_TEMPLATELENGTH, 0.0);
  }
  double TemplateWidth() const {
    return GetField<double>(VT_TEMPLATEWIDTH, 0.0);
  }
  const flatbuffers::String *SheetScale() const {
    return GetPointer<const flatbuffers::String *>(VT_SHEETSCALE);
  }
  int32_t UndoStepNum() const {
    return GetField<int32_t>(VT_UNDOSTEPNUM, 0);
  }
  int32_t ProjectType() const {
    return GetField<int32_t>(VT_PROJECTTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(Type()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(Elements()) &&
           verifier.VerifyVectorOfTables(Elements()) &&
           VerifyOffset(verifier, VT_ENTITIES) &&
           verifier.VerifyVector(Entities()) &&
           verifier.VerifyVectorOfTables(Entities()) &&
           VerifyOffset(verifier, VT_VIEWS) &&
           verifier.VerifyVector(Views()) &&
           verifier.VerifyVectorOfTables(Views()) &&
           VerifyOffset(verifier, VT_GROUPS) &&
           verifier.VerifyVector(Groups()) &&
           verifier.VerifyVectorOfTables(Groups()) &&
           VerifyOffset(verifier, VT_FEATUREDATAS) &&
           verifier.VerifyVector(FeatureDatas()) &&
           verifier.VerifyVectorOfTables(FeatureDatas()) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(Variables()) &&
           verifier.VerifyVectorOfTables(Variables()) &&
           VerifyOffset(verifier, VT_DELELEMENTS) &&
           verifier.VerifyVector(DelElements()) &&
           VerifyOffset(verifier, VT_DELENTITIES) &&
           verifier.VerifyVector(DelEntities()) &&
           VerifyField<int32_t>(verifier, VT_ISMAINHYD) &&
           VerifyField<double>(verifier, VT_TEMPLATELENGTH) &&
           VerifyField<double>(verifier, VT_TEMPLATEWIDTH) &&
           VerifyOffset(verifier, VT_SHEETSCALE) &&
           verifier.VerifyString(SheetScale()) &&
           VerifyField<int32_t>(verifier, VT_UNDOSTEPNUM) &&
           VerifyField<int32_t>(verifier, VT_PROJECTTYPE) &&
           verifier.EndTable();
  }
};

struct MainsDataBuilder {
  typedef MainsData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Type(flatbuffers::Offset<flatbuffers::String> Type) {
    fbb_.AddOffset(MainsData::VT_TYPE, Type);
  }
  void add_Elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Elements) {
    fbb_.AddOffset(MainsData::VT_ELEMENTS, Elements);
  }
  void add_Entities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> Entities) {
    fbb_.AddOffset(MainsData::VT_ENTITIES, Entities);
  }
  void add_Views(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>> Views) {
    fbb_.AddOffset(MainsData::VT_VIEWS, Views);
  }
  void add_Groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> Groups) {
    fbb_.AddOffset(MainsData::VT_GROUPS, Groups);
  }
  void add_FeatureDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas) {
    fbb_.AddOffset(MainsData::VT_FEATUREDATAS, FeatureDatas);
  }
  void add_Variables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> Variables) {
    fbb_.AddOffset(MainsData::VT_VARIABLES, Variables);
  }
  void add_DelElements(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelElements) {
    fbb_.AddOffset(MainsData::VT_DELELEMENTS, DelElements);
  }
  void add_DelEntities(flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelEntities) {
    fbb_.AddOffset(MainsData::VT_DELENTITIES, DelEntities);
  }
  void add_IsMainHyd(int32_t IsMainHyd) {
    fbb_.AddElement<int32_t>(MainsData::VT_ISMAINHYD, IsMainHyd, 0);
  }
  void add_TemplateLength(double TemplateLength) {
    fbb_.AddElement<double>(MainsData::VT_TEMPLATELENGTH, TemplateLength, 0.0);
  }
  void add_TemplateWidth(double TemplateWidth) {
    fbb_.AddElement<double>(MainsData::VT_TEMPLATEWIDTH, TemplateWidth, 0.0);
  }
  void add_SheetScale(flatbuffers::Offset<flatbuffers::String> SheetScale) {
    fbb_.AddOffset(MainsData::VT_SHEETSCALE, SheetScale);
  }
  void add_UndoStepNum(int32_t UndoStepNum) {
    fbb_.AddElement<int32_t>(MainsData::VT_UNDOSTEPNUM, UndoStepNum, 0);
  }
  void add_ProjectType(int32_t ProjectType) {
    fbb_.AddElement<int32_t>(MainsData::VT_PROJECTTYPE, ProjectType, 0);
  }
  explicit MainsDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainsDataBuilder &operator=(const MainsDataBuilder &);
  flatbuffers::Offset<MainsData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainsData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainsData> CreateMainsData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>> Elements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> Entities = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>> Views = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>> Groups = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>> FeatureDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>> Variables = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelElements = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> DelEntities = 0,
    int32_t IsMainHyd = 0,
    double TemplateLength = 0.0,
    double TemplateWidth = 0.0,
    flatbuffers::Offset<flatbuffers::String> SheetScale = 0,
    int32_t UndoStepNum = 0,
    int32_t ProjectType = 0) {
  MainsDataBuilder builder_(_fbb);
  builder_.add_TemplateWidth(TemplateWidth);
  builder_.add_TemplateLength(TemplateLength);
  builder_.add_ProjectType(ProjectType);
  builder_.add_UndoStepNum(UndoStepNum);
  builder_.add_SheetScale(SheetScale);
  builder_.add_IsMainHyd(IsMainHyd);
  builder_.add_DelEntities(DelEntities);
  builder_.add_DelElements(DelElements);
  builder_.add_Variables(Variables);
  builder_.add_FeatureDatas(FeatureDatas);
  builder_.add_Groups(Groups);
  builder_.add_Views(Views);
  builder_.add_Entities(Entities);
  builder_.add_Elements(Elements);
  builder_.add_Type(Type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MainsData> CreateMainsDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Type = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>> *Elements = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *Entities = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>> *Views = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>> *Groups = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>> *FeatureDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>> *Variables = nullptr,
    const std::vector<int32_t> *DelElements = nullptr,
    const std::vector<int32_t> *DelEntities = nullptr,
    int32_t IsMainHyd = 0,
    double TemplateLength = 0.0,
    double TemplateWidth = 0.0,
    const char *SheetScale = nullptr,
    int32_t UndoStepNum = 0,
    int32_t ProjectType = 0) {
  auto Type__ = Type ? _fbb.CreateString(Type) : 0;
  auto Elements__ = Elements ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ElementData>>(*Elements) : 0;
  auto Entities__ = Entities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*Entities) : 0;
  auto Views__ = Views ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::DrawingViewEntity>>(*Views) : 0;
  auto Groups__ = Groups ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::EntityData>>(*Groups) : 0;
  auto FeatureDatas__ = FeatureDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FeatureData>>(*FeatureDatas) : 0;
  auto Variables__ = Variables ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::VariableData>>(*Variables) : 0;
  auto DelElements__ = DelElements ? _fbb.CreateVector<int32_t>(*DelElements) : 0;
  auto DelEntities__ = DelEntities ? _fbb.CreateVector<int32_t>(*DelEntities) : 0;
  auto SheetScale__ = SheetScale ? _fbb.CreateString(SheetScale) : 0;
  return FlatBufferDocSpace::CreateMainsData(
      _fbb,
      Type__,
      Elements__,
      Entities__,
      Views__,
      Groups__,
      FeatureDatas__,
      Variables__,
      DelElements__,
      DelEntities__,
      IsMainHyd,
      TemplateLength,
      TemplateWidth,
      SheetScale__,
      UndoStepNum,
      ProjectType);
}

struct DrawinfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DrawinfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVESHEETORDER = 4,
    VT_SHEETLIST = 6,
    VT_SHEETDATA = 8,
    VT_VIEWDATA = 10,
    VT_MODE = 12,
    VT_STATUS = 14,
    VT_LAYERDATA = 16
  };
  int32_t ActiveSheetOrder() const {
    return GetField<int32_t>(VT_ACTIVESHEETORDER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ListData>> *SheetList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ListData>> *>(VT_SHEETLIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>> *SheetData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>> *>(VT_SHEETDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>> *viewData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>> *>(VT_VIEWDATA);
  }
  const flatbuffers::String *Mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  const FlatBufferDocSpace::LayerDataManager *LayerData() const {
    return GetPointer<const FlatBufferDocSpace::LayerDataManager *>(VT_LAYERDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACTIVESHEETORDER) &&
           VerifyOffset(verifier, VT_SHEETLIST) &&
           verifier.VerifyVector(SheetList()) &&
           verifier.VerifyVectorOfTables(SheetList()) &&
           VerifyOffset(verifier, VT_SHEETDATA) &&
           verifier.VerifyVector(SheetData()) &&
           verifier.VerifyVectorOfTables(SheetData()) &&
           VerifyOffset(verifier, VT_VIEWDATA) &&
           verifier.VerifyVector(viewData()) &&
           verifier.VerifyVectorOfTables(viewData()) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(Mode()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_LAYERDATA) &&
           verifier.VerifyTable(LayerData()) &&
           verifier.EndTable();
  }
};

struct DrawinfoDataBuilder {
  typedef DrawinfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ActiveSheetOrder(int32_t ActiveSheetOrder) {
    fbb_.AddElement<int32_t>(DrawinfoData::VT_ACTIVESHEETORDER, ActiveSheetOrder, 0);
  }
  void add_SheetList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ListData>>> SheetList) {
    fbb_.AddOffset(DrawinfoData::VT_SHEETLIST, SheetList);
  }
  void add_SheetData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>>> SheetData) {
    fbb_.AddOffset(DrawinfoData::VT_SHEETDATA, SheetData);
  }
  void add_viewData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>>> viewData) {
    fbb_.AddOffset(DrawinfoData::VT_VIEWDATA, viewData);
  }
  void add_Mode(flatbuffers::Offset<flatbuffers::String> Mode) {
    fbb_.AddOffset(DrawinfoData::VT_MODE, Mode);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(DrawinfoData::VT_STATUS, Status, 0);
  }
  void add_LayerData(flatbuffers::Offset<FlatBufferDocSpace::LayerDataManager> LayerData) {
    fbb_.AddOffset(DrawinfoData::VT_LAYERDATA, LayerData);
  }
  explicit DrawinfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DrawinfoDataBuilder &operator=(const DrawinfoDataBuilder &);
  flatbuffers::Offset<DrawinfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DrawinfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DrawinfoData> CreateDrawinfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ActiveSheetOrder = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ListData>>> SheetList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>>> SheetData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>>> viewData = 0,
    flatbuffers::Offset<flatbuffers::String> Mode = 0,
    int32_t Status = 0,
    flatbuffers::Offset<FlatBufferDocSpace::LayerDataManager> LayerData = 0) {
  DrawinfoDataBuilder builder_(_fbb);
  builder_.add_LayerData(LayerData);
  builder_.add_Status(Status);
  builder_.add_Mode(Mode);
  builder_.add_viewData(viewData);
  builder_.add_SheetData(SheetData);
  builder_.add_SheetList(SheetList);
  builder_.add_ActiveSheetOrder(ActiveSheetOrder);
  return builder_.Finish();
}

inline flatbuffers::Offset<DrawinfoData> CreateDrawinfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ActiveSheetOrder = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ListData>> *SheetList = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>> *SheetData = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>> *viewData = nullptr,
    const char *Mode = nullptr,
    int32_t Status = 0,
    flatbuffers::Offset<FlatBufferDocSpace::LayerDataManager> LayerData = 0) {
  auto SheetList__ = SheetList ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ListData>>(*SheetList) : 0;
  auto SheetData__ = SheetData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>>(*SheetData) : 0;
  auto viewData__ = viewData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MainsData>>(*viewData) : 0;
  auto Mode__ = Mode ? _fbb.CreateString(Mode) : 0;
  return FlatBufferDocSpace::CreateDrawinfoData(
      _fbb,
      ActiveSheetOrder,
      SheetList__,
      SheetData__,
      viewData__,
      Mode__,
      Status,
      LayerData);
}

struct ListData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ListDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INDEX = 6,
    VT_REVISIONTABLE = 8,
    VT_ISPAPER1 = 10,
    VT_VIEWSINFO = 12,
    VT_REVISION = 14,
    VT_REVISIONSYMBOLSTATUS = 16,
    VT_SHEETSCALE = 18,
    VT_PROJECTTYPE = 20
  };
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  int32_t RevisionTable() const {
    return GetField<int32_t>(VT_REVISIONTABLE, 0);
  }
  int32_t IsPaper1() const {
    return GetField<int32_t>(VT_ISPAPER1, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewDataInfo>> *ViewsInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewDataInfo>> *>(VT_VIEWSINFO);
  }
  const flatbuffers::String *Revision() const {
    return GetPointer<const flatbuffers::String *>(VT_REVISION);
  }
  int32_t RevisionSymbolStatus() const {
    return GetField<int32_t>(VT_REVISIONSYMBOLSTATUS, 0);
  }
  const flatbuffers::String *SheetScale() const {
    return GetPointer<const flatbuffers::String *>(VT_SHEETSCALE);
  }
  int32_t ProjectType() const {
    return GetField<int32_t>(VT_PROJECTTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_REVISIONTABLE) &&
           VerifyField<int32_t>(verifier, VT_ISPAPER1) &&
           VerifyOffset(verifier, VT_VIEWSINFO) &&
           verifier.VerifyVector(ViewsInfo()) &&
           verifier.VerifyVectorOfTables(ViewsInfo()) &&
           VerifyOffset(verifier, VT_REVISION) &&
           verifier.VerifyString(Revision()) &&
           VerifyField<int32_t>(verifier, VT_REVISIONSYMBOLSTATUS) &&
           VerifyOffset(verifier, VT_SHEETSCALE) &&
           verifier.VerifyString(SheetScale()) &&
           VerifyField<int32_t>(verifier, VT_PROJECTTYPE) &&
           verifier.EndTable();
  }
};

struct ListDataBuilder {
  typedef ListData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(ListData::VT_NAME, Name);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(ListData::VT_INDEX, Index, 0);
  }
  void add_RevisionTable(int32_t RevisionTable) {
    fbb_.AddElement<int32_t>(ListData::VT_REVISIONTABLE, RevisionTable, 0);
  }
  void add_IsPaper1(int32_t IsPaper1) {
    fbb_.AddElement<int32_t>(ListData::VT_ISPAPER1, IsPaper1, 0);
  }
  void add_ViewsInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewDataInfo>>> ViewsInfo) {
    fbb_.AddOffset(ListData::VT_VIEWSINFO, ViewsInfo);
  }
  void add_Revision(flatbuffers::Offset<flatbuffers::String> Revision) {
    fbb_.AddOffset(ListData::VT_REVISION, Revision);
  }
  void add_RevisionSymbolStatus(int32_t RevisionSymbolStatus) {
    fbb_.AddElement<int32_t>(ListData::VT_REVISIONSYMBOLSTATUS, RevisionSymbolStatus, 0);
  }
  void add_SheetScale(flatbuffers::Offset<flatbuffers::String> SheetScale) {
    fbb_.AddOffset(ListData::VT_SHEETSCALE, SheetScale);
  }
  void add_ProjectType(int32_t ProjectType) {
    fbb_.AddElement<int32_t>(ListData::VT_PROJECTTYPE, ProjectType, 0);
  }
  explicit ListDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ListDataBuilder &operator=(const ListDataBuilder &);
  flatbuffers::Offset<ListData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ListData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ListData> CreateListData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t Index = 0,
    int32_t RevisionTable = 0,
    int32_t IsPaper1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::ViewDataInfo>>> ViewsInfo = 0,
    flatbuffers::Offset<flatbuffers::String> Revision = 0,
    int32_t RevisionSymbolStatus = 0,
    flatbuffers::Offset<flatbuffers::String> SheetScale = 0,
    int32_t ProjectType = 0) {
  ListDataBuilder builder_(_fbb);
  builder_.add_ProjectType(ProjectType);
  builder_.add_SheetScale(SheetScale);
  builder_.add_RevisionSymbolStatus(RevisionSymbolStatus);
  builder_.add_Revision(Revision);
  builder_.add_ViewsInfo(ViewsInfo);
  builder_.add_IsPaper1(IsPaper1);
  builder_.add_RevisionTable(RevisionTable);
  builder_.add_Index(Index);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ListData> CreateListDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    int32_t Index = 0,
    int32_t RevisionTable = 0,
    int32_t IsPaper1 = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::ViewDataInfo>> *ViewsInfo = nullptr,
    const char *Revision = nullptr,
    int32_t RevisionSymbolStatus = 0,
    const char *SheetScale = nullptr,
    int32_t ProjectType = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto ViewsInfo__ = ViewsInfo ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::ViewDataInfo>>(*ViewsInfo) : 0;
  auto Revision__ = Revision ? _fbb.CreateString(Revision) : 0;
  auto SheetScale__ = SheetScale ? _fbb.CreateString(SheetScale) : 0;
  return FlatBufferDocSpace::CreateListData(
      _fbb,
      Name__,
      Index,
      RevisionTable,
      IsPaper1,
      ViewsInfo__,
      Revision__,
      RevisionSymbolStatus,
      SheetScale__,
      ProjectType);
}

struct ViewDataInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ViewDataInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VIEWNAME = 4,
    VT_VIEWTYPE = 6,
    VT_VIEWORDER = 8,
    VT_VIEWVISIBLE = 10,
    VT_BROKENSECDATAS = 12,
    VT_VIEWSCALE = 14
  };
  const flatbuffers::String *ViewName() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWNAME);
  }
  int32_t ViewType() const {
    return GetField<int32_t>(VT_VIEWTYPE, 0);
  }
  int32_t ViewOrder() const {
    return GetField<int32_t>(VT_VIEWORDER, 0);
  }
  int32_t ViewVisible() const {
    return GetField<int32_t>(VT_VIEWVISIBLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>> *BrokenSecDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>> *>(VT_BROKENSECDATAS);
  }
  const flatbuffers::String *ViewScale() const {
    return GetPointer<const flatbuffers::String *>(VT_VIEWSCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VIEWNAME) &&
           verifier.VerifyString(ViewName()) &&
           VerifyField<int32_t>(verifier, VT_VIEWTYPE) &&
           VerifyField<int32_t>(verifier, VT_VIEWORDER) &&
           VerifyField<int32_t>(verifier, VT_VIEWVISIBLE) &&
           VerifyOffset(verifier, VT_BROKENSECDATAS) &&
           verifier.VerifyVector(BrokenSecDatas()) &&
           verifier.VerifyVectorOfTables(BrokenSecDatas()) &&
           VerifyOffset(verifier, VT_VIEWSCALE) &&
           verifier.VerifyString(ViewScale()) &&
           verifier.EndTable();
  }
};

struct ViewDataInfoBuilder {
  typedef ViewDataInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ViewName(flatbuffers::Offset<flatbuffers::String> ViewName) {
    fbb_.AddOffset(ViewDataInfo::VT_VIEWNAME, ViewName);
  }
  void add_ViewType(int32_t ViewType) {
    fbb_.AddElement<int32_t>(ViewDataInfo::VT_VIEWTYPE, ViewType, 0);
  }
  void add_ViewOrder(int32_t ViewOrder) {
    fbb_.AddElement<int32_t>(ViewDataInfo::VT_VIEWORDER, ViewOrder, 0);
  }
  void add_ViewVisible(int32_t ViewVisible) {
    fbb_.AddElement<int32_t>(ViewDataInfo::VT_VIEWVISIBLE, ViewVisible, 0);
  }
  void add_BrokenSecDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>>> BrokenSecDatas) {
    fbb_.AddOffset(ViewDataInfo::VT_BROKENSECDATAS, BrokenSecDatas);
  }
  void add_ViewScale(flatbuffers::Offset<flatbuffers::String> ViewScale) {
    fbb_.AddOffset(ViewDataInfo::VT_VIEWSCALE, ViewScale);
  }
  explicit ViewDataInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ViewDataInfoBuilder &operator=(const ViewDataInfoBuilder &);
  flatbuffers::Offset<ViewDataInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ViewDataInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ViewDataInfo> CreateViewDataInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ViewName = 0,
    int32_t ViewType = 0,
    int32_t ViewOrder = 0,
    int32_t ViewVisible = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>>> BrokenSecDatas = 0,
    flatbuffers::Offset<flatbuffers::String> ViewScale = 0) {
  ViewDataInfoBuilder builder_(_fbb);
  builder_.add_ViewScale(ViewScale);
  builder_.add_BrokenSecDatas(BrokenSecDatas);
  builder_.add_ViewVisible(ViewVisible);
  builder_.add_ViewOrder(ViewOrder);
  builder_.add_ViewType(ViewType);
  builder_.add_ViewName(ViewName);
  return builder_.Finish();
}

inline flatbuffers::Offset<ViewDataInfo> CreateViewDataInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ViewName = nullptr,
    int32_t ViewType = 0,
    int32_t ViewOrder = 0,
    int32_t ViewVisible = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>> *BrokenSecDatas = nullptr,
    const char *ViewScale = nullptr) {
  auto ViewName__ = ViewName ? _fbb.CreateString(ViewName) : 0;
  auto BrokenSecDatas__ = BrokenSecDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::BrokenSecElements>>(*BrokenSecDatas) : 0;
  auto ViewScale__ = ViewScale ? _fbb.CreateString(ViewScale) : 0;
  return FlatBufferDocSpace::CreateViewDataInfo(
      _fbb,
      ViewName__,
      ViewType,
      ViewOrder,
      ViewVisible,
      BrokenSecDatas__,
      ViewScale__);
}

struct FlatBufferDrawingDoc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlatBufferDrawingDocBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6,
    VT_SHEETSCALE = 8,
    VT_DRAWINGDATA = 10,
    VT_DRAWINGQUERY = 12,
    VT_PROJECTTYPE = 14
  };
  FlatBufferDocSpace::DataMessage Data_type() const {
    return static_cast<FlatBufferDocSpace::DataMessage>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *Data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *Data_as() const;
  const FlatBufferDocSpace::IncrementalData *Data_as_IncrementalData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IncrementalData ? static_cast<const FlatBufferDocSpace::IncrementalData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::AssemblyPartData *Data_as_AssemblyPartData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_AssemblyPartData ? static_cast<const FlatBufferDocSpace::AssemblyPartData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::InitCmdData *Data_as_InitCmdData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_InitCmdData ? static_cast<const FlatBufferDocSpace::InitCmdData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::IncrementalCompData *Data_as_IncrementalCompData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IncrementalCompData ? static_cast<const FlatBufferDocSpace::IncrementalCompData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SerializePreviewData *Data_as_SerializePreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SerializePreviewData ? static_cast<const FlatBufferDocSpace::SerializePreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SpecialPreviewInforData *Data_as_SpecialPreviewInforData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SpecialPreviewInforData ? static_cast<const FlatBufferDocSpace::SpecialPreviewInforData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SketchPreviewData *Data_as_SketchPreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SketchPreviewData ? static_cast<const FlatBufferDocSpace::SketchPreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SketchCheckData *Data_as_SketchCheckData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SketchCheckData ? static_cast<const FlatBufferDocSpace::SketchCheckData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::DatumPreviewData *Data_as_DatumPreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_DatumPreviewData ? static_cast<const FlatBufferDocSpace::DatumPreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::InitOffsetCurveData *Data_as_InitOffsetCurveData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_InitOffsetCurveData ? static_cast<const FlatBufferDocSpace::InitOffsetCurveData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::WorkPlaneMatrixData *Data_as_WorkPlaneMatrixData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_WorkPlaneMatrixData ? static_cast<const FlatBufferDocSpace::WorkPlaneMatrixData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::MeasureInforData *Data_as_MeasureInforData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_MeasureInforData ? static_cast<const FlatBufferDocSpace::MeasureInforData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::VariableDataMessage *Data_as_VariableDataMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_VariableDataMessage ? static_cast<const FlatBufferDocSpace::VariableDataMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::DimensionDataInforMessage *Data_as_DimensionDataInforMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_DimensionDataInforMessage ? static_cast<const FlatBufferDocSpace::DimensionDataInforMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ElementData *Data_as_ElementData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ElementData ? static_cast<const FlatBufferDocSpace::ElementData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ErrorStringData *Data_as_ErrorStringData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ErrorStringData ? static_cast<const FlatBufferDocSpace::ErrorStringData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::MassPropertyData *Data_as_MassPropertyData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_MassPropertyData ? static_cast<const FlatBufferDocSpace::MassPropertyData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::IntegerValue *Data_as_IntegerValue() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IntegerValue ? static_cast<const FlatBufferDocSpace::IntegerValue *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SaveData *Data_as_SaveData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SaveData ? static_cast<const FlatBufferDocSpace::SaveData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::CurvatureData *Data_as_CurvatureData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_CurvatureData ? static_cast<const FlatBufferDocSpace::CurvatureData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SurfaceCurvatureData *Data_as_SurfaceCurvatureData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SurfaceCurvatureData ? static_cast<const FlatBufferDocSpace::SurfaceCurvatureData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::IdData *Data_as_IdData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IdData ? static_cast<const FlatBufferDocSpace::IdData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::CheckGapData *Data_as_CheckGapData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_CheckGapData ? static_cast<const FlatBufferDocSpace::CheckGapData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::TotalMassData *Data_as_TotalMassData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_TotalMassData ? static_cast<const FlatBufferDocSpace::TotalMassData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::CheckVariableData *Data_as_CheckVariableData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_CheckVariableData ? static_cast<const FlatBufferDocSpace::CheckVariableData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ArsPreviewData *Data_as_ArsPreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ArsPreviewData ? static_cast<const FlatBufferDocSpace::ArsPreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::HoleParamDataMessage *Data_as_HoleParamDataMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_HoleParamDataMessage ? static_cast<const FlatBufferDocSpace::HoleParamDataMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::CosmeticThreadParamDataMessage *Data_as_CosmeticThreadParamDataMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_CosmeticThreadParamDataMessage ? static_cast<const FlatBufferDocSpace::CosmeticThreadParamDataMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SweepPathParamDataMessage *Data_as_SweepPathParamDataMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SweepPathParamDataMessage ? static_cast<const FlatBufferDocSpace::SweepPathParamDataMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::BoundingBoxData *Data_as_BoundingBoxData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_BoundingBoxData ? static_cast<const FlatBufferDocSpace::BoundingBoxData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::TextureInfoData *Data_as_TextureInfoData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_TextureInfoData ? static_cast<const FlatBufferDocSpace::TextureInfoData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::TorqueAxisData *Data_as_TorqueAxisData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_TorqueAxisData ? static_cast<const FlatBufferDocSpace::TorqueAxisData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::IncrementalDrawingData *Data_as_IncrementalDrawingData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IncrementalDrawingData ? static_cast<const FlatBufferDocSpace::IncrementalDrawingData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::DrawingPreviewData *Data_as_DrawingPreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_DrawingPreviewData ? static_cast<const FlatBufferDocSpace::DrawingPreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SerializeInitData *Data_as_SerializeInitData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SerializeInitData ? static_cast<const FlatBufferDocSpace::SerializeInitData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::FolderGroupData *Data_as_FolderGroupData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_FolderGroupData ? static_cast<const FlatBufferDocSpace::FolderGroupData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::FeatRelations *Data_as_FeatRelations() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_FeatRelations ? static_cast<const FlatBufferDocSpace::FeatRelations *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::DraftAnalysisData *Data_as_DraftAnalysisData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_DraftAnalysisData ? static_cast<const FlatBufferDocSpace::DraftAnalysisData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ThicknessAnalysisData *Data_as_ThicknessAnalysisData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ThicknessAnalysisData ? static_cast<const FlatBufferDocSpace::ThicknessAnalysisData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::PreviewSimulationData *Data_as_PreviewSimulationData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_PreviewSimulationData ? static_cast<const FlatBufferDocSpace::PreviewSimulationData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ExtRefTree *Data_as_ExtRefTree() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ExtRefTree ? static_cast<const FlatBufferDocSpace::ExtRefTree *>(Data()) : nullptr;
  }
  const flatbuffers::String *SheetScale() const {
    return GetPointer<const flatbuffers::String *>(VT_SHEETSCALE);
  }
  const FlatBufferDocSpace::DrawinfoData *DrawingData() const {
    return GetPointer<const FlatBufferDocSpace::DrawinfoData *>(VT_DRAWINGDATA);
  }
  const FlatBufferDocSpace::DrawingQueryData *DrawingQuery() const {
    return GetPointer<const FlatBufferDocSpace::DrawingQueryData *>(VT_DRAWINGQUERY);
  }
  int32_t ProjectType() const {
    return GetField<int32_t>(VT_PROJECTTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyDataMessage(verifier, Data(), Data_type()) &&
           VerifyOffset(verifier, VT_SHEETSCALE) &&
           verifier.VerifyString(SheetScale()) &&
           VerifyOffset(verifier, VT_DRAWINGDATA) &&
           verifier.VerifyTable(DrawingData()) &&
           VerifyOffset(verifier, VT_DRAWINGQUERY) &&
           verifier.VerifyTable(DrawingQuery()) &&
           VerifyField<int32_t>(verifier, VT_PROJECTTYPE) &&
           verifier.EndTable();
  }
};

template<> inline const FlatBufferDocSpace::IncrementalData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::IncrementalData>() const {
  return Data_as_IncrementalData();
}

template<> inline const FlatBufferDocSpace::AssemblyPartData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::AssemblyPartData>() const {
  return Data_as_AssemblyPartData();
}

template<> inline const FlatBufferDocSpace::InitCmdData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::InitCmdData>() const {
  return Data_as_InitCmdData();
}

template<> inline const FlatBufferDocSpace::IncrementalCompData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::IncrementalCompData>() const {
  return Data_as_IncrementalCompData();
}

template<> inline const FlatBufferDocSpace::SerializePreviewData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::SerializePreviewData>() const {
  return Data_as_SerializePreviewData();
}

template<> inline const FlatBufferDocSpace::SpecialPreviewInforData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::SpecialPreviewInforData>() const {
  return Data_as_SpecialPreviewInforData();
}

template<> inline const FlatBufferDocSpace::SketchPreviewData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::SketchPreviewData>() const {
  return Data_as_SketchPreviewData();
}

template<> inline const FlatBufferDocSpace::SketchCheckData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::SketchCheckData>() const {
  return Data_as_SketchCheckData();
}

template<> inline const FlatBufferDocSpace::DatumPreviewData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::DatumPreviewData>() const {
  return Data_as_DatumPreviewData();
}

template<> inline const FlatBufferDocSpace::InitOffsetCurveData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::InitOffsetCurveData>() const {
  return Data_as_InitOffsetCurveData();
}

template<> inline const FlatBufferDocSpace::WorkPlaneMatrixData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::WorkPlaneMatrixData>() const {
  return Data_as_WorkPlaneMatrixData();
}

template<> inline const FlatBufferDocSpace::MeasureInforData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::MeasureInforData>() const {
  return Data_as_MeasureInforData();
}

template<> inline const FlatBufferDocSpace::VariableDataMessage *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::VariableDataMessage>() const {
  return Data_as_VariableDataMessage();
}

template<> inline const FlatBufferDocSpace::DimensionDataInforMessage *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::DimensionDataInforMessage>() const {
  return Data_as_DimensionDataInforMessage();
}

template<> inline const FlatBufferDocSpace::ElementData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::ElementData>() const {
  return Data_as_ElementData();
}

template<> inline const FlatBufferDocSpace::ErrorStringData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::ErrorStringData>() const {
  return Data_as_ErrorStringData();
}

template<> inline const FlatBufferDocSpace::MassPropertyData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::MassPropertyData>() const {
  return Data_as_MassPropertyData();
}

template<> inline const FlatBufferDocSpace::IntegerValue *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::IntegerValue>() const {
  return Data_as_IntegerValue();
}

template<> inline const FlatBufferDocSpace::SaveData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::SaveData>() const {
  return Data_as_SaveData();
}

template<> inline const FlatBufferDocSpace::CurvatureData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::CurvatureData>() const {
  return Data_as_CurvatureData();
}

template<> inline const FlatBufferDocSpace::SurfaceCurvatureData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::SurfaceCurvatureData>() const {
  return Data_as_SurfaceCurvatureData();
}

template<> inline const FlatBufferDocSpace::IdData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::IdData>() const {
  return Data_as_IdData();
}

template<> inline const FlatBufferDocSpace::CheckGapData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::CheckGapData>() const {
  return Data_as_CheckGapData();
}

template<> inline const FlatBufferDocSpace::TotalMassData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::TotalMassData>() const {
  return Data_as_TotalMassData();
}

template<> inline const FlatBufferDocSpace::CheckVariableData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::CheckVariableData>() const {
  return Data_as_CheckVariableData();
}

template<> inline const FlatBufferDocSpace::ArsPreviewData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::ArsPreviewData>() const {
  return Data_as_ArsPreviewData();
}

template<> inline const FlatBufferDocSpace::HoleParamDataMessage *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::HoleParamDataMessage>() const {
  return Data_as_HoleParamDataMessage();
}

template<> inline const FlatBufferDocSpace::CosmeticThreadParamDataMessage *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::CosmeticThreadParamDataMessage>() const {
  return Data_as_CosmeticThreadParamDataMessage();
}

template<> inline const FlatBufferDocSpace::SweepPathParamDataMessage *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::SweepPathParamDataMessage>() const {
  return Data_as_SweepPathParamDataMessage();
}

template<> inline const FlatBufferDocSpace::BoundingBoxData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::BoundingBoxData>() const {
  return Data_as_BoundingBoxData();
}

template<> inline const FlatBufferDocSpace::TextureInfoData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::TextureInfoData>() const {
  return Data_as_TextureInfoData();
}

template<> inline const FlatBufferDocSpace::TorqueAxisData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::TorqueAxisData>() const {
  return Data_as_TorqueAxisData();
}

template<> inline const FlatBufferDocSpace::IncrementalDrawingData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::IncrementalDrawingData>() const {
  return Data_as_IncrementalDrawingData();
}

template<> inline const FlatBufferDocSpace::DrawingPreviewData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::DrawingPreviewData>() const {
  return Data_as_DrawingPreviewData();
}

template<> inline const FlatBufferDocSpace::SerializeInitData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::SerializeInitData>() const {
  return Data_as_SerializeInitData();
}

template<> inline const FlatBufferDocSpace::FolderGroupData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::FolderGroupData>() const {
  return Data_as_FolderGroupData();
}

template<> inline const FlatBufferDocSpace::FeatRelations *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::FeatRelations>() const {
  return Data_as_FeatRelations();
}

template<> inline const FlatBufferDocSpace::DraftAnalysisData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::DraftAnalysisData>() const {
  return Data_as_DraftAnalysisData();
}

template<> inline const FlatBufferDocSpace::ThicknessAnalysisData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::ThicknessAnalysisData>() const {
  return Data_as_ThicknessAnalysisData();
}

template<> inline const FlatBufferDocSpace::PreviewSimulationData *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::PreviewSimulationData>() const {
  return Data_as_PreviewSimulationData();
}

template<> inline const FlatBufferDocSpace::ExtRefTree *FlatBufferDrawingDoc::Data_as<FlatBufferDocSpace::ExtRefTree>() const {
  return Data_as_ExtRefTree();
}

struct FlatBufferDrawingDocBuilder {
  typedef FlatBufferDrawingDoc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Data_type(FlatBufferDocSpace::DataMessage Data_type) {
    fbb_.AddElement<uint8_t>(FlatBufferDrawingDoc::VT_DATA_TYPE, static_cast<uint8_t>(Data_type), 0);
  }
  void add_Data(flatbuffers::Offset<void> Data) {
    fbb_.AddOffset(FlatBufferDrawingDoc::VT_DATA, Data);
  }
  void add_SheetScale(flatbuffers::Offset<flatbuffers::String> SheetScale) {
    fbb_.AddOffset(FlatBufferDrawingDoc::VT_SHEETSCALE, SheetScale);
  }
  void add_DrawingData(flatbuffers::Offset<FlatBufferDocSpace::DrawinfoData> DrawingData) {
    fbb_.AddOffset(FlatBufferDrawingDoc::VT_DRAWINGDATA, DrawingData);
  }
  void add_DrawingQuery(flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryData> DrawingQuery) {
    fbb_.AddOffset(FlatBufferDrawingDoc::VT_DRAWINGQUERY, DrawingQuery);
  }
  void add_ProjectType(int32_t ProjectType) {
    fbb_.AddElement<int32_t>(FlatBufferDrawingDoc::VT_PROJECTTYPE, ProjectType, 0);
  }
  explicit FlatBufferDrawingDocBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlatBufferDrawingDocBuilder &operator=(const FlatBufferDrawingDocBuilder &);
  flatbuffers::Offset<FlatBufferDrawingDoc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlatBufferDrawingDoc>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlatBufferDrawingDoc> CreateFlatBufferDrawingDoc(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::DataMessage Data_type = FlatBufferDocSpace::DataMessage_NONE,
    flatbuffers::Offset<void> Data = 0,
    flatbuffers::Offset<flatbuffers::String> SheetScale = 0,
    flatbuffers::Offset<FlatBufferDocSpace::DrawinfoData> DrawingData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryData> DrawingQuery = 0,
    int32_t ProjectType = 0) {
  FlatBufferDrawingDocBuilder builder_(_fbb);
  builder_.add_ProjectType(ProjectType);
  builder_.add_DrawingQuery(DrawingQuery);
  builder_.add_DrawingData(DrawingData);
  builder_.add_SheetScale(SheetScale);
  builder_.add_Data(Data);
  builder_.add_Data_type(Data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlatBufferDrawingDoc> CreateFlatBufferDrawingDocDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::DataMessage Data_type = FlatBufferDocSpace::DataMessage_NONE,
    flatbuffers::Offset<void> Data = 0,
    const char *SheetScale = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::DrawinfoData> DrawingData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::DrawingQueryData> DrawingQuery = 0,
    int32_t ProjectType = 0) {
  auto SheetScale__ = SheetScale ? _fbb.CreateString(SheetScale) : 0;
  return FlatBufferDocSpace::CreateFlatBufferDrawingDoc(
      _fbb,
      Data_type,
      Data,
      SheetScale__,
      DrawingData,
      DrawingQuery,
      ProjectType);
}

struct FlatBufferDoc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlatBufferDocBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6,
    VT_ENTITYTYPE = 8,
    VT_MODE = 10,
    VT_STATUS = 12,
    VT_ERROR = 14,
    VT_ROLLFEATUREID = 16,
    VT_CURRENTFEATURE = 18,
    VT_SKETCHWORKSTATE = 20,
    VT_UNDOSTEPNUM = 22,
    VT_REDOSTEPNUM = 24,
    VT_MODELTIME = 26,
    VT_RESULTTIME = 28,
    VT_TOPDOWN = 30,
    VT_BOX = 32,
    VT_NAME = 34,
    VT_PCFDATAS = 36,
    VT_CUTLISTDATAS = 38,
    VT_STUDYSOLVE = 40,
    VT_UP = 42,
    VT_NORMAL = 44,
    VT_MATERIALS = 46,
    VT_REPEATENTITIES = 48,
    VT_INSTANCEINFO = 50,
    VT_ERRORCURVEIDS = 52,
    VT_STUDYREPORT = 54,
    VT_HYPUPDATE = 56,
    VT_DRAWINGDOCDATA = 58,
    VT_LAYERDATASMANAGER = 60
  };
  FlatBufferDocSpace::DataMessage Data_type() const {
    return static_cast<FlatBufferDocSpace::DataMessage>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *Data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *Data_as() const;
  const FlatBufferDocSpace::IncrementalData *Data_as_IncrementalData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IncrementalData ? static_cast<const FlatBufferDocSpace::IncrementalData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::AssemblyPartData *Data_as_AssemblyPartData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_AssemblyPartData ? static_cast<const FlatBufferDocSpace::AssemblyPartData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::InitCmdData *Data_as_InitCmdData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_InitCmdData ? static_cast<const FlatBufferDocSpace::InitCmdData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::IncrementalCompData *Data_as_IncrementalCompData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IncrementalCompData ? static_cast<const FlatBufferDocSpace::IncrementalCompData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SerializePreviewData *Data_as_SerializePreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SerializePreviewData ? static_cast<const FlatBufferDocSpace::SerializePreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SpecialPreviewInforData *Data_as_SpecialPreviewInforData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SpecialPreviewInforData ? static_cast<const FlatBufferDocSpace::SpecialPreviewInforData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SketchPreviewData *Data_as_SketchPreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SketchPreviewData ? static_cast<const FlatBufferDocSpace::SketchPreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SketchCheckData *Data_as_SketchCheckData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SketchCheckData ? static_cast<const FlatBufferDocSpace::SketchCheckData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::DatumPreviewData *Data_as_DatumPreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_DatumPreviewData ? static_cast<const FlatBufferDocSpace::DatumPreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::InitOffsetCurveData *Data_as_InitOffsetCurveData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_InitOffsetCurveData ? static_cast<const FlatBufferDocSpace::InitOffsetCurveData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::WorkPlaneMatrixData *Data_as_WorkPlaneMatrixData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_WorkPlaneMatrixData ? static_cast<const FlatBufferDocSpace::WorkPlaneMatrixData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::MeasureInforData *Data_as_MeasureInforData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_MeasureInforData ? static_cast<const FlatBufferDocSpace::MeasureInforData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::VariableDataMessage *Data_as_VariableDataMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_VariableDataMessage ? static_cast<const FlatBufferDocSpace::VariableDataMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::DimensionDataInforMessage *Data_as_DimensionDataInforMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_DimensionDataInforMessage ? static_cast<const FlatBufferDocSpace::DimensionDataInforMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ElementData *Data_as_ElementData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ElementData ? static_cast<const FlatBufferDocSpace::ElementData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ErrorStringData *Data_as_ErrorStringData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ErrorStringData ? static_cast<const FlatBufferDocSpace::ErrorStringData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::MassPropertyData *Data_as_MassPropertyData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_MassPropertyData ? static_cast<const FlatBufferDocSpace::MassPropertyData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::IntegerValue *Data_as_IntegerValue() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IntegerValue ? static_cast<const FlatBufferDocSpace::IntegerValue *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SaveData *Data_as_SaveData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SaveData ? static_cast<const FlatBufferDocSpace::SaveData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::CurvatureData *Data_as_CurvatureData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_CurvatureData ? static_cast<const FlatBufferDocSpace::CurvatureData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SurfaceCurvatureData *Data_as_SurfaceCurvatureData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SurfaceCurvatureData ? static_cast<const FlatBufferDocSpace::SurfaceCurvatureData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::IdData *Data_as_IdData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IdData ? static_cast<const FlatBufferDocSpace::IdData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::CheckGapData *Data_as_CheckGapData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_CheckGapData ? static_cast<const FlatBufferDocSpace::CheckGapData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::TotalMassData *Data_as_TotalMassData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_TotalMassData ? static_cast<const FlatBufferDocSpace::TotalMassData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::CheckVariableData *Data_as_CheckVariableData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_CheckVariableData ? static_cast<const FlatBufferDocSpace::CheckVariableData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ArsPreviewData *Data_as_ArsPreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ArsPreviewData ? static_cast<const FlatBufferDocSpace::ArsPreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::HoleParamDataMessage *Data_as_HoleParamDataMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_HoleParamDataMessage ? static_cast<const FlatBufferDocSpace::HoleParamDataMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::CosmeticThreadParamDataMessage *Data_as_CosmeticThreadParamDataMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_CosmeticThreadParamDataMessage ? static_cast<const FlatBufferDocSpace::CosmeticThreadParamDataMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SweepPathParamDataMessage *Data_as_SweepPathParamDataMessage() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SweepPathParamDataMessage ? static_cast<const FlatBufferDocSpace::SweepPathParamDataMessage *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::BoundingBoxData *Data_as_BoundingBoxData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_BoundingBoxData ? static_cast<const FlatBufferDocSpace::BoundingBoxData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::TextureInfoData *Data_as_TextureInfoData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_TextureInfoData ? static_cast<const FlatBufferDocSpace::TextureInfoData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::TorqueAxisData *Data_as_TorqueAxisData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_TorqueAxisData ? static_cast<const FlatBufferDocSpace::TorqueAxisData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::IncrementalDrawingData *Data_as_IncrementalDrawingData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_IncrementalDrawingData ? static_cast<const FlatBufferDocSpace::IncrementalDrawingData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::DrawingPreviewData *Data_as_DrawingPreviewData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_DrawingPreviewData ? static_cast<const FlatBufferDocSpace::DrawingPreviewData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::SerializeInitData *Data_as_SerializeInitData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_SerializeInitData ? static_cast<const FlatBufferDocSpace::SerializeInitData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::FolderGroupData *Data_as_FolderGroupData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_FolderGroupData ? static_cast<const FlatBufferDocSpace::FolderGroupData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::FeatRelations *Data_as_FeatRelations() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_FeatRelations ? static_cast<const FlatBufferDocSpace::FeatRelations *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::DraftAnalysisData *Data_as_DraftAnalysisData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_DraftAnalysisData ? static_cast<const FlatBufferDocSpace::DraftAnalysisData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ThicknessAnalysisData *Data_as_ThicknessAnalysisData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ThicknessAnalysisData ? static_cast<const FlatBufferDocSpace::ThicknessAnalysisData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::PreviewSimulationData *Data_as_PreviewSimulationData() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_PreviewSimulationData ? static_cast<const FlatBufferDocSpace::PreviewSimulationData *>(Data()) : nullptr;
  }
  const FlatBufferDocSpace::ExtRefTree *Data_as_ExtRefTree() const {
    return Data_type() == FlatBufferDocSpace::DataMessage_ExtRefTree ? static_cast<const FlatBufferDocSpace::ExtRefTree *>(Data()) : nullptr;
  }
  int32_t EntityType() const {
    return GetField<int32_t>(VT_ENTITYTYPE, 0);
  }
  const flatbuffers::String *Mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  int32_t Status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  const FlatBufferDocSpace::ErrorMessage *Error() const {
    return GetPointer<const FlatBufferDocSpace::ErrorMessage *>(VT_ERROR);
  }
  int32_t RollFeatureId() const {
    return GetField<int32_t>(VT_ROLLFEATUREID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CurrentFeatureData>> *CurrentFeature() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CurrentFeatureData>> *>(VT_CURRENTFEATURE);
  }
  bool SketchWorkState() const {
    return GetField<uint8_t>(VT_SKETCHWORKSTATE, 0) != 0;
  }
  int64_t UndoStepNum() const {
    return GetField<int64_t>(VT_UNDOSTEPNUM, 0);
  }
  int64_t RedoStepNum() const {
    return GetField<int64_t>(VT_REDOSTEPNUM, 0);
  }
  double ModelTime() const {
    return GetField<double>(VT_MODELTIME, 0.0);
  }
  double ResultTime() const {
    return GetField<double>(VT_RESULTTIME, 0.0);
  }
  const flatbuffers::String *TopDown() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPDOWN);
  }
  const flatbuffers::Vector<float> *Box() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BOX);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PipeDocData>> *PCFDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PipeDocData>> *>(VT_PCFDATAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>> *CutListDatas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>> *>(VT_CUTLISTDATAS);
  }
  const FlatBufferDocSpace::StudySolveData *StudySolve() const {
    return GetPointer<const FlatBufferDocSpace::StudySolveData *>(VT_STUDYSOLVE);
  }
  const flatbuffers::Vector<float> *Up() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_UP);
  }
  const flatbuffers::Vector<float> *Normal() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_NORMAL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *Materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>> *RepeatEntities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>> *>(VT_REPEATENTITIES);
  }
  const FlatBufferDocSpace::InstanceInfoData *InstanceInfo() const {
    return GetPointer<const FlatBufferDocSpace::InstanceInfoData *>(VT_INSTANCEINFO);
  }
  const flatbuffers::Vector<int32_t> *ErrorCurveIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ERRORCURVEIDS);
  }
  const FlatBufferDocSpace::StudyReportData *StudyReport() const {
    return GetPointer<const FlatBufferDocSpace::StudyReportData *>(VT_STUDYREPORT);
  }
  const FlatBufferDocSpace::HypUpdateMessage *HypUpdate() const {
    return GetPointer<const FlatBufferDocSpace::HypUpdateMessage *>(VT_HYPUPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FlatBufferDrawingDoc>> *DrawingDocData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FlatBufferDrawingDoc>> *>(VT_DRAWINGDOCDATA);
  }
  const FlatBufferDocSpace::LayerDataManager *LayerDatasManager() const {
    return GetPointer<const FlatBufferDocSpace::LayerDataManager *>(VT_LAYERDATASMANAGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyDataMessage(verifier, Data(), Data_type()) &&
           VerifyField<int32_t>(verifier, VT_ENTITYTYPE) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(Mode()) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(Error()) &&
           VerifyField<int32_t>(verifier, VT_ROLLFEATUREID) &&
           VerifyOffset(verifier, VT_CURRENTFEATURE) &&
           verifier.VerifyVector(CurrentFeature()) &&
           verifier.VerifyVectorOfTables(CurrentFeature()) &&
           VerifyField<uint8_t>(verifier, VT_SKETCHWORKSTATE) &&
           VerifyField<int64_t>(verifier, VT_UNDOSTEPNUM) &&
           VerifyField<int64_t>(verifier, VT_REDOSTEPNUM) &&
           VerifyField<double>(verifier, VT_MODELTIME) &&
           VerifyField<double>(verifier, VT_RESULTTIME) &&
           VerifyOffset(verifier, VT_TOPDOWN) &&
           verifier.VerifyString(TopDown()) &&
           VerifyOffset(verifier, VT_BOX) &&
           verifier.VerifyVector(Box()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_PCFDATAS) &&
           verifier.VerifyVector(PCFDatas()) &&
           verifier.VerifyVectorOfTables(PCFDatas()) &&
           VerifyOffset(verifier, VT_CUTLISTDATAS) &&
           verifier.VerifyVector(CutListDatas()) &&
           verifier.VerifyVectorOfTables(CutListDatas()) &&
           VerifyOffset(verifier, VT_STUDYSOLVE) &&
           verifier.VerifyTable(StudySolve()) &&
           VerifyOffset(verifier, VT_UP) &&
           verifier.VerifyVector(Up()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyVector(Normal()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(Materials()) &&
           verifier.VerifyVectorOfTables(Materials()) &&
           VerifyOffset(verifier, VT_REPEATENTITIES) &&
           verifier.VerifyVector(RepeatEntities()) &&
           verifier.VerifyVectorOfTables(RepeatEntities()) &&
           VerifyOffset(verifier, VT_INSTANCEINFO) &&
           verifier.VerifyTable(InstanceInfo()) &&
           VerifyOffset(verifier, VT_ERRORCURVEIDS) &&
           verifier.VerifyVector(ErrorCurveIds()) &&
           VerifyOffset(verifier, VT_STUDYREPORT) &&
           verifier.VerifyTable(StudyReport()) &&
           VerifyOffset(verifier, VT_HYPUPDATE) &&
           verifier.VerifyTable(HypUpdate()) &&
           VerifyOffset(verifier, VT_DRAWINGDOCDATA) &&
           verifier.VerifyVector(DrawingDocData()) &&
           verifier.VerifyVectorOfTables(DrawingDocData()) &&
           VerifyOffset(verifier, VT_LAYERDATASMANAGER) &&
           verifier.VerifyTable(LayerDatasManager()) &&
           verifier.EndTable();
  }
};

template<> inline const FlatBufferDocSpace::IncrementalData *FlatBufferDoc::Data_as<FlatBufferDocSpace::IncrementalData>() const {
  return Data_as_IncrementalData();
}

template<> inline const FlatBufferDocSpace::AssemblyPartData *FlatBufferDoc::Data_as<FlatBufferDocSpace::AssemblyPartData>() const {
  return Data_as_AssemblyPartData();
}

template<> inline const FlatBufferDocSpace::InitCmdData *FlatBufferDoc::Data_as<FlatBufferDocSpace::InitCmdData>() const {
  return Data_as_InitCmdData();
}

template<> inline const FlatBufferDocSpace::IncrementalCompData *FlatBufferDoc::Data_as<FlatBufferDocSpace::IncrementalCompData>() const {
  return Data_as_IncrementalCompData();
}

template<> inline const FlatBufferDocSpace::SerializePreviewData *FlatBufferDoc::Data_as<FlatBufferDocSpace::SerializePreviewData>() const {
  return Data_as_SerializePreviewData();
}

template<> inline const FlatBufferDocSpace::SpecialPreviewInforData *FlatBufferDoc::Data_as<FlatBufferDocSpace::SpecialPreviewInforData>() const {
  return Data_as_SpecialPreviewInforData();
}

template<> inline const FlatBufferDocSpace::SketchPreviewData *FlatBufferDoc::Data_as<FlatBufferDocSpace::SketchPreviewData>() const {
  return Data_as_SketchPreviewData();
}

template<> inline const FlatBufferDocSpace::SketchCheckData *FlatBufferDoc::Data_as<FlatBufferDocSpace::SketchCheckData>() const {
  return Data_as_SketchCheckData();
}

template<> inline const FlatBufferDocSpace::DatumPreviewData *FlatBufferDoc::Data_as<FlatBufferDocSpace::DatumPreviewData>() const {
  return Data_as_DatumPreviewData();
}

template<> inline const FlatBufferDocSpace::InitOffsetCurveData *FlatBufferDoc::Data_as<FlatBufferDocSpace::InitOffsetCurveData>() const {
  return Data_as_InitOffsetCurveData();
}

template<> inline const FlatBufferDocSpace::WorkPlaneMatrixData *FlatBufferDoc::Data_as<FlatBufferDocSpace::WorkPlaneMatrixData>() const {
  return Data_as_WorkPlaneMatrixData();
}

template<> inline const FlatBufferDocSpace::MeasureInforData *FlatBufferDoc::Data_as<FlatBufferDocSpace::MeasureInforData>() const {
  return Data_as_MeasureInforData();
}

template<> inline const FlatBufferDocSpace::VariableDataMessage *FlatBufferDoc::Data_as<FlatBufferDocSpace::VariableDataMessage>() const {
  return Data_as_VariableDataMessage();
}

template<> inline const FlatBufferDocSpace::DimensionDataInforMessage *FlatBufferDoc::Data_as<FlatBufferDocSpace::DimensionDataInforMessage>() const {
  return Data_as_DimensionDataInforMessage();
}

template<> inline const FlatBufferDocSpace::ElementData *FlatBufferDoc::Data_as<FlatBufferDocSpace::ElementData>() const {
  return Data_as_ElementData();
}

template<> inline const FlatBufferDocSpace::ErrorStringData *FlatBufferDoc::Data_as<FlatBufferDocSpace::ErrorStringData>() const {
  return Data_as_ErrorStringData();
}

template<> inline const FlatBufferDocSpace::MassPropertyData *FlatBufferDoc::Data_as<FlatBufferDocSpace::MassPropertyData>() const {
  return Data_as_MassPropertyData();
}

template<> inline const FlatBufferDocSpace::IntegerValue *FlatBufferDoc::Data_as<FlatBufferDocSpace::IntegerValue>() const {
  return Data_as_IntegerValue();
}

template<> inline const FlatBufferDocSpace::SaveData *FlatBufferDoc::Data_as<FlatBufferDocSpace::SaveData>() const {
  return Data_as_SaveData();
}

template<> inline const FlatBufferDocSpace::CurvatureData *FlatBufferDoc::Data_as<FlatBufferDocSpace::CurvatureData>() const {
  return Data_as_CurvatureData();
}

template<> inline const FlatBufferDocSpace::SurfaceCurvatureData *FlatBufferDoc::Data_as<FlatBufferDocSpace::SurfaceCurvatureData>() const {
  return Data_as_SurfaceCurvatureData();
}

template<> inline const FlatBufferDocSpace::IdData *FlatBufferDoc::Data_as<FlatBufferDocSpace::IdData>() const {
  return Data_as_IdData();
}

template<> inline const FlatBufferDocSpace::CheckGapData *FlatBufferDoc::Data_as<FlatBufferDocSpace::CheckGapData>() const {
  return Data_as_CheckGapData();
}

template<> inline const FlatBufferDocSpace::TotalMassData *FlatBufferDoc::Data_as<FlatBufferDocSpace::TotalMassData>() const {
  return Data_as_TotalMassData();
}

template<> inline const FlatBufferDocSpace::CheckVariableData *FlatBufferDoc::Data_as<FlatBufferDocSpace::CheckVariableData>() const {
  return Data_as_CheckVariableData();
}

template<> inline const FlatBufferDocSpace::ArsPreviewData *FlatBufferDoc::Data_as<FlatBufferDocSpace::ArsPreviewData>() const {
  return Data_as_ArsPreviewData();
}

template<> inline const FlatBufferDocSpace::HoleParamDataMessage *FlatBufferDoc::Data_as<FlatBufferDocSpace::HoleParamDataMessage>() const {
  return Data_as_HoleParamDataMessage();
}

template<> inline const FlatBufferDocSpace::CosmeticThreadParamDataMessage *FlatBufferDoc::Data_as<FlatBufferDocSpace::CosmeticThreadParamDataMessage>() const {
  return Data_as_CosmeticThreadParamDataMessage();
}

template<> inline const FlatBufferDocSpace::SweepPathParamDataMessage *FlatBufferDoc::Data_as<FlatBufferDocSpace::SweepPathParamDataMessage>() const {
  return Data_as_SweepPathParamDataMessage();
}

template<> inline const FlatBufferDocSpace::BoundingBoxData *FlatBufferDoc::Data_as<FlatBufferDocSpace::BoundingBoxData>() const {
  return Data_as_BoundingBoxData();
}

template<> inline const FlatBufferDocSpace::TextureInfoData *FlatBufferDoc::Data_as<FlatBufferDocSpace::TextureInfoData>() const {
  return Data_as_TextureInfoData();
}

template<> inline const FlatBufferDocSpace::TorqueAxisData *FlatBufferDoc::Data_as<FlatBufferDocSpace::TorqueAxisData>() const {
  return Data_as_TorqueAxisData();
}

template<> inline const FlatBufferDocSpace::IncrementalDrawingData *FlatBufferDoc::Data_as<FlatBufferDocSpace::IncrementalDrawingData>() const {
  return Data_as_IncrementalDrawingData();
}

template<> inline const FlatBufferDocSpace::DrawingPreviewData *FlatBufferDoc::Data_as<FlatBufferDocSpace::DrawingPreviewData>() const {
  return Data_as_DrawingPreviewData();
}

template<> inline const FlatBufferDocSpace::SerializeInitData *FlatBufferDoc::Data_as<FlatBufferDocSpace::SerializeInitData>() const {
  return Data_as_SerializeInitData();
}

template<> inline const FlatBufferDocSpace::FolderGroupData *FlatBufferDoc::Data_as<FlatBufferDocSpace::FolderGroupData>() const {
  return Data_as_FolderGroupData();
}

template<> inline const FlatBufferDocSpace::FeatRelations *FlatBufferDoc::Data_as<FlatBufferDocSpace::FeatRelations>() const {
  return Data_as_FeatRelations();
}

template<> inline const FlatBufferDocSpace::DraftAnalysisData *FlatBufferDoc::Data_as<FlatBufferDocSpace::DraftAnalysisData>() const {
  return Data_as_DraftAnalysisData();
}

template<> inline const FlatBufferDocSpace::ThicknessAnalysisData *FlatBufferDoc::Data_as<FlatBufferDocSpace::ThicknessAnalysisData>() const {
  return Data_as_ThicknessAnalysisData();
}

template<> inline const FlatBufferDocSpace::PreviewSimulationData *FlatBufferDoc::Data_as<FlatBufferDocSpace::PreviewSimulationData>() const {
  return Data_as_PreviewSimulationData();
}

template<> inline const FlatBufferDocSpace::ExtRefTree *FlatBufferDoc::Data_as<FlatBufferDocSpace::ExtRefTree>() const {
  return Data_as_ExtRefTree();
}

struct FlatBufferDocBuilder {
  typedef FlatBufferDoc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Data_type(FlatBufferDocSpace::DataMessage Data_type) {
    fbb_.AddElement<uint8_t>(FlatBufferDoc::VT_DATA_TYPE, static_cast<uint8_t>(Data_type), 0);
  }
  void add_Data(flatbuffers::Offset<void> Data) {
    fbb_.AddOffset(FlatBufferDoc::VT_DATA, Data);
  }
  void add_EntityType(int32_t EntityType) {
    fbb_.AddElement<int32_t>(FlatBufferDoc::VT_ENTITYTYPE, EntityType, 0);
  }
  void add_Mode(flatbuffers::Offset<flatbuffers::String> Mode) {
    fbb_.AddOffset(FlatBufferDoc::VT_MODE, Mode);
  }
  void add_Status(int32_t Status) {
    fbb_.AddElement<int32_t>(FlatBufferDoc::VT_STATUS, Status, 0);
  }
  void add_Error(flatbuffers::Offset<FlatBufferDocSpace::ErrorMessage> Error) {
    fbb_.AddOffset(FlatBufferDoc::VT_ERROR, Error);
  }
  void add_RollFeatureId(int32_t RollFeatureId) {
    fbb_.AddElement<int32_t>(FlatBufferDoc::VT_ROLLFEATUREID, RollFeatureId, 0);
  }
  void add_CurrentFeature(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CurrentFeatureData>>> CurrentFeature) {
    fbb_.AddOffset(FlatBufferDoc::VT_CURRENTFEATURE, CurrentFeature);
  }
  void add_SketchWorkState(bool SketchWorkState) {
    fbb_.AddElement<uint8_t>(FlatBufferDoc::VT_SKETCHWORKSTATE, static_cast<uint8_t>(SketchWorkState), 0);
  }
  void add_UndoStepNum(int64_t UndoStepNum) {
    fbb_.AddElement<int64_t>(FlatBufferDoc::VT_UNDOSTEPNUM, UndoStepNum, 0);
  }
  void add_RedoStepNum(int64_t RedoStepNum) {
    fbb_.AddElement<int64_t>(FlatBufferDoc::VT_REDOSTEPNUM, RedoStepNum, 0);
  }
  void add_ModelTime(double ModelTime) {
    fbb_.AddElement<double>(FlatBufferDoc::VT_MODELTIME, ModelTime, 0.0);
  }
  void add_ResultTime(double ResultTime) {
    fbb_.AddElement<double>(FlatBufferDoc::VT_RESULTTIME, ResultTime, 0.0);
  }
  void add_TopDown(flatbuffers::Offset<flatbuffers::String> TopDown) {
    fbb_.AddOffset(FlatBufferDoc::VT_TOPDOWN, TopDown);
  }
  void add_Box(flatbuffers::Offset<flatbuffers::Vector<float>> Box) {
    fbb_.AddOffset(FlatBufferDoc::VT_BOX, Box);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(FlatBufferDoc::VT_NAME, Name);
  }
  void add_PCFDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PipeDocData>>> PCFDatas) {
    fbb_.AddOffset(FlatBufferDoc::VT_PCFDATAS, PCFDatas);
  }
  void add_CutListDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>>> CutListDatas) {
    fbb_.AddOffset(FlatBufferDoc::VT_CUTLISTDATAS, CutListDatas);
  }
  void add_StudySolve(flatbuffers::Offset<FlatBufferDocSpace::StudySolveData> StudySolve) {
    fbb_.AddOffset(FlatBufferDoc::VT_STUDYSOLVE, StudySolve);
  }
  void add_Up(flatbuffers::Offset<flatbuffers::Vector<float>> Up) {
    fbb_.AddOffset(FlatBufferDoc::VT_UP, Up);
  }
  void add_Normal(flatbuffers::Offset<flatbuffers::Vector<float>> Normal) {
    fbb_.AddOffset(FlatBufferDoc::VT_NORMAL, Normal);
  }
  void add_Materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>> Materials) {
    fbb_.AddOffset(FlatBufferDoc::VT_MATERIALS, Materials);
  }
  void add_RepeatEntities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>>> RepeatEntities) {
    fbb_.AddOffset(FlatBufferDoc::VT_REPEATENTITIES, RepeatEntities);
  }
  void add_InstanceInfo(flatbuffers::Offset<FlatBufferDocSpace::InstanceInfoData> InstanceInfo) {
    fbb_.AddOffset(FlatBufferDoc::VT_INSTANCEINFO, InstanceInfo);
  }
  void add_ErrorCurveIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ErrorCurveIds) {
    fbb_.AddOffset(FlatBufferDoc::VT_ERRORCURVEIDS, ErrorCurveIds);
  }
  void add_StudyReport(flatbuffers::Offset<FlatBufferDocSpace::StudyReportData> StudyReport) {
    fbb_.AddOffset(FlatBufferDoc::VT_STUDYREPORT, StudyReport);
  }
  void add_HypUpdate(flatbuffers::Offset<FlatBufferDocSpace::HypUpdateMessage> HypUpdate) {
    fbb_.AddOffset(FlatBufferDoc::VT_HYPUPDATE, HypUpdate);
  }
  void add_DrawingDocData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FlatBufferDrawingDoc>>> DrawingDocData) {
    fbb_.AddOffset(FlatBufferDoc::VT_DRAWINGDOCDATA, DrawingDocData);
  }
  void add_LayerDatasManager(flatbuffers::Offset<FlatBufferDocSpace::LayerDataManager> LayerDatasManager) {
    fbb_.AddOffset(FlatBufferDoc::VT_LAYERDATASMANAGER, LayerDatasManager);
  }
  explicit FlatBufferDocBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlatBufferDocBuilder &operator=(const FlatBufferDocBuilder &);
  flatbuffers::Offset<FlatBufferDoc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlatBufferDoc>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlatBufferDoc> CreateFlatBufferDoc(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::DataMessage Data_type = FlatBufferDocSpace::DataMessage_NONE,
    flatbuffers::Offset<void> Data = 0,
    int32_t EntityType = 0,
    flatbuffers::Offset<flatbuffers::String> Mode = 0,
    int32_t Status = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ErrorMessage> Error = 0,
    int32_t RollFeatureId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CurrentFeatureData>>> CurrentFeature = 0,
    bool SketchWorkState = false,
    int64_t UndoStepNum = 0,
    int64_t RedoStepNum = 0,
    double ModelTime = 0.0,
    double ResultTime = 0.0,
    flatbuffers::Offset<flatbuffers::String> TopDown = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Box = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::PipeDocData>>> PCFDatas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>>> CutListDatas = 0,
    flatbuffers::Offset<FlatBufferDocSpace::StudySolveData> StudySolve = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Up = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Normal = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>> Materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>>> RepeatEntities = 0,
    flatbuffers::Offset<FlatBufferDocSpace::InstanceInfoData> InstanceInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ErrorCurveIds = 0,
    flatbuffers::Offset<FlatBufferDocSpace::StudyReportData> StudyReport = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HypUpdateMessage> HypUpdate = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBufferDocSpace::FlatBufferDrawingDoc>>> DrawingDocData = 0,
    flatbuffers::Offset<FlatBufferDocSpace::LayerDataManager> LayerDatasManager = 0) {
  FlatBufferDocBuilder builder_(_fbb);
  builder_.add_ResultTime(ResultTime);
  builder_.add_ModelTime(ModelTime);
  builder_.add_RedoStepNum(RedoStepNum);
  builder_.add_UndoStepNum(UndoStepNum);
  builder_.add_LayerDatasManager(LayerDatasManager);
  builder_.add_DrawingDocData(DrawingDocData);
  builder_.add_HypUpdate(HypUpdate);
  builder_.add_StudyReport(StudyReport);
  builder_.add_ErrorCurveIds(ErrorCurveIds);
  builder_.add_InstanceInfo(InstanceInfo);
  builder_.add_RepeatEntities(RepeatEntities);
  builder_.add_Materials(Materials);
  builder_.add_Normal(Normal);
  builder_.add_Up(Up);
  builder_.add_StudySolve(StudySolve);
  builder_.add_CutListDatas(CutListDatas);
  builder_.add_PCFDatas(PCFDatas);
  builder_.add_Name(Name);
  builder_.add_Box(Box);
  builder_.add_TopDown(TopDown);
  builder_.add_CurrentFeature(CurrentFeature);
  builder_.add_RollFeatureId(RollFeatureId);
  builder_.add_Error(Error);
  builder_.add_Status(Status);
  builder_.add_Mode(Mode);
  builder_.add_EntityType(EntityType);
  builder_.add_Data(Data);
  builder_.add_SketchWorkState(SketchWorkState);
  builder_.add_Data_type(Data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlatBufferDoc> CreateFlatBufferDocDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FlatBufferDocSpace::DataMessage Data_type = FlatBufferDocSpace::DataMessage_NONE,
    flatbuffers::Offset<void> Data = 0,
    int32_t EntityType = 0,
    const char *Mode = nullptr,
    int32_t Status = 0,
    flatbuffers::Offset<FlatBufferDocSpace::ErrorMessage> Error = 0,
    int32_t RollFeatureId = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CurrentFeatureData>> *CurrentFeature = nullptr,
    bool SketchWorkState = false,
    int64_t UndoStepNum = 0,
    int64_t RedoStepNum = 0,
    double ModelTime = 0.0,
    double ResultTime = 0.0,
    const char *TopDown = nullptr,
    const std::vector<float> *Box = nullptr,
    const char *Name = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::PipeDocData>> *PCFDatas = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>> *CutListDatas = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::StudySolveData> StudySolve = 0,
    const std::vector<float> *Up = nullptr,
    const std::vector<float> *Normal = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>> *Materials = nullptr,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>> *RepeatEntities = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::InstanceInfoData> InstanceInfo = 0,
    const std::vector<int32_t> *ErrorCurveIds = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::StudyReportData> StudyReport = 0,
    flatbuffers::Offset<FlatBufferDocSpace::HypUpdateMessage> HypUpdate = 0,
    const std::vector<flatbuffers::Offset<FlatBufferDocSpace::FlatBufferDrawingDoc>> *DrawingDocData = nullptr,
    flatbuffers::Offset<FlatBufferDocSpace::LayerDataManager> LayerDatasManager = 0) {
  auto Mode__ = Mode ? _fbb.CreateString(Mode) : 0;
  auto CurrentFeature__ = CurrentFeature ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CurrentFeatureData>>(*CurrentFeature) : 0;
  auto TopDown__ = TopDown ? _fbb.CreateString(TopDown) : 0;
  auto Box__ = Box ? _fbb.CreateVector<float>(*Box) : 0;
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto PCFDatas__ = PCFDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::PipeDocData>>(*PCFDatas) : 0;
  auto CutListDatas__ = CutListDatas ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::CutGroupData>>(*CutListDatas) : 0;
  auto Up__ = Up ? _fbb.CreateVector<float>(*Up) : 0;
  auto Normal__ = Normal ? _fbb.CreateVector<float>(*Normal) : 0;
  auto Materials__ = Materials ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::MaterialData>>(*Materials) : 0;
  auto RepeatEntities__ = RepeatEntities ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::RepeatGroupData>>(*RepeatEntities) : 0;
  auto ErrorCurveIds__ = ErrorCurveIds ? _fbb.CreateVector<int32_t>(*ErrorCurveIds) : 0;
  auto DrawingDocData__ = DrawingDocData ? _fbb.CreateVector<flatbuffers::Offset<FlatBufferDocSpace::FlatBufferDrawingDoc>>(*DrawingDocData) : 0;
  return FlatBufferDocSpace::CreateFlatBufferDoc(
      _fbb,
      Data_type,
      Data,
      EntityType,
      Mode__,
      Status,
      Error,
      RollFeatureId,
      CurrentFeature__,
      SketchWorkState,
      UndoStepNum,
      RedoStepNum,
      ModelTime,
      ResultTime,
      TopDown__,
      Box__,
      Name__,
      PCFDatas__,
      CutListDatas__,
      StudySolve,
      Up__,
      Normal__,
      Materials__,
      RepeatEntities__,
      InstanceInfo,
      ErrorCurveIds__,
      StudyReport,
      HypUpdate,
      DrawingDocData__,
      LayerDatasManager);
}

struct RelIntersDate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelIntersDateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RELCVIDS = 4,
    VT_INTERSINDEX = 6,
    VT_RELPNTS = 8,
    VT_RELSILINDEXS = 10
  };
  const flatbuffers::Vector<int32_t> *RelCvIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_RELCVIDS);
  }
  int32_t IntersIndex() const {
    return GetField<int32_t>(VT_INTERSINDEX, 0);
  }
  const flatbuffers::Vector<double> *RelPnts() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_RELPNTS);
  }
  const flatbuffers::Vector<int32_t> *RelSilIndexs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_RELSILINDEXS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RELCVIDS) &&
           verifier.VerifyVector(RelCvIds()) &&
           VerifyField<int32_t>(verifier, VT_INTERSINDEX) &&
           VerifyOffset(verifier, VT_RELPNTS) &&
           verifier.VerifyVector(RelPnts()) &&
           VerifyOffset(verifier, VT_RELSILINDEXS) &&
           verifier.VerifyVector(RelSilIndexs()) &&
           verifier.EndTable();
  }
};

struct RelIntersDateBuilder {
  typedef RelIntersDate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RelCvIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> RelCvIds) {
    fbb_.AddOffset(RelIntersDate::VT_RELCVIDS, RelCvIds);
  }
  void add_IntersIndex(int32_t IntersIndex) {
    fbb_.AddElement<int32_t>(RelIntersDate::VT_INTERSINDEX, IntersIndex, 0);
  }
  void add_RelPnts(flatbuffers::Offset<flatbuffers::Vector<double>> RelPnts) {
    fbb_.AddOffset(RelIntersDate::VT_RELPNTS, RelPnts);
  }
  void add_RelSilIndexs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> RelSilIndexs) {
    fbb_.AddOffset(RelIntersDate::VT_RELSILINDEXS, RelSilIndexs);
  }
  explicit RelIntersDateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelIntersDateBuilder &operator=(const RelIntersDateBuilder &);
  flatbuffers::Offset<RelIntersDate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelIntersDate>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelIntersDate> CreateRelIntersDate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> RelCvIds = 0,
    int32_t IntersIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> RelPnts = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> RelSilIndexs = 0) {
  RelIntersDateBuilder builder_(_fbb);
  builder_.add_RelSilIndexs(RelSilIndexs);
  builder_.add_RelPnts(RelPnts);
  builder_.add_IntersIndex(IntersIndex);
  builder_.add_RelCvIds(RelCvIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<RelIntersDate> CreateRelIntersDateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *RelCvIds = nullptr,
    int32_t IntersIndex = 0,
    const std::vector<double> *RelPnts = nullptr,
    const std::vector<int32_t> *RelSilIndexs = nullptr) {
  auto RelCvIds__ = RelCvIds ? _fbb.CreateVector<int32_t>(*RelCvIds) : 0;
  auto RelPnts__ = RelPnts ? _fbb.CreateVector<double>(*RelPnts) : 0;
  auto RelSilIndexs__ = RelSilIndexs ? _fbb.CreateVector<int32_t>(*RelSilIndexs) : 0;
  return FlatBufferDocSpace::CreateRelIntersDate(
      _fbb,
      RelCvIds__,
      IntersIndex,
      RelPnts__,
      RelSilIndexs__);
}

inline bool VerifyGeometryData(flatbuffers::Verifier &verifier, const void *obj, GeometryData type) {
  switch (type) {
    case GeometryData_NONE: {
      return true;
    }
    case GeometryData_GeometryPointData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::GeometryPointData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryData_GeomLineData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::GeomLineData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryData_GeomArcData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::GeomArcData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryData_GeomCircleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::GeomCircleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryData_InterPositionNurbsData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::InterPositionNurbsData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryData_NurbsCurveData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::NurbsCurveData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryData_OffsetCurveData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::OffsetCurveData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryData_EllipseArcData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::EllipseArcData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryData_EquationCurvecData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::EquationCurvecData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGeometryDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGeometryData(
        verifier,  values->Get(i), types->GetEnum<GeometryData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAttributeSurfaceData(flatbuffers::Verifier &verifier, const void *obj, AttributeSurfaceData type) {
  switch (type) {
    case AttributeSurfaceData_NONE: {
      return true;
    }
    case AttributeSurfaceData_PlaneSurfaceData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::PlaneSurfaceData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeSurfaceData_CylSurfaceData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::CylSurfaceData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeSurfaceData_RevSrfAttribute: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::RevSrfAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeSurfaceData_TabCylSrfAttribute: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::TabCylSrfAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAttributeSurfaceDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAttributeSurfaceData(
        verifier,  values->Get(i), types->GetEnum<AttributeSurfaceData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAttributeCurveData(flatbuffers::Verifier &verifier, const void *obj, AttributeCurveData type) {
  switch (type) {
    case AttributeCurveData_NONE: {
      return true;
    }
    case AttributeCurveData_AttributeLineData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AttributeLineData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeCurveData_AttributeArcData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AttributeArcData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeCurveData_AttributeEllipseData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AttributeEllipseData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeCurveData_AttributeNurbsData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AttributeNurbsData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeCurveData_AttributeCrvOnSrfData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AttributeCrvOnSrfData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeCurveData_AttributeOffsetData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AttributeOffsetData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeCurveData_AttributeEquationData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AttributeEquationData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAttributeCurveDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAttributeCurveData(
        verifier,  values->Get(i), types->GetEnum<AttributeCurveData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifySimulationEntityData(flatbuffers::Verifier &verifier, const void *obj, SimulationEntityData type) {
  switch (type) {
    case SimulationEntityData_NONE: {
      return true;
    }
    case SimulationEntityData_StudyData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::StudyData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SimulationEntityData_ExternalLoadsData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::ExternalLoadsData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SimulationEntityData_FixturesData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::FixturesData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SimulationEntityData_SimulationMaterialData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SimulationMaterialData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SimulationEntityData_SimulationGridData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SimulationGridData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SimulationEntityData_ConnectionData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::ConnectionData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySimulationEntityDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySimulationEntityData(
        verifier,  values->Get(i), types->GetEnum<SimulationEntityData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyInitDataMessage(flatbuffers::Verifier &verifier, const void *obj, InitDataMessage type) {
  switch (type) {
    case InitDataMessage_NONE: {
      return true;
    }
    case InitDataMessage_InitDataForPart: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::InitDataForPart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InitDataMessage_InitDataForAssembly: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::InitDataForAssembly *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInitDataMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInitDataMessage(
        verifier,  values->Get(i), types->GetEnum<InitDataMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDefineDataMessage(flatbuffers::Verifier &verifier, const void *obj, DefineDataMessage type) {
  switch (type) {
    case DefineDataMessage_NONE: {
      return true;
    }
    case DefineDataMessage_DistanceHandleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::DistanceHandleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DefineDataMessage_AngleHandleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AngleHandleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DefineDataMessage_RadiusHandleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::RadiusHandleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DefineDataMessage_TangentHandleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::TangentHandleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DefineDataMessage_PointHandleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::PointHandleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DefineDataMessage_MatrixHandleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::MatrixHandleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DefineDataMessage_DirectionHandleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::DirectionHandleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DefineDataMessage_DimensionHandleData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::DimensionHandleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDefineDataMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDefineDataMessage(
        verifier,  values->Get(i), types->GetEnum<DefineDataMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDataMessage(flatbuffers::Verifier &verifier, const void *obj, DataMessage type) {
  switch (type) {
    case DataMessage_NONE: {
      return true;
    }
    case DataMessage_IncrementalData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::IncrementalData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_AssemblyPartData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::AssemblyPartData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_InitCmdData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::InitCmdData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_IncrementalCompData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::IncrementalCompData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_SerializePreviewData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SerializePreviewData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_SpecialPreviewInforData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SpecialPreviewInforData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_SketchPreviewData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SketchPreviewData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_SketchCheckData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SketchCheckData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_DatumPreviewData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::DatumPreviewData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_InitOffsetCurveData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::InitOffsetCurveData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_WorkPlaneMatrixData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::WorkPlaneMatrixData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_MeasureInforData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::MeasureInforData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_VariableDataMessage: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::VariableDataMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_DimensionDataInforMessage: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::DimensionDataInforMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_ElementData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::ElementData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_ErrorStringData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::ErrorStringData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_MassPropertyData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::MassPropertyData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_IntegerValue: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::IntegerValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_SaveData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SaveData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_CurvatureData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::CurvatureData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_SurfaceCurvatureData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SurfaceCurvatureData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_IdData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::IdData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_CheckGapData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::CheckGapData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_TotalMassData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::TotalMassData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_CheckVariableData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::CheckVariableData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_ArsPreviewData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::ArsPreviewData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_HoleParamDataMessage: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::HoleParamDataMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_CosmeticThreadParamDataMessage: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::CosmeticThreadParamDataMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_SweepPathParamDataMessage: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SweepPathParamDataMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_BoundingBoxData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::BoundingBoxData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_TextureInfoData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::TextureInfoData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_TorqueAxisData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::TorqueAxisData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_IncrementalDrawingData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::IncrementalDrawingData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_DrawingPreviewData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::DrawingPreviewData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_SerializeInitData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::SerializeInitData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_FolderGroupData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::FolderGroupData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_FeatRelations: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::FeatRelations *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_DraftAnalysisData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::DraftAnalysisData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_ThicknessAnalysisData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::ThicknessAnalysisData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_PreviewSimulationData: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::PreviewSimulationData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataMessage_ExtRefTree: {
      auto ptr = reinterpret_cast<const FlatBufferDocSpace::ExtRefTree *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataMessage(
        verifier,  values->Get(i), types->GetEnum<DataMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline const FlatBufferDocSpace::FlatBufferDoc *GetFlatBufferDoc(const void *buf) {
  return flatbuffers::GetRoot<FlatBufferDocSpace::FlatBufferDoc>(buf);
}

inline const FlatBufferDocSpace::FlatBufferDoc *GetSizePrefixedFlatBufferDoc(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<FlatBufferDocSpace::FlatBufferDoc>(buf);
}

inline bool VerifyFlatBufferDocBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FlatBufferDocSpace::FlatBufferDoc>(nullptr);
}

inline bool VerifySizePrefixedFlatBufferDocBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FlatBufferDocSpace::FlatBufferDoc>(nullptr);
}

inline void FinishFlatBufferDocBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FlatBufferDocSpace::FlatBufferDoc> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFlatBufferDocBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FlatBufferDocSpace::FlatBufferDoc> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FlatBufferDocSpace

#endif  // FLATBUFFERS_GENERATED_SERIALIZATION_FLATBUFFERDOCSPACE_H_
