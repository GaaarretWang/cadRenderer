#version 450
#extension GL_ARB_separate_shader_objects : enable
precision highp float;
#extension GL_EXT_scalar_block_layout : enable
layout(set = 0, binding = 0) buffer OutIndirect {
  	uint indexCount;
  	uint instanceCount;
  	uint firstIndex;
  	int vertexOffset;
  	uint firstInstance;
}outIndirect;

layout(set = 0, binding = 1) buffer InIndirect {
  	uint indexCount;
  	uint instanceCount;
  	uint firstIndex;
  	int vertexOffset;
  	uint firstInstance;
}inIndirect;

struct MatrixData {
    mat4 protoMatrix;
    mat4 modelMatrix;
};

struct InstanceData {
    mat4 protoMatrix;
    mat4 modelMatrix;
    uint highlight;
};

layout(set = 0, binding = 2) buffer InIndirectMatrix {
    MatrixData instanceModelMatrix[];
}inIndirectMatrix;

layout(set = 0, binding = 3) buffer InHighlightData {
    uvec4 data[];
}inHighlightData;

layout(set = 0, binding = 4) buffer OutIndirectMatrix {
    InstanceData instanceModelMatrix[];
}outIndirectMatrix;

layout(set = 0, binding = 5) buffer CameraPlaneInfo{
	vec4 planes[6];
}camera_plane;

layout(std430, set = 0, binding = 6) buffer BBox{
    vec4 min;
    vec4 max;
    vec4 draw_state[];
}bbox;

layout(set = 0, binding = 7) buffer ViewMatrix{
	mat4 view;
	mat4 vp;
}viewMatrix;

layout(set=0, binding=8) uniform sampler2D mipPyramid;

layout (local_size_x = 32) in;

// 判断包围盒是否完全在视锥外（被某个平面完全遮挡）
bool isFullyCulled(vec4[8] points, vec4 plane) {
    for (int i = 0; i < 8; i++) {
        if (dot(points[i].xyz, plane.xyz) + plane.w >= 0.0) {
            return false; // 至少有一个点在平面内侧，未被完全遮挡
        }
    }
    return true; // 所有点都在平面外侧，完全被遮挡
}

void main() {
	uint instanceIndex = gl_GlobalInvocationID.x;
    
    // 确保不超出实例数量范围
    if (instanceIndex >= inIndirect.instanceCount) {
        return;
    }

	// 初始化输出
    if (gl_LocalInvocationID.x == 0 && gl_WorkGroupID.x == 0) {
        outIndirect.instanceCount = 0; // 默认不可见
    }
    barrier(); // 确保初始化完成
    inHighlightData.data[instanceIndex].y = 0;

    if(inHighlightData.data[instanceIndex].z == 1){
        uint prevCount = atomicAdd(outIndirect.instanceCount, 1);
        MatrixData cur_data = inIndirectMatrix.instanceModelMatrix[instanceIndex];
        //cur_data.modelMatrix[3][2] += 1;
        InstanceData out_data;
        out_data.protoMatrix = cur_data.protoMatrix;
        out_data.modelMatrix = cur_data.modelMatrix;
        out_data.highlight = inHighlightData.data[instanceIndex].x;
        outIndirectMatrix.instanceModelMatrix[prevCount] = out_data;

        memoryBarrierBuffer();	
        inHighlightData.data[instanceIndex].y = 1;
    }
}
