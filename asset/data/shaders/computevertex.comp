#version 450
#extension GL_ARB_separate_shader_objects : enable
precision highp float;
#extension GL_EXT_scalar_block_layout : enable
layout(set = 0, binding = 0) buffer OutIndirect {
  	uint indexCount;
  	uint instanceCount;
  	uint firstIndex;
  	int vertexOffset;
  	uint firstInstance;
}outIndirect;

layout(set = 0, binding = 1) buffer InIndirect {
  	uint indexCount;
  	uint instanceCount;
  	uint firstIndex;
  	int vertexOffset;
  	uint firstInstance;
}inIndirect;

struct MatrixData {
    mat4 protoMatrix;
    mat4 modelMatrix;
};

struct InstanceData {
    mat4 protoMatrix;
    mat4 modelMatrix;
    uint highlight;
};

layout(set = 0, binding = 2) buffer InIndirectMatrix {
    MatrixData instanceModelMatrix[];
}inIndirectMatrix;

layout(set = 0, binding = 3) buffer InHighlightData {
    uvec4 data[];
}inHighlightData;

layout(set = 0, binding = 4) buffer OutIndirectMatrix {
    InstanceData instanceModelMatrix[];
}outIndirectMatrix;

layout(set = 0, binding = 5) buffer CameraPlaneInfo{
	vec4 planes[6];
}camera_plane;

layout(std430, set = 0, binding = 6) buffer BBox{
    vec4 min;
    vec4 max;
    float draw_state[];
}bbox;

layout(set = 0, binding = 7) buffer ViewMatrix{
	mat4 view;
	mat4 vp;
}viewMatrix;

layout(set = 0, binding = 8) buffer DepthInfo{
	float view[];
}depthInfo;

layout (local_size_x = 32) in;

// 判断包围盒是否完全在视锥外（被某个平面完全遮挡）
bool isFullyCulled(vec4[8] points, vec4 plane) {
    for (int i = 0; i < 8; i++) {
        if (dot(points[i].xyz, plane.xyz) + plane.w >= 0.0) {
            return false; // 至少有一个点在平面内侧，未被完全遮挡
        }
    }
    return true; // 所有点都在平面外侧，完全被遮挡
}

void main() {
	uint instanceIndex = gl_GlobalInvocationID.x;
    
    // 确保不超出实例数量范围
    if (instanceIndex >= inIndirect.instanceCount) {
        return;
    }

	// 初始化输出
    if (gl_LocalInvocationID.x == 0 && gl_WorkGroupID.x == 0) {
        outIndirect.instanceCount = 0; // 默认不可见
    }
    barrier(); // 确保初始化完成
    inHighlightData.data[instanceIndex].y = 0;

    // 计算包围盒的8个顶点（世界空间）
    vec4 points[8];
    points[0] = vec4(bbox.min.x, bbox.min.y, bbox.min.z, 1.0);
    points[1] = vec4(bbox.min.x, bbox.min.y, bbox.max.z, 1.0);
    points[2] = vec4(bbox.min.x, bbox.max.y, bbox.min.z, 1.0);
    points[3] = vec4(bbox.min.x, bbox.max.y, bbox.max.z, 1.0);
    points[4] = vec4(bbox.max.x, bbox.min.y, bbox.min.z, 1.0);
    points[5] = vec4(bbox.max.x, bbox.min.y, bbox.max.z, 1.0);
    points[6] = vec4(bbox.max.x, bbox.max.y, bbox.min.z, 1.0);
    points[7] = vec4(bbox.max.x, bbox.max.y, bbox.max.z, 1.0);

	mat4 mv = viewMatrix.view * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].modelMatrix * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].protoMatrix;
	mat4 mvp = viewMatrix.vp * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].modelMatrix * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].protoMatrix;
    vec4 viewPoints[8];
    vec4 clipPoints[8];


	for(int i = 0; i < 8; i ++){
		viewPoints[i] = mv * points[i];
		clipPoints[i] = mvp * points[i];
	}


    // 检查是否被任一平面完全遮挡
    bool culled = false;
    for (int p = 0; p < 6; p++) {
        if (isFullyCulled(viewPoints, camera_plane.planes[p])) {
            culled = true;
            break;
        }
    }

    // 如果没有被完全遮挡，则设置实例可见
    if (!culled) {		
        ivec2 imageSize = ivec2(1280, 960);
        for (int i = 0; i < 8; i++) {
            // 透视除法
            vec3 ndc = clipPoints[i].xyz / clipPoints[i].w;
            // 转换为屏幕 UV [0,1]
            vec2 uv = ndc.xy * 0.5 + 0.5;
            uv.x = max(uv.x, 0);
            uv.y = max(uv.y, 0);
            uv.x = min(uv.x, 1);
            uv.y = min(uv.y, 1);

            // 计算深度（Vulkan 深度范围 [0,1]）
            float depth = ndc.z;
            ivec2 texel = ivec2(uv * imageSize);
            float render_depth = depthInfo.view[texel.y * imageSize.x + texel.x];
            if(render_depth <= depth){
                uint prevCount = atomicAdd(outIndirect.instanceCount, 1);
                MatrixData cur_data = inIndirectMatrix.instanceModelMatrix[instanceIndex];
                //cur_data.modelMatrix[3][2] += 1;
                InstanceData out_data;
                out_data.protoMatrix = cur_data.protoMatrix;
                out_data.modelMatrix = cur_data.modelMatrix;
                out_data.highlight = inHighlightData.data[instanceIndex].x;
                outIndirectMatrix.instanceModelMatrix[prevCount] = out_data;
    
                memoryBarrierBuffer();	
                inHighlightData.data[instanceIndex].y = 1;
                return;
            }
        }
    }
}
