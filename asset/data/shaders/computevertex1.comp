#version 450
#extension GL_ARB_separate_shader_objects : enable
precision highp float;
#extension GL_EXT_scalar_block_layout : enable
layout(set = 0, binding = 0) buffer OutIndirect {
  	uint indexCount;
  	uint instanceCount;
  	uint firstIndex;
  	int vertexOffset;
  	uint firstInstance;
}outIndirect;

layout(set = 0, binding = 1) buffer InIndirect {
  	uint indexCount;
  	uint instanceCount;
  	uint firstIndex;
  	int vertexOffset;
  	uint firstInstance;
}inIndirect;

struct MatrixData {
    mat4 protoMatrix;
    mat4 modelMatrix;
};

struct InstanceData {
    mat4 protoMatrix;
    mat4 modelMatrix;
    uint highlight;
};

layout(set = 0, binding = 2) buffer InIndirectMatrix {
    MatrixData instanceModelMatrix[];
}inIndirectMatrix;

layout(set = 0, binding = 3) buffer InHighlightData {
    uvec4 data[];
}inHighlightData;

layout(set = 0, binding = 4) buffer OutIndirectMatrix {
    InstanceData instanceModelMatrix[];
}outIndirectMatrix;

layout(set = 0, binding = 5) buffer CameraPlaneInfo{
	vec4 planes[6];
}camera_plane;

layout(std430, set = 0, binding = 6) buffer BBox{
    vec4 min;
    vec4 max;
    vec4 draw_state;
}bbox;

layout(set = 0, binding = 7) buffer ViewMatrix{
	mat4 view;
	mat4 vp;
}viewMatrix;

layout(set=0, binding = 8) uniform sampler2D mipPyramid;

layout (local_size_x = 32) in;

// 判断包围盒是否完全在视锥外（被某个平面完全遮挡）
bool isFullyCulled(vec4[8] points, vec4 plane) {
    for (int i = 0; i < 8; i++) {
        if (dot(points[i].xyz, plane.xyz) + plane.w >= 0.0) {
            return false; // 至少有一个点在平面内侧，未被完全遮挡
        }
    }
    return true; // 所有点都在平面外侧，完全被遮挡
}

void main() {
	uint instanceIndex = gl_GlobalInvocationID.x;
    
    // 确保不超出实例数量范围
    if (instanceIndex >= inIndirect.instanceCount) {
        return;
    }

	// 初始化输出
    if (gl_LocalInvocationID.x == 0 && gl_WorkGroupID.x == 0) {
        outIndirect.instanceCount = 0; // 默认不可见
    }
    barrier(); // 确保初始化完成

    // 计算包围盒的8个顶点（世界空间）
    vec4 points[8];
    points[0] = vec4(bbox.min.x, bbox.min.y, bbox.min.z, 1.0);
    points[1] = vec4(bbox.min.x, bbox.min.y, bbox.max.z, 1.0);
    points[2] = vec4(bbox.min.x, bbox.max.y, bbox.min.z, 1.0);
    points[3] = vec4(bbox.min.x, bbox.max.y, bbox.max.z, 1.0);
    points[4] = vec4(bbox.max.x, bbox.min.y, bbox.min.z, 1.0);
    points[5] = vec4(bbox.max.x, bbox.min.y, bbox.max.z, 1.0);
    points[6] = vec4(bbox.max.x, bbox.max.y, bbox.min.z, 1.0);
    points[7] = vec4(bbox.max.x, bbox.max.y, bbox.max.z, 1.0);

	mat4 mv = viewMatrix.view * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].modelMatrix * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].protoMatrix;
	mat4 mvp = viewMatrix.vp * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].modelMatrix * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].protoMatrix;
    vec4 viewPoints[8];
    vec4 clipPoints[8];


	for(int i = 0; i < 8; i ++){
		viewPoints[i] = mv * points[i];
		clipPoints[i] = mvp * points[i];
	}


    // 检查是否被任一平面完全遮挡
    bool culled = false;
    for (int p = 0; p < 6; p++) {
        if (isFullyCulled(viewPoints, camera_plane.planes[p])) {
            culled = true;
            break;
        }
    }

    // 如果没有被完全遮挡，则设置实例可见
    if (!culled) {		
        ivec2 imageSize = ivec2(1280, 960);

        vec3 ndc_min = vec3(100.0);
        vec3 ndc_max = vec3(-100.0);
        vec3 ndcs[8];
        for (int i = 0; i < 8; i++) {
            ndcs[i] = clipPoints[i].xyz / clipPoints[i].w;
            ndc_min.x = min(ndc_min.x, ndcs[i].x);
            ndc_min.y = min(ndc_min.y, ndcs[i].y);
            ndc_min.z = min(ndc_min.z, ndcs[i].z);
            ndc_max.x = max(ndc_max.x, ndcs[i].x);
            ndc_max.y = max(ndc_max.y, ndcs[i].y);
            ndc_max.z = max(ndc_max.z, ndcs[i].z);
        }
        float x_bound = (ndc_max.x - ndc_min.x) * 0.5;
        float y_bound = (ndc_max.y - ndc_min.y) * 0.5;
        float uvWidth  = x_bound * imageSize.x;   // 物体在纹理空间覆盖的宽度（像素）
        float uvHeight = y_bound * imageSize.y;  // 物体在纹理空间覆盖的高度（像素）

        // 计算Mip Level（取最大边长的对数）
        float maxCoverage = max(uvWidth, uvHeight);
        int mipLevel = int(floor(log2(maxCoverage)));
        mipLevel = clamp(mipLevel, 0, 6);

        vec2 uv_min = ndc_min.xy * 0.5 + 0.5;
        vec2 uv_max = ndc_max.xy * 0.5 + 0.5;
        uv_min = min(max(uv_min, vec2(0)), vec2(1));
        uv_max = min(max(uv_max, vec2(0)), vec2(1));

        bool depth_culled = false;
        float render_depth0 = textureLod(mipPyramid, vec2(uv_min.x, uv_min.y), mipLevel).x;
        float render_depth1 = textureLod(mipPyramid, vec2(uv_min.x, uv_max.y), mipLevel).x;
        float render_depth2 = textureLod(mipPyramid, vec2(uv_max.x, uv_min.y), mipLevel).x;
        float render_depth3 = textureLod(mipPyramid, vec2(uv_max.x, uv_max.y), mipLevel).x;
        float box_nearest_depth = ndc_max.z;

        if(box_nearest_depth < render_depth0 && box_nearest_depth < render_depth1 && box_nearest_depth < render_depth2 && box_nearest_depth < render_depth3)
            depth_culled = true;

        if(depth_culled){
            inHighlightData.data[instanceIndex].z = 0;
        }else{
            inHighlightData.data[instanceIndex].z = 1;
        }


        if(inHighlightData.data[instanceIndex].y == 0){
            if(!depth_culled){
                uint prevCount = atomicAdd(outIndirect.instanceCount, 1);
                MatrixData cur_data = inIndirectMatrix.instanceModelMatrix[instanceIndex];
                InstanceData out_data;
                out_data.protoMatrix = cur_data.protoMatrix;
                out_data.modelMatrix = cur_data.modelMatrix;
                out_data.highlight = inHighlightData.data[instanceIndex].x;
                outIndirectMatrix.instanceModelMatrix[prevCount] = out_data;
    
                memoryBarrierBuffer();	
            }
        }
    }else{
        inHighlightData.data[instanceIndex].z = 0;
    }
}
