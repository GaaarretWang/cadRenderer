#version 450
#extension GL_ARB_separate_shader_objects : enable
precision highp float;
#extension GL_EXT_scalar_block_layout : enable
layout(set = 0, binding = 0) buffer OutIndirect {
  	uint indexCount;
  	uint instanceCount;
  	uint firstIndex;
  	int vertexOffset;
  	uint firstInstance;
}outIndirect;

layout(set = 0, binding = 1) buffer InIndirect {
  	uint indexCount;
  	uint instanceCount;
  	uint firstIndex;
  	int vertexOffset;
  	uint firstInstance;
}inIndirect;

struct InstanceData {
    mat4 protoMatrix;
    mat4 modelMatrix;
};

layout(set = 0, binding = 2) buffer InIndirectMatrix {
    InstanceData instanceModelMatrix[2];
}inIndirectMatrix;

layout(set = 0, binding = 3) buffer OutIndirectMatrix {
    InstanceData instanceModelMatrix[2];
}outIndirectMatrix;

layout(set = 0, binding = 4) buffer CameraPlaneInfo{
	vec4 planes[6];
}camera_plane;

layout(std430, set = 0, binding = 5) buffer BBox{
    vec4 min;
    vec4 max;
}bbox;

layout(set = 0, binding = 6) buffer ViewMatrix{
	mat4 view;
}viewMatrix;

layout (local_size_x = 32) in;

// 判断包围盒是否完全在视锥外（被某个平面完全遮挡）
bool isFullyCulled(vec4[8] points, vec4 plane) {
    for (int i = 0; i < 8; i++) {
        if (dot(points[i].xyz, plane.xyz) + plane.w >= 0.0) {
            return false; // 至少有一个点在平面内侧，未被完全遮挡
        }
    }
    return true; // 所有点都在平面外侧，完全被遮挡
}

void main() {
	uint instanceIndex = gl_GlobalInvocationID.x;
    
    // 确保不超出实例数量范围
    if (instanceIndex >= inIndirect.instanceCount) {
        return;
    }

	// 初始化输出
    if (gl_LocalInvocationID.x == 0 && gl_WorkGroupID.x == 0) {
        outIndirect.instanceCount = 0; // 默认不可见
    }
    barrier(); // 确保初始化完成

    // 计算包围盒的8个顶点（世界空间）
    vec4 points[8];
    points[0] = vec4(bbox.min.x, bbox.min.y, bbox.min.z, 1.0);
    points[1] = vec4(bbox.min.x, bbox.min.y, bbox.max.z, 1.0);
    points[2] = vec4(bbox.min.x, bbox.max.y, bbox.min.z, 1.0);
    points[3] = vec4(bbox.min.x, bbox.max.y, bbox.max.z, 1.0);
    points[4] = vec4(bbox.max.x, bbox.min.y, bbox.min.z, 1.0);
    points[5] = vec4(bbox.max.x, bbox.min.y, bbox.max.z, 1.0);
    points[6] = vec4(bbox.max.x, bbox.max.y, bbox.min.z, 1.0);
    points[7] = vec4(bbox.max.x, bbox.max.y, bbox.max.z, 1.0);

	mat4 mv = viewMatrix.view * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].modelMatrix * 
					inIndirectMatrix.instanceModelMatrix[instanceIndex].protoMatrix;
	
	for(int i = 0; i < 8; i ++){
		points[i] = mv * points[i];
	}


    // 检查是否被任一平面完全遮挡
    bool culled = false;
    for (int p = 0; p < 6; p++) {
        if (isFullyCulled(points, camera_plane.planes[p])) {
            culled = true;
            break;
        }
    }

    // 如果没有被完全遮挡，则设置实例可见
    if (!culled && instanceIndex == 1) {		
        uint prevCount = atomicAdd(outIndirect.instanceCount, 1);
        outIndirectMatrix.instanceModelMatrix[prevCount] = 
            inIndirectMatrix.instanceModelMatrix[instanceIndex];
        
        memoryBarrierBuffer();	
    }
}
